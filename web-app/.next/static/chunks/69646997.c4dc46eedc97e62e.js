"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[995],{9445:function(t,e,a){let i,n;a.r(e),a.d(e,{curves:function(){return V},fflonk:function(){return aR},groth16:function(){return er},plonk:function(){return ap},powersOfTau:function(){return ev},r1cs:function(){return eR},wtns:function(){return eM},zKey:function(){return at}});var r,o,l=a(5162),s=a(5566),u={};async function f(t,e,a,i){if(a=a||262144,"number"!=typeof e&&0>["w+","wx+","r","ax+","a+"].indexOf(e))throw Error("Invalid open option");let n=await u.promises.open(t,e),r=await n.stat();return new g(n,r,a,i,t)}class g{constructor(t,e,a,i,n){for(this.fileName=n,this.fd=t,this.pos=0,this.pageSize=i||256;this.pageSize<e.blksize;)this.pageSize*=2;this.totalSize=e.size,this.totalPages=Math.floor((e.size-1)/this.pageSize)+1,this.maxPagesLoaded=Math.floor(a/this.pageSize)+1,this.pages={},this.pendingLoads=[],this.writing=!1,this.reading=!1,this.avBuffs=[],this.history={}}_loadPage(t){let e=this,a=new Promise((a,i)=>{e.pendingLoads.push({page:t,resolve:a,reject:i})});return e.__statusPage("After Load request: ",t),a}__statusPage(t,e){let a=[];if(!this.logHistory)return;a.push("=="+t+" "+e);let i="";for(let t=0;t<this.pendingLoads.length;t++)this.pendingLoads[t].page==e&&(i=i+" "+t);if(i&&a.push("Pending loads:"+i),void 0!==this.pages[e]){let t=this.pages[e];a.push("Loaded"),a.push("pendingOps: "+t.pendingOps),t.loading&&a.push("loading: "+t.loading),t.writing&&a.push("writing"),t.dirty&&a.push("dirty")}a.push("=="),this.history[e]||(this.history[e]=[]),this.history[e].push(a)}__printHistory(t){this.history[t]||console.log("Empty History ",t),console.log("History "+t);for(let e=0;e<this.history[t].length;e++)for(let a=0;a<this.history[t][e].length;a++)console.log("-> "+this.history[t][e][a])}_triggerLoad(){let t=this;if(t.reading||0==t.pendingLoads.length)return;let e=Object.keys(t.pages),a=[];for(let i=0;i<e.length;i++){let n=t.pages[parseInt(e[i])];!1!=n.dirty||0!=n.pendingOps||n.writing||n.loading||a.push(parseInt(e[i]))}let i=t.maxPagesLoaded-e.length,n=[];for(;t.pendingLoads.length>0&&(void 0!==t.pages[t.pendingLoads[0].page]||i>0||a.length>0);){let e=t.pendingLoads.shift();if(void 0!==t.pages[e.page]){t.pages[e.page].pendingOps++;let i=a.indexOf(e.page);i>=0&&a.splice(i,1),t.pages[e.page].loading?t.pages[e.page].loading.push(e):e.resolve(),t.__statusPage("After Load (cached): ",e.page)}else{if(i)i--;else{let e=a.shift();t.__statusPage("Before Unload: ",e),t.avBuffs.unshift(t.pages[e]),delete t.pages[e],t.__statusPage("After Unload: ",e)}e.page>=t.totalPages?(t.pages[e.page]=r(),e.resolve(),t.__statusPage("After Load (new): ",e.page)):(t.reading=!0,t.pages[e.page]=r(),t.pages[e.page].loading=[e],n.push(t.fd.read(t.pages[e.page].buff,0,t.pageSize,e.page*t.pageSize).then(a=>{t.pages[e.page].size=a.bytesRead;let i=t.pages[e.page].loading;delete t.pages[e.page].loading;for(let t=0;t<i.length;t++)i[t].resolve();return t.__statusPage("After Load (loaded): ",e.page),a},t=>{e.reject(t)})),t.__statusPage("After Load (loading): ",e.page))}}function r(){if(!(t.avBuffs.length>0))return{dirty:!1,buff:new Uint8Array(t.pageSize),pendingOps:1,size:0};{let e=t.avBuffs.shift();return e.dirty=!1,e.pendingOps=1,e.size=0,e}}Promise.all(n).then(()=>{t.reading=!1,t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t)),t._tryClose()})}_triggerWrite(){let t=this;if(t.writing)return;let e=Object.keys(t.pages),a=[];for(let i=0;i<e.length;i++){let n=t.pages[parseInt(e[i])];n.dirty&&(n.dirty=!1,n.writing=!0,t.writing=!0,a.push(t.fd.write(n.buff,0,n.size,parseInt(e[i])*t.pageSize).then(()=>{n.writing=!1},e=>{console.log("ERROR Writing: "+e),t.error=e,t._tryClose()})))}t.writing&&Promise.all(a).then(()=>{t.writing=!1,setImmediate(t._triggerWrite.bind(t)),t._tryClose(),t.pendingLoads.length>0&&setImmediate(t._triggerLoad.bind(t))})}_getDirtyPage(){for(let t in this.pages)if(this.pages[t].dirty)return t;return -1}async write(t,e){if(0==t.byteLength)return;if(void 0===e&&(e=this.pos),this.pos=e+t.byteLength,this.totalSize<e+t.byteLength&&(this.totalSize=e+t.byteLength),this.pendingClose)throw Error("Writing a closing file");let a=Math.floor(e/this.pageSize),i=Math.floor((e+t.byteLength-1)/this.pageSize),n=[];for(let t=a;t<=i;t++)n.push(this._loadPage(t));this._triggerLoad();let r=a,o=e%this.pageSize,l=t.byteLength;for(;l>0;){await n[r-a];let e=o+l>this.pageSize?this.pageSize-o:l,i=t.slice(t.byteLength-l,t.byteLength-l+e);new Uint8Array(this.pages[r].buff.buffer,o,e).set(i),this.pages[r].dirty=!0,this.pages[r].pendingOps--,this.pages[r].size=Math.max(o+e,this.pages[r].size),r>=this.totalPages&&(this.totalPages=r+1),l-=e,r++,o=0,this.writing||setImmediate(this._triggerWrite.bind(this))}}async read(t,e){let a=new Uint8Array(t);return await this.readToBuffer(a,0,t,e),a}async readToBuffer(t,e,a,i){if(0==a)return;if(a>this.pageSize*this.maxPagesLoaded*.8&&(this.maxPagesLoaded=Math.floor(Math.floor(1.1*a)/this.pageSize)+1),void 0===i&&(i=this.pos),this.pos=i+a,this.pendingClose)throw Error("Reading a closing file");let n=Math.floor(i/this.pageSize),r=Math.floor((i+a-1)/this.pageSize),o=[];for(let t=n;t<=r;t++)o.push(this._loadPage(t));this._triggerLoad();let l=n,s=i%this.pageSize,u=i+a>this.totalSize?a-(i+a-this.totalSize):a;for(;u>0;){await o[l-n],this.__statusPage("After Await (read): ",l);let i=s+u>this.pageSize?this.pageSize-s:u,r=new Uint8Array(this.pages[l].buff.buffer,this.pages[l].buff.byteOffset+s,i);t.set(r,e+a-u),this.pages[l].pendingOps--,this.__statusPage("After Op done: ",l),u-=i,l++,s=0,this.pendingLoads.length>0&&setImmediate(this._triggerLoad.bind(this))}this.pos=i+a}_tryClose(){this.pendingClose&&(this.error&&this.pendingCloseReject(this.error),this._getDirtyPage()>=0||this.writing||this.reading||this.pendingLoads.length>0||this.pendingClose())}close(){let t=this;if(t.pendingClose)throw Error("Closing the file twice");return new Promise((e,a)=>{t.pendingClose=e,t.pendingCloseReject=a,t._tryClose()}).then(()=>{t.fd.close()},e=>{throw t.fd.close(),e})}async discard(){await this.close(),await u.promises.unlink(this.fileName)}async writeULE32(t,e){let a=new Uint8Array(4);new DataView(a.buffer).setUint32(0,t,!0),await this.write(a,e)}async writeUBE32(t,e){let a=new Uint8Array(4);new DataView(a.buffer).setUint32(0,t,!1),await this.write(a,e)}async writeULE64(t,e){let a=new Uint8Array(8),i=new DataView(a.buffer);i.setUint32(0,4294967295&t,!0),i.setUint32(4,Math.floor(t/4294967296),!0),await this.write(a,e)}async readULE32(t){return new Uint32Array((await this.read(4,t)).buffer)[0]}async readUBE32(t){return new DataView((await this.read(4,t)).buffer).getUint32(0,!1)}async readULE64(t){let e=new Uint32Array((await this.read(8,t)).buffer);return 4294967296*e[1]+e[0]}async readString(t){if(this.pendingClose)throw Error("Reading a closing file");let e=void 0===t?this.pos:t,a=Math.floor(e/this.pageSize),i=!1,n="";for(;!i;){let t=this._loadPage(a);this._triggerLoad(),await t,this.__statusPage("After Await (read): ",a);let r=e%this.pageSize,o=new Uint8Array(this.pages[a].buff.buffer,this.pages[a].buff.byteOffset+r,this.pageSize-r),l=o.findIndex(t=>0===t);(i=-1!==l)?(n+=new TextDecoder().decode(o.slice(0,l)),this.pos=a*this.pageSize+r+l+1):(n+=new TextDecoder().decode(o),this.pos=a*this.pageSize+r+o.length),this.pages[a].pendingOps--,this.__statusPage("After Op done: ",a),e=this.pos,a++,this.pendingLoads.length>0&&setImmediate(this._triggerLoad.bind(this))}return n}}let h=new Uint8Array(4),w=new DataView(h.buffer),c=new Uint8Array(8),d=new DataView(c.buffer);class m{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t>this.allocSize){let e=Math.max(this.allocSize+1048576,Math.floor(1.1*this.allocSize),t),a=new Uint8Array(e);a.set(this.o.data),this.o.data=a,this.allocSize=e}}async write(t,e){if(void 0===e&&(e=this.pos),this.readOnly)throw Error("Writing a read only file");this._resizeIfNeeded(e+t.byteLength),this.o.data.set(t.slice(),e),e+t.byteLength>this.totalSize&&(this.totalSize=e+t.byteLength),this.pos=e+t.byteLength}async readToBuffer(t,e,a,i){if(void 0===i&&(i=this.pos),this.readOnly&&i+a>this.totalSize)throw Error("Reading out of bounds");this._resizeIfNeeded(i+a);let n=new Uint8Array(this.o.data.buffer,this.o.data.byteOffset+i,a);t.set(n,e),this.pos=i+a}async read(t,e){let a=new Uint8Array(t);return await this.readToBuffer(a,0,t,e),a}close(){this.o.data.byteLength!=this.totalSize&&(this.o.data=this.o.data.slice(0,this.totalSize))}async discard(){}async writeULE32(t,e){w.setUint32(0,t,!0),await this.write(h,e)}async writeUBE32(t,e){w.setUint32(0,t,!1),await this.write(h,e)}async writeULE64(t,e){d.setUint32(0,4294967295&t,!0),d.setUint32(4,Math.floor(t/4294967296),!0),await this.write(c,e)}async readULE32(t){return new Uint32Array((await this.read(4,t)).buffer)[0]}async readUBE32(t){return new DataView((await this.read(4,t)).buffer).getUint32(0,!1)}async readULE64(t){let e=new Uint32Array((await this.read(8,t)).buffer);return 4294967296*e[1]+e[0]}async readString(t){let e=void 0===t?this.pos:t;if(e>this.totalSize){if(this.readOnly)throw Error("Reading out of bounds");this._resizeIfNeeded(t)}let a=new Uint8Array(this.o.data.buffer,e,this.totalSize-e),i=a.findIndex(t=>0===t),n="";return -1!==i?(n=new TextDecoder().decode(a.slice(0,i)),this.pos=e+i+1):this.pos=e,n}}let A=new Uint8Array(4),p=new DataView(A.buffer),y=new Uint8Array(8),I=new DataView(y.buffer);class b{constructor(){this.pageSize=16384}_resizeIfNeeded(t){if(t<=this.totalSize)return;if(this.readOnly)throw Error("Reading out of file bounds");let e=Math.floor((t-1)/4194304)+1;for(let a=Math.max(this.o.data.length-1,0);a<e;a++){let i=new Uint8Array(a<e-1?4194304:t-(e-1)*4194304);a==this.o.data.length-1&&i.set(this.o.data[a]),this.o.data[a]=i}this.totalSize=t}async write(t,e){if(void 0===e&&(e=this.pos),this.readOnly)throw Error("Writing a read only file");this._resizeIfNeeded(e+t.byteLength);let a=Math.floor(e/4194304),i=e%4194304,n=t.byteLength;for(;n>0;){let e=i+n>4194304?4194304-i:n,r=t.slice(t.byteLength-n,t.byteLength-n+e);new Uint8Array(this.o.data[a].buffer,i,e).set(r),n-=e,a++,i=0}this.pos=e+t.byteLength}async readToBuffer(t,e,a,i){if(void 0===i&&(i=this.pos),this.readOnly&&i+a>this.totalSize)throw Error("Reading out of bounds");this._resizeIfNeeded(i+a);let n=Math.floor(i/4194304),r=i%4194304,o=a;for(;o>0;){let i=r+o>4194304?4194304-r:o,l=new Uint8Array(this.o.data[n].buffer,r,i);t.set(l,e+a-o),o-=i,n++,r=0}this.pos=i+a}async read(t,e){let a=new Uint8Array(t);return await this.readToBuffer(a,0,t,e),a}close(){}async discard(){}async writeULE32(t,e){p.setUint32(0,t,!0),await this.write(A,e)}async writeUBE32(t,e){p.setUint32(0,t,!1),await this.write(A,e)}async writeULE64(t,e){I.setUint32(0,4294967295&t,!0),I.setUint32(4,Math.floor(t/4294967296),!0),await this.write(y,e)}async readULE32(t){return new Uint32Array((await this.read(4,t)).buffer)[0]}async readUBE32(t){return new DataView((await this.read(4,t)).buffer).getUint32(0,!1)}async readULE64(t){let e=new Uint32Array((await this.read(8,t)).buffer);return 4294967296*e[1]+e[0]}async readString(t){let e=void 0===t?this.pos:t;if(e>this.totalSize){if(this.readOnly)throw Error("Reading out of bounds");this._resizeIfNeeded(t)}let a=!1,i="";for(;!a;){let t=Math.floor(e/4194304),n=e%4194304;if(void 0===this.o.data[t])throw Error("ERROR");let r=Math.min(2048,this.o.data[t].length-n),o=new Uint8Array(this.o.data[t].buffer,n,r),l=o.findIndex(t=>0===t);(a=-1!==l)?(i+=new TextDecoder().decode(o.slice(0,l)),this.pos=4194304*t+n+l+1):(i+=new TextDecoder().decode(o),this.pos=4194304*t+n+o.length),e=this.pos}return i}}async function C(t,e,a){if("string"==typeof t&&(t={type:"file",fileName:t,cacheSize:e||65536,pageSize:a||8192}),"file"==t.type)return await f(t.fileName,1538,t.cacheSize,t.pageSize);if("mem"==t.type)return function(t){let e=t.initialSize||1048576,a=new m;return a.o=t,a.o.data=new Uint8Array(e),a.allocSize=e,a.totalSize=0,a.readOnly=!1,a.pos=0,a}(t);if("bigMem"==t.type)return function(t){let e=t.initialSize||0,a=new b;a.o=t;let i=e?Math.floor((e-1)/4194304)+1:0;a.o.data=[];for(let t=0;t<i-1;t++)a.o.data.push(new Uint8Array(4194304));return i&&a.o.data.push(new Uint8Array(e-4194304*(i-1))),a.totalSize=0,a.readOnly=!1,a.pos=0,a}(t);throw Error("Invalid FastFile type: "+t.type)}async function E(t,e,a){if(t instanceof Uint8Array&&(t={type:"mem",data:t}),"string"==typeof t&&(t={type:"mem",data:await fetch(t).then(function(t){return t.arrayBuffer()}).then(function(t){return new Uint8Array(t)})}),"file"==t.type)return await f(t.fileName,0,t.cacheSize,t.pageSize);if("mem"==t.type)return await function(t){let e=new m;return e.o=t,e.allocSize=t.data.byteLength,e.totalSize=t.data.byteLength,e.readOnly=!0,e.pos=0,e}(t);if("bigMem"==t.type)return await function(t){let e=new b;return e.o=t,e.totalSize=(t.data.length-1)*4194304+t.data[t.data.length-1].byteLength,e.readOnly=!0,e.pos=0,e}(t);throw Error("Invalid FastFile type: "+t.type)}async function S(t,e,a,i,n){let r=await E(t),o=await r.read(4),l="";for(let t=0;t<4;t++)l+=String.fromCharCode(o[t]);if(l!=e)throw Error(t+": Invalid File format");if(await r.readULE32()>a)throw Error("Version not supported");let s=await r.readULE32(),u=[];for(let t=0;t<s;t++){let t=await r.readULE32(),e=await r.readULE64();void 0===u[t]&&(u[t]=[]),u[t].push({p:r.pos,size:e}),r.pos+=e}return{fd:r,sections:u}}async function v(t,e,a,i,n,r){let o=await C(t,n,r),l=new Uint8Array(4);for(let t=0;t<4;t++)l[t]=e.charCodeAt(t);return await o.write(l,0),await o.writeULE32(a),await o.writeULE32(i),o}async function F(t,e){if(void 0!==t.writingSection)throw Error("Already writing a section");await t.writeULE32(e),t.writingSection={pSectionSize:t.pos},await t.writeULE64(0)}async function B(t){if(void 0===t.writingSection)throw Error("Not writing a section");let e=t.pos-t.writingSection.pSectionSize-8,a=t.pos;t.pos=t.writingSection.pSectionSize,await t.writeULE64(e),t.pos=a,delete t.writingSection}async function G(t,e,a){if(void 0!==t.readingSection)throw Error("Already reading a section");if(!e[a])throw Error(t.fileName+": Missing section "+a);if(e[a].length>1)throw Error(t.fileName+": Section Duplicated "+a);t.pos=e[a][0].p,t.readingSection=e[a][0]}async function Q(t,e){if(void 0===t.readingSection)throw Error("Not reading a section");if(!e&&t.pos-t.readingSection.p!=t.readingSection.size)throw Error("Invalid section size reading");delete t.readingSection}async function x(t,e,a,i){let n=new Uint8Array(a);l.Ru.toRprLE(n,0,e,a),await t.write(n,i)}async function L(t,e,a){let i=await t.read(e,a);return l.Ru.fromRprLE(i,0,e)}async function U(t,e,a,i,n){void 0===n&&(n=e[i][0].size);let r=t.pageSize;await G(t,e,i),await F(a,i);for(let e=0;e<n;e+=r){let i=Math.min(n-e,r),o=await t.read(i);await a.write(o)}await B(a),await Q(t,n!=e[i][0].size)}async function _(t,e,a,i,n){let r;if(i=void 0===i?0:i,n=void 0===n?e[a][0].size-i:n,i+n>e[a][0].size)throw Error("Reading out of the range of the section");return r=n<1073741824?new Uint8Array(n):new l.qc(n),await t.readToBuffer(r,0,n,e[a][0].p+i),r}async function T(t,e,a,i,n){let r=16*t.pageSize;if(await G(t,e,n),await G(a,i,n),e[n][0].size!=i[n][0].size)return!1;let o=e[n][0].size;for(let e=0;e<o;e+=r){let i=Math.min(o-e,r),n=await t.read(i),l=await a.read(i);for(let t=0;t<i;t++)if(n[t]!=l[t])return!1}return await Q(t),await Q(a),!0}let z=l.Ru.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),P=l.Ru.e("21888242871839275222246405745257275088548364400416034343698204186575808495617"),D=l.Ru.e("1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab",16),R=l.Ru.e("21888242871839275222246405745257275088696311157297823662689037894645226208583");async function k(t,e){let a;let i=e&&e.singleThread;if(l.Ru.eq(t,P))a=await (0,l.SO)(i);else if(l.Ru.eq(t,z))a=await (0,l.ev)(i);else throw Error(`Curve not supported: ${l.Ru.toString(t)}`);return a}async function O(t,e){let a;let i=e&&e.singleThread;if(l.Ru.eq(t,R))a=await (0,l.SO)(i);else if(l.Ru.eq(t,D))a=await (0,l.ev)(i);else throw Error(`Curve not supported: ${l.Ru.toString(t)}`);return a}async function M(t,e){let a;let i=e&&e.singleThread,n=t.toUpperCase().match(/[A-Za-z0-9]+/g).join("");if(["BN128","BN254","ALTBN128"].indexOf(n)>=0)a=await (0,l.SO)(i);else if(["BLS12381"].indexOf(n)>=0)a=await (0,l.ev)(i);else throw Error(`Curve not supported: ${t}`);return a}var V=Object.freeze({__proto__:null,getCurveFromR:k,getCurveFromQ:O,getCurveFromName:M}),q="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{},K={exports:{}};class $ extends Error{}$.prototype.name="AssertionError";var H={exports:{}};function N(t){return t.length}var j={byteLength:N,toString:function(t){let e=t.byteLength,a="";for(let i=0;i<e;i++)a+=String.fromCharCode(t[i]);return a},write:function(t,e,a=0,i=N(e)){let n=Math.min(i,t.byteLength-a);for(let i=0;i<n;i++)t[a+i]=e.charCodeAt(i);return n}};let W="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",Y=new Uint8Array(256);for(let t=0;t<W.length;t++)Y[W.charCodeAt(t)]=t;function Z(t){let e=t.length;return 61===t.charCodeAt(e-1)&&e--,e>1&&61===t.charCodeAt(e-1)&&e--,3*e>>>2}Y[45]=62,Y[95]=63;var X={byteLength:Z,toString:function(t){let e=t.byteLength,a="";for(let i=0;i<e;i+=3)a+=W[t[i]>>2]+W[(3&t[i])<<4|t[i+1]>>4]+W[(15&t[i+1])<<2|t[i+2]>>6]+W[63&t[i+2]];return e%3==2?a=a.substring(0,a.length-1)+"=":e%3==1&&(a=a.substring(0,a.length-2)+"=="),a},write:function(t,e,a=0,i=Z(e)){let n=Math.min(i,t.byteLength-a);for(let a=0,i=0;i<n;a+=4){let n=Y[e.charCodeAt(a)],r=Y[e.charCodeAt(a+1)],o=Y[e.charCodeAt(a+2)],l=Y[e.charCodeAt(a+3)];t[i++]=n<<2|r>>4,t[i++]=(15&r)<<4|o>>2,t[i++]=(3&o)<<6|63&l}return n}};function J(t){return t.length>>>1}var tt={byteLength:J,toString:function(t){let e=t.byteLength;t=new DataView(t.buffer,t.byteOffset,e);let a="",i=0;for(let n=e-e%4;i<n;i+=4)a+=t.getUint32(i).toString(16).padStart(8,"0");for(;i<e;i++)a+=t.getUint8(i).toString(16).padStart(2,"0");return a},write:function(t,e,a=0,i=J(e)){let n=Math.min(i,t.byteLength-a);for(let i=0;i<n;i++){let n=te(e.charCodeAt(2*i)),r=te(e.charCodeAt(2*i+1));if(void 0===n||void 0===r)return t.subarray(0,i);t[a+i]=n<<4|r}return n}};function te(t){return t>=48&&t<=57?t-48:t>=65&&t<=70?t-65+10:t>=97&&t<=102?t-97+10:void 0}function ta(t){let e=0;for(let a=0,i=t.length;a<i;a++){let n=t.charCodeAt(a);if(n>=55296&&n<=56319&&a+1<i){let i=t.charCodeAt(a+1);if(i>=56320&&i<=57343){e+=4,a++;continue}}n<=127?e+=1:n<=2047?e+=2:e+=3}return e}if("undefined"!=typeof TextDecoder){let t=new TextDecoder;i=function(e){return t.decode(e)}}else i=function(t){let e=t.byteLength,a="",i=0;for(;i<e;){let n=t[i];if(n<=127){a+=String.fromCharCode(n),i++;continue}let r=0,o=0;if(n<=223?(r=1,o=31&n):n<=239?(r=2,o=15&n):n<=244&&(r=3,o=7&n),e-i-r>0){let e=0;for(;e<r;)o=o<<6|63&(n=t[i+e+1]),e+=1}else o=65533,r=e-i;a+=String.fromCodePoint(o),i+=r+1}return a};if("undefined"!=typeof TextEncoder){let t=new TextEncoder;n=function(e,a,i=0,n=ta(a)){let r=Math.min(n,e.byteLength-i);return t.encodeInto(a,e.subarray(i,i+r)),r}}else n=function(t,e,a=0,i=ta(e)){let n=Math.min(i,t.byteLength-a);t=t.subarray(a,a+n);let r=0,o=0;for(;r<e.length;){let a=e.codePointAt(r);if(a<=127){t[o++]=a,r++;continue}let i=0,n=0;for(a<=2047?(i=6,n=192):a<=65535?(i=12,n=224):a<=2097151&&(i=18,n=240),t[o++]=n|a>>i,i-=6;i>=0;)t[o++]=128|a>>i&63,i-=6;r+=a>=65536?2:1}return n};var ti={byteLength:ta,toString:i,write:n};function tn(t){return 2*t.length}var tr={byteLength:tn,toString:function(t){let e=t.byteLength,a="";for(let i=0;i<e-1;i+=2)a+=String.fromCharCode(t[i]+256*t[i+1]);return a},write:function(t,e,a=0,i=tn(e)){let n=Math.min(i,t.byteLength-a),r=n;for(let i=0;i<e.length&&!((r-=2)<0);++i){let n=e.charCodeAt(i),r=n>>8,o=n%256;t[a+2*i]=o,t[a+2*i+1]=r}return n}};!function(t,e){let a=255===new Uint8Array(Uint16Array.of(255).buffer)[0];function i(t){switch(t){case"ascii":return j;case"base64":return X;case"hex":return tt;case"utf8":case"utf-8":case void 0:return ti;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return tr;default:throw Error(`Unknown encoding: ${t}`)}}function n(t){return t instanceof Uint8Array}function r(t,e,a){return"string"==typeof t?function(t,e){let a=i(e),n=new Uint8Array(a.byteLength(t));return a.write(n,t,0,n.byteLength),n}(t,e):Array.isArray(t)?function(t){let e=new Uint8Array(t.length);return e.set(t),e}(t):ArrayBuffer.isView(t)?function(t){let e=new Uint8Array(t.byteLength);return e.set(t),e}(t):new Uint8Array(t,e,a)}function o(t,e,a,i,n){if(0===t.byteLength)return -1;if("string"==typeof a?(i=a,a=0):void 0===a?a=n?0:t.length-1:a<0&&(a+=t.byteLength),a>=t.byteLength){if(n)return -1;a=t.byteLength-1}else if(a<0){if(!n)return -1;a=0}if("string"==typeof e)e=r(e,i);else if("number"==typeof e)return(e&=255,n)?t.indexOf(e,a):t.lastIndexOf(e,a);if(0===e.byteLength)return -1;if(n){let i=-1;for(let n=a;n<t.byteLength;n++)if(t[n]===e[-1===i?0:n-i]){if(-1===i&&(i=n),n-i+1===e.byteLength)return i}else -1!==i&&(n-=n-i),i=-1}else{a+e.byteLength>t.byteLength&&(a=t.byteLength-e.byteLength);for(let i=a;i>=0;i--){let a=!0;for(let n=0;n<e.byteLength;n++)if(t[i+n]!==e[n]){a=!1;break}if(a)return i}}return -1}function l(t,e,a,i){return o(t,e,a,i,!0)}function s(t,e,a){let i=t[e];t[e]=t[a],t[a]=i}t.exports=e={isBuffer:n,isEncoding:function(t){try{return i(t),!0}catch{return!1}},alloc:function(t,a,i){let n=new Uint8Array(t);return void 0!==a&&e.fill(n,a,0,n.byteLength,i),n},allocUnsafe:function(t){return new Uint8Array(t)},allocUnsafeSlow:function(t){return new Uint8Array(t)},byteLength:function(t,e){return i(e).byteLength(t)},compare:function(t,e){if(t===e)return 0;let i=Math.min(t.byteLength,e.byteLength);t=new DataView(t.buffer,t.byteOffset,t.byteLength),e=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;for(let r=i-i%4;n<r&&t.getUint32(n,a)===e.getUint32(n,a);n+=4);for(;n<i;n++){let a=t.getUint8(n),i=e.getUint8(n);if(a<i)return -1;if(a>i)return 1}return t.byteLength>e.byteLength?1:t.byteLength<e.byteLength?-1:0},concat:function(t,e){void 0===e&&(e=t.reduce((t,e)=>t+e.byteLength,0));let a=new Uint8Array(e),i=0;for(let e of t){if(i+e.byteLength>a.byteLength){let t=e.subarray(0,a.byteLength-i);a.set(t,i);break}a.set(e,i),i+=e.byteLength}return a},copy:function(t,e,a=0,i=0,n=t.byteLength){if(n>0&&n<i||n===i||0===t.byteLength||0===e.byteLength)return 0;if(a<0)throw RangeError("targetStart is out of range");if(i<0||i>=t.byteLength)throw RangeError("sourceStart is out of range");if(n<0)throw RangeError("sourceEnd is out of range");a>=e.byteLength&&(a=e.byteLength),n>t.byteLength&&(n=t.byteLength),e.byteLength-a<n-i&&(n=e.length-a+i);let r=n-i;return t===e?e.copyWithin(a,i,n):e.set(t.subarray(i,n),a),r},equals:function(t,e){if(t===e)return!0;if(t.byteLength!==e.byteLength)return!1;let i=t.byteLength;t=new DataView(t.buffer,t.byteOffset,t.byteLength),e=new DataView(e.buffer,e.byteOffset,e.byteLength);let n=0;for(let r=i-i%4;n<r;n+=4)if(t.getUint32(n,a)!==e.getUint32(n,a))return!1;for(;n<i;n++)if(t.getUint8(n)!==e.getUint8(n))return!1;return!0},fill:function(t,e,a,i,o){if("string"==typeof e?"string"==typeof a?(o=a,a=0,i=t.byteLength):"string"==typeof i&&(o=i,i=t.byteLength):"number"==typeof e?e&=255:"boolean"==typeof e&&(e=+e),a<0||t.byteLength<a||t.byteLength<i)throw RangeError("Out of range index");if(void 0===a&&(a=0),void 0===i&&(i=t.byteLength),i<=a)return t;if(e||(e=0),"number"==typeof e)for(let n=a;n<i;++n)t[n]=e;else{let l=(e=n(e)?e:r(e,o)).byteLength;for(let n=0;n<i-a;++n)t[n+a]=e[n%l]}return t},from:r,includes:function(t,e,a,i){return -1!==l(t,e,a,i)},indexOf:l,lastIndexOf:function(t,e,a,i){return o(t,e,a,i,!1)},swap16:function(t){let e=t.byteLength;if(e%2!=0)throw RangeError("Buffer size must be a multiple of 16-bits");for(let a=0;a<e;a+=2)s(t,a,a+1);return t},swap32:function(t){let e=t.byteLength;if(e%4!=0)throw RangeError("Buffer size must be a multiple of 32-bits");for(let a=0;a<e;a+=4)s(t,a,a+3),s(t,a+1,a+2);return t},swap64:function(t){let e=t.byteLength;if(e%8!=0)throw RangeError("Buffer size must be a multiple of 64-bits");for(let a=0;a<e;a+=8)s(t,a,a+7),s(t,a+1,a+6),s(t,a+2,a+5),s(t,a+3,a+4);return t},toBuffer:function(t){return t},toString:function(t,e,a=0,n=t.byteLength){let r=t.byteLength;return a>=r||n<=a?"":(a<0&&(a=0),n>r&&(n=r),(0!==a||n<r)&&(t=t.subarray(a,n)),i(e).toString(t))},write:function(t,e,a,n,r){return void 0===a?r="utf8":void 0===n&&"string"==typeof a?(r=a,a=void 0):void 0===r&&"string"==typeof n&&(r=n,n=void 0),i(r).write(t,e,a,n)},writeDoubleLE:function(t,e,a){return void 0===a&&(a=0),new DataView(t.buffer,t.byteOffset,t.byteLength).setFloat64(a,e,!0),a+8},writeFloatLE:function(t,e,a){return void 0===a&&(a=0),new DataView(t.buffer,t.byteOffset,t.byteLength).setFloat32(a,e,!0),a+4},writeUInt32LE:function(t,e,a){return void 0===a&&(a=0),new DataView(t.buffer,t.byteOffset,t.byteLength).setUint32(a,e,!0),a+4},writeInt32LE:function(t,e,a){return void 0===a&&(a=0),new DataView(t.buffer,t.byteOffset,t.byteLength).setInt32(a,e,!0),a+4},readDoubleLE:function(t,e){return void 0===e&&(e=0),new DataView(t.buffer,t.byteOffset,t.byteLength).getFloat64(e,!0)},readFloatLE:function(t,e){return void 0===e&&(e=0),new DataView(t.buffer,t.byteOffset,t.byteLength).getFloat32(e,!0)},readUInt32LE:function(t,e){return void 0===e&&(e=0),new DataView(t.buffer,t.byteOffset,t.byteLength).getUint32(e,!0)},readInt32LE:function(t,e){return void 0===e&&(e=0),new DataView(t.buffer,t.byteOffset,t.byteLength).getInt32(e,!0)}}}(H,H.exports);var to=function t(e,a){if(!e){var i=new $(a);throw Error.captureStackTrace&&Error.captureStackTrace(i,t),i}},tl=H.exports,ts=null,tu="undefined"!=typeof WebAssembly&&(function(){let t,e;if(o)return r;o=1;var a=(()=>{for(var t=new Uint8Array(128),e=0;e<64;e++)t[e<26?e+65:e<52?e+71:e<62?e-4:4*e-205]=e;return e=>{for(var a=e.length,i=new Uint8Array((a-("="==e[a-1])-("="==e[a-2]))*3/4|0),n=0,r=0;n<a;){var o=t[e.charCodeAt(n++)],l=t[e.charCodeAt(n++)],s=t[e.charCodeAt(n++)],u=t[e.charCodeAt(n++)];i[r++]=o<<2|l>>4,i[r++]=l<<4|s>>2,i[r++]=s<<6|u}return i}})(),i=(t={"wasm-binary:./blake2b.wat"(t,e){e.exports=a("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")}},function(){return e||(0,t[Object.keys(t)[0]])((e={exports:{}}).exports,e),e.exports})(),n=WebAssembly.compile(i);return r=async t=>(await WebAssembly.instantiate(await n,t)).exports})()().then(t=>{ts=t}),tf=64,tg=[];K.exports=tp;var th=K.exports.BYTES_MIN=16,tw=K.exports.BYTES_MAX=64;K.exports.BYTES=32;var tc=K.exports.KEYBYTES_MIN=16,td=K.exports.KEYBYTES_MAX=64;K.exports.KEYBYTES=32;var tm=K.exports.SALTBYTES=16,tA=K.exports.PERSONALBYTES=16;function tp(t,e,a,i,n){if(!(this instanceof tp))return new tp(t,e,a,i,n);if(!ts)throw Error("WASM not loaded. Wait for Blake2b.ready(cb)");t||(t=32),!0!==n&&(to(t>=th,"digestLength must be at least "+th+", was given "+t),to(t<=tw,"digestLength must be at most "+tw+", was given "+t),null!=e&&(to(e instanceof Uint8Array,"key must be Uint8Array or Buffer"),to(e.length>=tc,"key must be at least "+tc+", was given "+e.length),to(e.length<=td,"key must be at least "+td+", was given "+e.length)),null!=a&&(to(a instanceof Uint8Array,"salt must be Uint8Array or Buffer"),to(a.length===tm,"salt must be exactly "+tm+", was given "+a.length)),null!=i&&(to(i instanceof Uint8Array,"personal must be Uint8Array or Buffer"),to(i.length===tA,"personal must be exactly "+tA+", was given "+i.length))),tg.length||(tg.push(tf),tf+=216),this.digestLength=t,this.finalized=!1,this.pointer=tg.pop(),this._memory=new Uint8Array(ts.memory.buffer),this._memory.fill(0,0,64),this._memory[0]=this.digestLength,this._memory[1]=e?e.length:0,this._memory[2]=1,this._memory[3]=1,a&&this._memory.set(a,32),i&&this._memory.set(i,48),this.pointer+216>this._memory.length&&this._realloc(this.pointer+216),ts.blake2b_init(this.pointer,this.digestLength),e&&(this.update(e),this._memory.fill(0,tf,tf+e.length),this._memory[this.pointer+200]=128)}function ty(){}function tI(t){return((4294901760&t)!=0?(t&=4294901760,16):0)|((4278255360&t)!=0?(t&=4278255360,8):0)|((4042322160&t)!=0?(t&=4042322160,4):0)|((3435973836&t)!=0?(t&=3435973836,2):0)|(2863311530&t)!=0}function tb(t,e){let a=new DataView(t.buffer,t.byteOffset,t.byteLength),i="";for(let t=0;t<4;t++){t>0&&(i+="\n"),i+="		";for(let e=0;e<4;e++)e>0&&(i+=" "),i+=a.getUint32(16*t+4*e).toString(16).padStart(8,"0")}return e&&(i=e+"\n"+i),i}function tC(t,e){if(t.byteLength!=e.byteLength)return!1;for(var a=new Int8Array(t),i=new Int8Array(e),n=0;n!=t.byteLength;n++)if(a[n]!=i[n])return!1;return!0}async function tE(t,e,a,i,n){return!(t.G1.isZero(e)||t.G1.isZero(a)||t.G2.isZero(i)||t.G2.isZero(n))&&await t.pairingEq(e,n,t.G1.neg(a),i)}function tS(t){let e=new Uint8Array(t);return globalThis.crypto.getRandomValues(e),e}async function tv(t){return new Uint8Array(await globalThis.crypto.subtle.digest("SHA-256",t.buffer))}function tF(t,e){return new DataView(t.buffer).getUint32(e,!1)}async function tB(t){for(;!t;)t=await window.prompt("Enter a random text. (Entropy): ","");let e=K.exports(64);e.update(tS(64));let a=new TextEncoder;e.update(a.encode(t));let i=e.digest(),n=[];for(let t=0;t<8;t++)n[t]=tF(i,4*t);return new l.XY(n)}async function tG(t,e){let a,i;e<32?(a=1<<e>>>0,i=1):(a=4294967296,i=1<<e-32>>>0);let n=t;for(let t=0;t<i;t++)for(let t=0;t<a;t++)n=await tv(n);let r=new DataView(n.buffer,n.byteOffset,n.byteLength),o=[];for(let t=0;t<8;t++)o[t]=r.getUint32(4*t,!1);return new l.XY(o)}function tQ(t){return t instanceof Uint8Array?t:("0x"==t.slice(0,2)&&(t=t.slice(2)),new Uint8Array(t.match(/[\da-f]{2}/gi).map(function(t){return parseInt(t,16)})))}function tx(t){return Array.prototype.map.call(t,function(t){return("0"+(255&t).toString(16)).slice(-2)}).join("")}function tL(t,e){if(e instanceof Uint8Array)return t.toString(e);if(Array.isArray(e))return e.map(tL.bind(null,t));if("object"==typeof e){let a={};return Object.keys(e).forEach(i=>{a[i]=tL(t,e[i])}),a}return"bigint"==typeof e||void 0!==e.eq?e.toString(10):e}async function tU(t,e){await F(t,1),await t.writeULE32(1),await B(t);let a=await O(e.q);await F(t,2);let i=a.q,n=(Math.floor((l.Ru.bitLength(i)-1)/64)+1)*8,r=a.r,o=(Math.floor((l.Ru.bitLength(r)-1)/64)+1)*8;await t.writeULE32(n),await x(t,i,n),await t.writeULE32(o),await x(t,r,o),await t.writeULE32(e.nVars),await t.writeULE32(e.nPublic),await t.writeULE32(e.domainSize),await t_(t,a,e.vk_alpha_1),await t_(t,a,e.vk_beta_1),await tT(t,a,e.vk_beta_2),await tT(t,a,e.vk_gamma_2),await t_(t,a,e.vk_delta_1),await tT(t,a,e.vk_delta_2),await B(t)}async function t_(t,e,a){let i=new Uint8Array(2*e.G1.F.n8);e.G1.toRprLEM(i,0,a),await t.write(i)}async function tT(t,e,a){let i=new Uint8Array(2*e.G2.F.n8);e.G2.toRprLEM(i,0,a),await t.write(i)}async function tz(t,e,a){let i=await t.read(2*e.G1.F.n8),n=e.G1.fromRprLEM(i,0);return a?e.G1.toObject(n):n}async function tP(t,e,a){let i=await t.read(2*e.G2.F.n8),n=e.G2.fromRprLEM(i,0);return a?e.G2.toObject(n):n}async function tD(t,e,a,i){await G(t,e,1);let n=await t.readULE32();if(await Q(t),1===n)return await tR(t,e,a,i);if(2===n)return await tk(t,e,a,i);if(10===n)return await tO(t,e,a,i);throw Error("Protocol not supported: ")}async function tR(t,e,a,i){let n={};n.protocol="groth16",await G(t,e,2);let r=await t.readULE32();n.n8q=r,n.q=await L(t,r);let o=await t.readULE32();return n.n8r=o,n.r=await L(t,o),n.curve=await O(n.q,i),n.nVars=await t.readULE32(),n.nPublic=await t.readULE32(),n.domainSize=await t.readULE32(),n.power=tI(n.domainSize),n.vk_alpha_1=await tz(t,n.curve,a),n.vk_beta_1=await tz(t,n.curve,a),n.vk_beta_2=await tP(t,n.curve,a),n.vk_gamma_2=await tP(t,n.curve,a),n.vk_delta_1=await tz(t,n.curve,a),n.vk_delta_2=await tP(t,n.curve,a),await Q(t),n}async function tk(t,e,a,i){let n={};n.protocol="plonk",await G(t,e,2);let r=await t.readULE32();n.n8q=r,n.q=await L(t,r);let o=await t.readULE32();return n.n8r=o,n.r=await L(t,o),n.curve=await O(n.q,i),n.nVars=await t.readULE32(),n.nPublic=await t.readULE32(),n.domainSize=await t.readULE32(),n.power=tI(n.domainSize),n.nAdditions=await t.readULE32(),n.nConstraints=await t.readULE32(),n.k1=await t.read(o),n.k2=await t.read(o),n.Qm=await tz(t,n.curve,a),n.Ql=await tz(t,n.curve,a),n.Qr=await tz(t,n.curve,a),n.Qo=await tz(t,n.curve,a),n.Qc=await tz(t,n.curve,a),n.S1=await tz(t,n.curve,a),n.S2=await tz(t,n.curve,a),n.S3=await tz(t,n.curve,a),n.X_2=await tP(t,n.curve,a),await Q(t),n}async function tO(t,e,a,i){let n={};n.protocol="fflonk",n.protocolId=10,await G(t,e,2);let r=await t.readULE32();n.n8q=r,n.q=await L(t,r),n.curve=await O(n.q,i);let o=await t.readULE32();return n.n8r=o,n.r=await L(t,o),n.nVars=await t.readULE32(),n.nPublic=await t.readULE32(),n.domainSize=await t.readULE32(),n.power=tI(n.domainSize),n.nAdditions=await t.readULE32(),n.nConstraints=await t.readULE32(),n.k1=await t.read(o),n.k2=await t.read(o),n.w3=await t.read(o),n.w4=await t.read(o),n.w8=await t.read(o),n.wr=await t.read(o),n.X_2=await tP(t,n.curve,a),n.C0=await tz(t,n.curve,a),await Q(t),n}async function tM(t,e){let{fd:a,sections:i}=await S(t,"zkey",1),n=await tD(a,i,e),r=new l.FX(n.r),o=l.Ru.mod(l.Ru.shl(1,8*n.n8r),n.r),s=r.inv(o),u=r.mul(s,s),f=await O(n.q);await G(a,i,3),n.IC=[];for(let t=0;t<=n.nPublic;t++){let t=await tz(a,f,e);n.IC.push(t)}await Q(a),await G(a,i,4);let g=await a.readULE32();n.ccoefs=[];for(let t=0;t<g;t++){let t=await a.readULE32(),e=await a.readULE32(),i=await a.readULE32(),r=await h();n.ccoefs.push({matrix:t,constraint:e,signal:i,value:r})}await Q(a),await G(a,i,5),n.A=[];for(let t=0;t<n.nVars;t++){let i=await tz(a,f,e);n.A[t]=i}await Q(a),await G(a,i,6),n.B1=[];for(let t=0;t<n.nVars;t++){let i=await tz(a,f,e);n.B1[t]=i}await Q(a),await G(a,i,7),n.B2=[];for(let t=0;t<n.nVars;t++){let i=await tP(a,f,e);n.B2[t]=i}await Q(a),await G(a,i,8),n.C=[];for(let t=n.nPublic+1;t<n.nVars;t++){let i=await tz(a,f,e);n.C[t]=i}await Q(a),await G(a,i,9),n.hExps=[];for(let t=0;t<n.domainSize;t++){let t=await tz(a,f,e);n.hExps.push(t)}return await Q(a),await a.close(),n;async function h(){let t=await L(a,n.n8r);return r.mul(t,u)}}async function tV(t,e,a){let i={delta:{}};i.deltaAfter=await tz(t,e,a),i.delta.g1_s=await tz(t,e,a),i.delta.g1_sx=await tz(t,e,a),i.delta.g2_spx=await tP(t,e,a),i.transcript=await t.read(64),i.type=await t.readULE32();let n=await t.readULE32(),r=t.pos,o=0;for(;t.pos-r<n;){let e=await t.read(1);if(e[0]<=o)throw Error("Parameters in the contribution must be sorted");if(o=e[0],1==e[0]){let e=await t.read(1),a=await t.read(e[0]);i.name=new TextDecoder().decode(a)}else if(2==e[0]){let e=await t.read(1);i.numIterationsExp=e[0]}else if(3==e[0]){let e=await t.read(1);i.beaconHash=await t.read(e[0])}else throw Error("Parameter not recognized")}if(t.pos!=r+n)throw Error("Parameters do not match");return i}async function tq(t,e,a){await G(t,a,10);let i={contributions:[]};i.csHash=await t.read(64);let n=await t.readULE32();for(let a=0;a<n;a++){let a=await tV(t,e);i.contributions.push(a)}return await Q(t),i}async function tK(t,e,a){await t_(t,e,a.deltaAfter),await t_(t,e,a.delta.g1_s),await t_(t,e,a.delta.g1_sx),await tT(t,e,a.delta.g2_spx),await t.write(a.transcript),await t.writeULE32(a.type||0);let i=[];if(a.name){i.push(1);let t=new TextEncoder("utf-8").encode(a.name.substring(0,64));i.push(t.byteLength);for(let e=0;e<t.byteLength;e++)i.push(t[e])}if(1==a.type){i.push(2),i.push(a.numIterationsExp),i.push(3),i.push(a.beaconHash.byteLength);for(let t=0;t<a.beaconHash.byteLength;t++)i.push(a.beaconHash[t])}if(i.length>0){let e=new Uint8Array(i);await t.writeULE32(e.byteLength),await t.write(e)}else await t.writeULE32(0)}async function t$(t,e,a){await F(t,10),await t.write(a.csHash),await t.writeULE32(a.contributions.length);for(let i=0;i<a.contributions.length;i++)await tK(t,e,a.contributions[i]);await B(t)}function tH(t,e,a){let i=new Uint8Array(2*e.G1.F.n8);e.G1.toRprUncompressed(i,0,a),t.update(i)}function tN(t,e,a){tH(t,e,a.deltaAfter),tH(t,e,a.delta.g1_s),tH(t,e,a.delta.g1_sx),function(t,e,a){let i=new Uint8Array(2*e.G2.F.n8);e.G2.toRprUncompressed(i,0,a),t.update(i)}(t,e,a.delta.g2_spx),t.update(a.transcript)}async function tj(t,e,a){await F(t,1);let i=(Math.floor((l.Ru.bitLength(a)-1)/64)+1)*8;await t.writeULE32(i),await x(t,a,i),await t.writeULE32(e.length),await B(t),await F(t,2);for(let a=0;a<e.length;a++)await x(t,e[a],i);await B(t)}async function tW(t,e,a){await F(t,1);let i=(Math.floor((l.Ru.bitLength(a)-1)/64)+1)*8;if(await t.writeULE32(i),await x(t,a,i),e.byteLength%i!=0)throw Error("Invalid witness length");await t.writeULE32(e.byteLength/i),await B(t),await F(t,2),await t.write(e),await B(t)}async function tY(t,e){await G(t,e,1);let a=await t.readULE32(),i=await L(t,a),n=await t.readULE32();return await Q(t),{n8:a,q:i,nWitness:n}}async function tZ(t){let{fd:e,sections:a}=await S(t,"wtns",2),{n8:i,nWitness:n}=await tY(e,a);await G(e,a,2);let r=[];for(let t=0;t<n;t++){let t=await L(e,i);r.push(t)}return await Q(e),await e.close(),r}tp.prototype._realloc=function(t){ts.memory.grow(Math.max(0,Math.ceil(Math.abs(t-this._memory.length)/65536))),this._memory=new Uint8Array(ts.memory.buffer)},tp.prototype.update=function(t){return to(!1===this.finalized,"Hash instance finalized"),to(t instanceof Uint8Array,"input must be Uint8Array or Buffer"),tf+t.length>this._memory.length&&this._realloc(tf+t.length),this._memory.set(t,tf),ts.blake2b_update(this.pointer,tf,tf+t.length),this},tp.prototype.digest=function(t){if(to(!1===this.finalized,"Hash instance finalized"),this.finalized=!0,tg.push(this.pointer),ts.blake2b_final(this.pointer),!t||"binary"===t)return this._memory.slice(this.pointer+128,this.pointer+128+this.digestLength);if("string"==typeof t)return tl.toString(this._memory,t,this.pointer+128,this.pointer+128+this.digestLength);to(t instanceof Uint8Array&&t.length>=this.digestLength,"input must be Uint8Array or Buffer");for(var e=0;e<this.digestLength;e++)t[e]=this._memory[this.pointer+128+e];return t},tp.prototype.final=tp.prototype.digest,tp.WASM=ts,tp.SUPPORTED="undefined"!=typeof WebAssembly,tp.ready=function(t){return(t||(t=ty),tu)?tu.then(()=>t(),t):t(Error("WebAssembly not supported"))},tp.prototype.ready=tp.ready,tp.prototype.getPartialHash=function(){return this._memory.slice(this.pointer,this.pointer+216)},tp.prototype.setPartialHash=function(t){this._memory.set(t,this.pointer)};let{stringifyBigInts:tX}=l.utils;async function tJ(t,e,a,i){let{fd:n,sections:r}=await S(e,"wtns",2),o=await tY(n,r),{fd:s,sections:u}=await S(t,"zkey",2),f=await tD(s,u,void 0,i);if("groth16"!=f.protocol)throw Error("zkey file is not groth16");if(!l.Ru.eq(f.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=f.nVars)throw Error(`Invalid witness length. Circuit: ${f.nVars}, witness: ${o.nWitness}`);let g=f.curve,h=g.Fr,w=g.G1,c=g.G2,d=tI(f.domainSize);a&&a.debug("Reading Wtns");let m=await _(n,r,2);a&&a.debug("Reading Coeffs");let A=await _(s,u,4);a&&a.debug("Building ABC");let[p,y,I]=await t1(g,f,m,A,a),b=d==h.s?g.Fr.shift:g.Fr.w[d+1],C=await h.ifft(p,"","",a,"IFFT_A"),E=await h.batchApplyKey(C,h.e(1),b),v=await h.fft(E,"","",a,"FFT_A"),F=await h.ifft(y,"","",a,"IFFT_B"),B=await h.batchApplyKey(F,h.e(1),b),G=await h.fft(B,"","",a,"FFT_B"),Q=await h.ifft(I,"","",a,"IFFT_C"),x=await h.batchApplyKey(Q,h.e(1),b),L=await h.fft(x,"","",a,"FFT_C");a&&a.debug("Join ABC");let U=await t2(g,f,v,G,L,a),T={};a&&a.debug("Reading A Points");let z=await _(s,u,5);T.pi_a=await g.G1.multiExpAffine(z,m,a,"multiexp A"),a&&a.debug("Reading B1 Points");let P=await _(s,u,6),D=await g.G1.multiExpAffine(P,m,a,"multiexp B1");a&&a.debug("Reading B2 Points");let R=await _(s,u,7);T.pi_b=await g.G2.multiExpAffine(R,m,a,"multiexp B2"),a&&a.debug("Reading C Points");let k=await _(s,u,8);T.pi_c=await g.G1.multiExpAffine(k,m.slice((f.nPublic+1)*g.Fr.n8),a,"multiexp C"),a&&a.debug("Reading H Points");let O=await _(s,u,9),M=await g.G1.multiExpAffine(O,U,a,"multiexp H"),V=g.Fr.random(),q=g.Fr.random();T.pi_a=w.add(T.pi_a,f.vk_alpha_1),T.pi_a=w.add(T.pi_a,w.timesFr(f.vk_delta_1,V)),T.pi_b=c.add(T.pi_b,f.vk_beta_2),T.pi_b=c.add(T.pi_b,c.timesFr(f.vk_delta_2,q)),D=w.add(D,f.vk_beta_1),D=w.add(D,w.timesFr(f.vk_delta_1,q)),T.pi_c=w.add(T.pi_c,M),T.pi_c=w.add(T.pi_c,w.timesFr(T.pi_a,q)),T.pi_c=w.add(T.pi_c,w.timesFr(D,V)),T.pi_c=w.add(T.pi_c,w.timesFr(f.vk_delta_1,h.neg(h.mul(V,q))));let K=[];for(let t=1;t<=f.nPublic;t++){let e=m.slice(t*h.n8,t*h.n8+h.n8);K.push(l.Ru.fromRprLE(e))}return T.pi_a=w.toObject(w.toAffine(T.pi_a)),T.pi_b=c.toObject(c.toAffine(T.pi_b)),T.pi_c=w.toObject(w.toAffine(T.pi_c)),T.protocol="groth16",T.curve=g.name,await s.close(),await n.close(),{proof:T=tX(T),publicSignals:K=tX(K)}}async function t1(t,e,a,i,n){let r=t.Fr.n8,o=12+e.n8r,s=(i.byteLength-4)/o,u=new l.qc(e.domainSize*r),f=new l.qc(e.domainSize*r),g=new l.qc(e.domainSize*r),h=[u,f];for(let e=0;e<s;e++){n&&e%1e6==0&&n.debug(`QAP AB: ${e}/${s}`);let l=i.slice(4+e*o,4+e*o+o),u=new DataView(l.buffer),f=u.getUint32(0,!0),g=u.getUint32(4,!0),w=u.getUint32(8,!0),c=l.slice(12,12+r);h[f].set(t.Fr.add(h[f].slice(g*r,g*r+r),t.Fr.mul(c,a.slice(w*r,w*r+r))),g*r)}for(let a=0;a<e.domainSize;a++)n&&a%1e6==0&&n.debug(`QAP C: ${a}/${e.domainSize}`),g.set(t.Fr.mul(u.slice(a*r,a*r+r),f.slice(a*r,a*r+r)),a*r);return[u,f,g]}async function t2(t,e,a,i,n,r){let o;let s=t.Fr.n8,u=Math.floor(a.byteLength/t.Fr.n8),f=[];for(let e=0;e<u;e+=4194304){r&&r.debug(`JoinABC: ${e}/${u}`);let o=Math.min(u-e,4194304),l=[],g=a.slice(e*s,(e+o)*s),h=i.slice(e*s,(e+o)*s),w=n.slice(e*s,(e+o)*s);l.push({cmd:"ALLOCSET",var:0,buff:g}),l.push({cmd:"ALLOCSET",var:1,buff:h}),l.push({cmd:"ALLOCSET",var:2,buff:w}),l.push({cmd:"ALLOC",var:3,len:o*s}),l.push({cmd:"CALL",fnName:"qap_joinABC",params:[{var:0},{var:1},{var:2},{val:o},{var:3}]}),l.push({cmd:"CALL",fnName:"frm_batchFromMontgomery",params:[{var:3},{val:o},{var:3}]}),l.push({cmd:"GET",out:0,var:3,len:o*s}),f.push(t.tm.queueAction(l))}let g=await Promise.all(f);o=a instanceof l.qc?new l.qc(a.byteLength):new Uint8Array(a.byteLength);let h=0;for(let t=0;t<g.length;t++)o.set(g[t][0],h),h+=g[t][0].byteLength;return o}function t0(t){let e=[];return function t(e,a){if(Array.isArray(a))for(let i=0;i<a.length;i++)t(e,a[i]);else e.push(a)}(e,t),e}function t8(t){let e=BigInt(2)**BigInt(64),a=BigInt("0xCBF29CE484222325");for(let i=0;i<t.length;i++)a^=BigInt(t[i].charCodeAt(0)),a*=BigInt(1099511628211),a%=e;let i=a.toString(16),n=16-i.length;return"0".repeat(n).concat(i)}async function t3(t,e){let a,i,n;e=e||{};let r=1,o=0,s=0,u=!1;if(t instanceof WebAssembly.Instance)a=t,u=!0;else{let u=32767;if(e.memorySize&&(u=parseInt(e.memorySize))<0)throw Error("Invalid memory size");let f=!1;for(;!f;)try{n=new WebAssembly.Memory({initial:u}),f=!0}catch(t){if(u<=1)throw t;console.warn("Could not allocate "+65536*u+" bytes. This may cause severe instability. Trying with "+65536*u/2+" bytes"),u=Math.floor(u/2)}let w=await WebAssembly.compile(t),c="",d="";a=await WebAssembly.instantiate(w,{env:{memory:n},runtime:{printDebug:function(t){console.log("printDebug:",t)},exceptionHandler:function(t){let e;throw e=1===t?"Signal not found. ":2===t?"Too many signals set. ":3===t?"Signal already set. ":4===t?"Assert Failed. ":5===t?"Not enough memory. ":6===t?"Input signal array access exceeds the size. ":"Unknown error. ",console.error("ERROR: ",t,c),Error(e+c)},printErrorMessage:function(){c+=g()+"\n"},writeBufferMessage:function(){let t=g();"\n"===t?(console.log(d),d=""):(""!==d&&(d+=" "),d+=t)},showSharedRWMemory:function(){let t=a.exports.getFieldNumLen32(),e=new Uint32Array(t);for(let i=0;i<t;i++)e[t-1-i]=a.exports.readSharedRWMemory(i);if(r>=2&&(o>=1||s>=7)){""!==d&&(d+=" ");let t=l.Ru.fromArray(e,4294967296).toString();d+=t}else console.log(l.Ru.fromArray(e,4294967296))},error:function(t,a,n,r,o,l){let s;throw s=7===t?h(a)+" "+i.getFr(r).toString()+" != "+i.getFr(o).toString()+" "+h(l):9===t?h(a)+" "+i.getFr(r).toString()+" "+h(o):5===t&&e.sym?h(a)+" "+e.sym.labelIdx2Name[o]:h(a)+" "+n+" "+r+" "+o+" "+l,console.log("ERROR: ",t,s),Error(s)},log:function(t){console.log(i.getFr(t).toString())},logGetSignal:function(t,a){e.logGetSignal&&e.logGetSignal(t,i.getFr(a))},logSetSignal:function(t,a){e.logSetSignal&&e.logSetSignal(t,i.getFr(a))},logStartComponent:function(t){e.logStartComponent&&e.logStartComponent(t)},logFinishComponent:function(t){e.logFinishComponent&&e.logFinishComponent(t)}}})}"function"==typeof a.exports.getVersion&&(r=a.exports.getVersion()),"function"==typeof a.exports.getMinorVersion&&(o=a.exports.getMinorVersion()),"function"==typeof a.exports.getPatchVersion&&(s=a.exports.getPatchVersion());let f=e&&(e.sanityCheck||e.logGetSignal||e.logSetSignal||e.logStartComponent||e.logFinishComponent);if(2===r)i=new t6(a,f);else if(1===r){if(u)throw Error("Loading code from WebAssembly instance is not supported for circom version 1");i=new t4(n,a,f)}else throw Error(`Unsupported circom version: ${r}`);return i;function g(){let t="",e=a.exports.getMessageChar();for(;0!==e;)t+=String.fromCharCode(e),e=a.exports.getMessageChar();return t}function h(t){let e=new Uint8Array(n.buffer),a=[];for(let i=0;e[t+i]>0;i++)a.push(e[t+i]);return String.fromCharCode.apply(null,a)}}class t4{constructor(t,e,a){this.memory=t,this.i32=new Uint32Array(t.buffer),this.instance=e,this.n32=(this.instance.exports.getFrLen()>>2)-2;let i=this.instance.exports.getPRawPrime(),n=Array(this.n32);for(let t=0;t<this.n32;t++)n[this.n32-1-t]=this.i32[(i>>2)+t];this.prime=l.Ru.fromArray(n,4294967296),this.Fr=new l.FX(this.prime),this.mask32=l.Ru.fromString("FFFFFFFF",16),this.NVars=this.instance.exports.getNVars(),this.n64=Math.floor((this.Fr.bitLength-1)/64)+1,this.R=this.Fr.e(l.Ru.shiftLeft(1,64*this.n64)),this.RInv=this.Fr.inv(this.R),this.sanityCheck=a}circom_version(){return 1}async _doCalculateWitness(t,e){this.instance.exports.init(this.sanityCheck||e?1:0);let a=this.allocInt(),i=this.allocFr();Object.keys(t).forEach(e=>{let n=t8(e),r=parseInt(n.slice(0,8),16),o=parseInt(n.slice(8,16),16);try{this.instance.exports.getSignalOffset32(a,0,r,o)}catch(t){throw Error(`Signal ${e} is not an input of the circuit.`)}let l=this.getInt(a),s=t0(t[e]);for(let t=0;t<s.length;t++)this.setFr(i,s[t]),this.instance.exports.setSignal(0,0,l+t,i)})}async calculateWitness(t,e){let a=this.i32[0],i=[];await this._doCalculateWitness(t,e);for(let t=0;t<this.NVars;t++){let e=this.instance.exports.getPWitness(t);i.push(this.getFr(e))}return this.i32[0]=a,i}async calculateBinWitness(t,e){let a=this.i32[0];await this._doCalculateWitness(t,e);let i=this.instance.exports.getWitnessBuffer();return this.i32[0]=a,new Uint8Array(this.memory.buffer.slice(i,i+this.NVars*this.n64*8))}allocInt(){let t=this.i32[0];return this.i32[0]=t+8,t}allocFr(){let t=this.i32[0];return this.i32[0]=t+4*this.n32+8,t}getInt(t){return this.i32[t>>2]}setInt(t,e){this.i32[t>>2]=e}getFr(t){let e=t>>2;if(2147483648&this.i32[e+1]){let t=Array(this.n32);for(let a=0;a<this.n32;a++)t[this.n32-1-a]=this.i32[e+2+a];let a=this.Fr.e(l.Ru.fromArray(t,4294967296));return 1073741824&this.i32[e+1]?this.Fr.mul(this.RInv,a):a}return 2147483648&this.i32[e]?this.Fr.e(this.i32[e]-4294967296):this.Fr.e(this.i32[e])}setFr(t,e){e=this.Fr.e(e);let a=this.Fr.neg(this.Fr.e("80000000",16)),i=this.Fr.e("7FFFFFFF",16);if(this.Fr.geq(e,a)&&this.Fr.leq(e,i)){let i;i=this.Fr.geq(e,this.Fr.zero)?l.Ru.toNumber(e):4294967296+(i=l.Ru.toNumber(this.Fr.sub(e,a))-2147483648),this.i32[t>>2]=i,this.i32[(t>>2)+1]=0;return}this.i32[t>>2]=0,this.i32[(t>>2)+1]=2147483648;let n=l.Ru.toArray(e,4294967296);for(let e=0;e<this.n32;e++){let a=n.length-1-e;a>=0?this.i32[(t>>2)+2+e]=n[a]:this.i32[(t>>2)+2+e]=0}}}class t6{constructor(t,e){this.instance=t,this.version=this.instance.exports.getVersion(),this.n32=this.instance.exports.getFieldNumLen32(),this.instance.exports.getRawPrime();let a=new Uint32Array(this.n32);for(let t=0;t<this.n32;t++)a[this.n32-1-t]=this.instance.exports.readSharedRWMemory(t);this.prime=l.Ru.fromArray(a,4294967296),this.witnessSize=this.instance.exports.getWitnessSize(),this.sanityCheck=e}circom_version(){return this.instance.exports.getVersion()}async _doCalculateWitness(t,e){this.instance.exports.init(this.sanityCheck||e?1:0);let a=Object.keys(t),i=0;if(a.forEach(e=>{let a=t8(e),n=parseInt(a.slice(0,8),16),r=parseInt(a.slice(8,16),16),o=t0(t[e]);if("function"==typeof this.instance.exports.getInputSignalSize){let t=this.instance.exports.getInputSignalSize(n,r);if(t<0)throw Error(`Signal ${e} not found
`);if(o.length<t)throw Error(`Not enough values for input signal ${e}
`);if(o.length>t)throw Error(`Too many values for input signal ${e}
`)}for(let t=0;t<o.length;t++){let e=function(t,e){let a=[],i=BigInt(t),n=BigInt(4294967296);for(;i;)a.unshift(Number(i%n)),i/=n;if(e){let t=e-a.length;for(;t>0;)a.unshift(0),t--}return a}(function(t,e){let a=BigInt(t)%e;return a<0&&(a+=e),a}(o[t],this.prime),this.n32);for(let t=0;t<this.n32;t++)this.instance.exports.writeSharedRWMemory(t,e[this.n32-1-t]);try{this.instance.exports.setInputSignal(n,r,t),i++}catch(t){throw Error(t)}}}),i<this.instance.exports.getInputSize())throw Error(`Not all inputs have been set. Only ${i} out of ${this.instance.exports.getInputSize()}`)}async calculateWitness(t,e){let a=[];await this._doCalculateWitness(t,e);for(let t=0;t<this.witnessSize;t++){this.instance.exports.getWitness(t);let e=new Uint32Array(this.n32);for(let t=0;t<this.n32;t++)e[this.n32-1-t]=this.instance.exports.readSharedRWMemory(t);a.push(l.Ru.fromArray(e,4294967296))}return a}async calculateWTNSBin(t,e){let a=new Uint32Array(this.witnessSize*this.n32+this.n32+11),i=new Uint8Array(a.buffer);await this._doCalculateWitness(t,e),i[0]=119,i[1]=116,i[2]=110,i[3]=115,a[1]=2,a[2]=2,a[3]=1;let n=4*this.n32,r=(8+n).toString(16);a[4]=parseInt(r.slice(0,8),16),a[5]=parseInt(r.slice(8,16),16),a[6]=n,this.instance.exports.getRawPrime();let o=7;for(let t=0;t<this.n32;t++)a[o+t]=this.instance.exports.readSharedRWMemory(t);a[o+=this.n32]=this.witnessSize,a[++o]=2,o++;let l=(n*this.witnessSize).toString(16);a[o]=parseInt(l.slice(0,8),16),a[o+1]=parseInt(l.slice(8,16),16),o+=2;for(let t=0;t<this.witnessSize;t++){this.instance.exports.getWitness(t);for(let t=0;t<this.n32;t++)a[o+t]=this.instance.exports.readSharedRWMemory(t);o+=this.n32}return i}}let{unstringifyBigInts:t5}=l.utils;async function t7(t,e,a,i){let n=t5(t),r=await E(e),o=await r.read(r.totalSize);await r.close();let l=await t3(o,i);if(1===l.circom_version()){let t=await l.calculateBinWitness(n),e=await v(a,"wtns",2,2);await tW(e,t,l.prime),await e.close()}else{let t=await C(a),e=await l.calculateWTNSBin(n);await t.write(e),await t.close()}}let{unstringifyBigInts:t9}=l.utils;async function et(t,e,a,i,n,r){let o=t9(t),l={type:"mem"};return await t7(o,e,l,n),await tJ(a,l,i,r)}let{unstringifyBigInts:ee}=l.utils;async function ea(t,e,a,i){let n=ee(t),r=ee(a),o=ee(e),s=await M(n.curve),u=s.G1.fromObject(n.IC[0]),f=new Uint8Array(2*s.G1.F.n8*o.length),g=new Uint8Array(s.Fr.n8*o.length);if(!function(t,e){for(let a=0;a<e.length;a++)if(!l.Ru.lt(e[a],t.r))return!1;return!0}(s,o))return i&&i.error("Public inputs are not valid."),!1;for(let t=0;t<o.length;t++){let e=s.G1.fromObject(n.IC[t+1]);f.set(e,t*s.G1.F.n8*2),l.Ru.toRprLE(g,s.Fr.n8*t,o[t],s.Fr.n8)}let h=await s.G1.multiExpAffine(f,g);h=s.G1.add(h,u);let w=s.G1.fromObject(r.pi_a),c=s.G2.fromObject(r.pi_b),d=s.G1.fromObject(r.pi_c);if(!function(t,e){let a=t.G1,i=t.G2;return a.isValid(e.pi_a)&&i.isValid(e.pi_b)&&a.isValid(e.pi_c)}(s,{pi_a:w,pi_b:c,pi_c:d}))return i&&i.error("Proof commitments are not valid."),!1;let m=s.G2.fromObject(n.vk_gamma_2),A=s.G2.fromObject(n.vk_delta_2),p=s.G1.fromObject(n.vk_alpha_1),y=s.G2.fromObject(n.vk_beta_2);return await s.pairingEq(s.G1.neg(w),c,h,m,d,A,p,y)?(i&&i.info("OK!"),!0):(i&&i.error("Invalid proof"),!1)}let{unstringifyBigInts:ei}=l.utils;function en(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`"0x${e}"`}var er=Object.freeze({__proto__:null,fullProve:et,prove:tJ,verify:ea,exportSolidityCallData:async function(t,e){let a=ei(t),i=ei(e),n="";for(let t=0;t<i.length;t++)""!=n&&(n+=","),n+=en(i[t]);return`[${en(a.pi_a[0])}, ${en(a.pi_a[1])}],[[${en(a.pi_b[0][1])}, ${en(a.pi_b[0][0])}],[${en(a.pi_b[1][1])}, ${en(a.pi_b[1][0])}]],[${en(a.pi_c[0])}, ${en(a.pi_c[1])}],[${n}]`}});function eo(t,e){let a=new DataView(e.buffer,e.byteOffset,e.byteLength),i=[];for(let t=0;t<8;t++)i[t]=a.getUint32(4*t);let n=new l.XY(i);return t.G2.fromRng(n)}function el(t,e,a,i,n){let r=K.exports(64),o=new Uint8Array([e]);r.update(o),r.update(a);let l=t.G1.toUncompressed(i);r.update(l);let s=t.G1.toUncompressed(n);return r.update(s),eo(t,r.digest())}function es(t,e,a,i,n){return t.g1_s=e.G1.toAffine(e.G1.fromRng(n)),t.g1_sx=e.G1.toAffine(e.G1.timesFr(t.g1_s,t.prvKey)),t.g2_sp=e.G2.toAffine(el(e,a,i,t.g1_s,t.g1_sx)),t.g2_spx=e.G2.toAffine(e.G2.timesFr(t.g2_sp,t.prvKey)),t}function eu(t,e,a){let i={tau:{},alpha:{},beta:{}};return i.tau.prvKey=t.Fr.fromRng(a),i.alpha.prvKey=t.Fr.fromRng(a),i.beta.prvKey=t.Fr.fromRng(a),es(i.tau,t,0,e,a),es(i.alpha,t,1,e,a),es(i.beta,t,2,e,a),i}async function ef(t,e,a,i){i||(i=a),await t.writeULE32(1);let n=t.pos;await t.writeULE64(0),await t.writeULE32(8*e.F1.n64);let r=new Uint8Array(e.F1.n8);l.Ru.toRprLE(r,0,e.q,e.F1.n8),await t.write(r),await t.writeULE32(a),await t.writeULE32(i);let o=t.pos-n-8,s=t.pos;await t.writeULE64(o,n),t.pos=s}async function eg(t,e){if(!e[1])throw Error(t.fileName+": File has no  header");if(e[1].length>1)throw Error(t.fileName+": File has more than one header");t.pos=e[1][0].p;let a=await t.readULE32(),i=await t.read(a),n=l.Ru.fromRprLE(i),r=await O(n);if(8*r.F1.n64!=a)throw Error(t.fileName+": Invalid size");let o=await t.readULE32(),s=await t.readULE32();if(t.pos-e[1][0].p!=e[1][0].size)throw Error("Invalid PTau header size");return{curve:r,power:o,ceremonyPower:s}}async function eh(t,e,a){return ew(await t.read(12*e.F1.n8+6*e.F2.n8),0,e,a)}function ew(t,e,a,i){let n={tau:{},alpha:{},beta:{}};return n.tau.g1_s=r(),n.tau.g1_sx=r(),n.alpha.g1_s=r(),n.alpha.g1_sx=r(),n.beta.g1_s=r(),n.beta.g1_sx=r(),n.tau.g2_spx=o(),n.alpha.g2_spx=o(),n.beta.g2_spx=o(),n;function r(){let n;return n=i?a.G1.fromRprLEM(t,e):a.G1.fromRprUncompressed(t,e),e+=2*a.G1.F.n8,n}function o(){let n;return n=i?a.G2.fromRprLEM(t,e):a.G2.fromRprUncompressed(t,e),e+=2*a.G2.F.n8,n}}function ec(t,e,a,i,n){async function r(i){n?a.G1.toRprLEM(t,e,i):a.G1.toRprUncompressed(t,e,i),e+=2*a.F1.n8}async function o(i){n?a.G2.toRprLEM(t,e,i):a.G2.toRprUncompressed(t,e,i),e+=2*a.F2.n8}return r(i.tau.g1_s),r(i.tau.g1_sx),r(i.alpha.g1_s),r(i.alpha.g1_sx),r(i.beta.g1_s),r(i.beta.g1_sx),o(i.tau.g2_spx),o(i.alpha.g2_spx),o(i.beta.g2_spx),t}async function ed(t,e,a,i){let n=new Uint8Array(12*e.F1.n8+6*e.F2.n8);ec(n,0,e,a,i),await t.write(n)}async function em(t,e){let a={};a.tauG1=await s(),a.tauG2=await u(),a.alphaG1=await s(),a.betaG1=await s(),a.betaG2=await u(),a.key=await eh(t,e,!0),a.partialHash=await t.read(216),a.nextChallenge=await t.read(64),a.type=await t.readULE32();let i=new Uint8Array(12*e.G1.F.n8+6*e.G2.F.n8);ec(i,0,e,a.key,!1);let n=K.exports(64);n.setPartialHash(a.partialHash),n.update(i),a.responseHash=n.digest();let r=await t.readULE32(),o=t.pos,l=0;for(;t.pos-o<r;){let t=await f(1);if(t[0]<=l)throw Error("Parameters in the contribution must be sorted");if(l=t[0],1==t[0]){let t=await f(1),e=await f(t[0]);a.name=new TextDecoder().decode(e)}else if(2==t[0]){let t=await f(1);a.numIterationsExp=t[0]}else if(3==t[0]){let t=await f(1);a.beaconHash=await f(t[0])}else throw Error("Parameter not recognized")}if(t.pos!=o+r)throw Error("Parameters do not match");return a;async function s(){let a=await t.read(2*e.G1.F.n8);return e.G1.fromRprLEM(a)}async function u(){let a=await t.read(2*e.G2.F.n8);return e.G2.fromRprLEM(a)}async function f(e){return new Uint8Array(await t.read(e))}}async function eA(t,e,a){if(!a[7])throw Error(t.fileName+": File has no  contributions");if(a[7][0].length>1)throw Error(t.fileName+": File has more than one contributions section");t.pos=a[7][0].p;let i=await t.readULE32(),n=[];for(let a=0;a<i;a++){let i=await em(t,e);i.id=a+1,n.push(i)}if(t.pos-a[7][0].p!=a[7][0].size)throw Error("Invalid contribution section size");return n}async function ep(t,e,a){let i=new Uint8Array(2*e.F1.n8),n=new Uint8Array(2*e.F2.n8);await o(a.tauG1),await l(a.tauG2),await o(a.alphaG1),await o(a.betaG1),await l(a.betaG2),await ed(t,e,a.key,!0),await t.write(a.partialHash),await t.write(a.nextChallenge),await t.writeULE32(a.type||0);let r=[];if(a.name){r.push(1);let t=new TextEncoder("utf-8").encode(a.name.substring(0,64));r.push(t.byteLength);for(let e=0;e<t.byteLength;e++)r.push(t[e])}if(1==a.type){r.push(2),r.push(a.numIterationsExp),r.push(3),r.push(a.beaconHash.byteLength);for(let t=0;t<a.beaconHash.byteLength;t++)r.push(a.beaconHash[t])}if(r.length>0){let e=new Uint8Array(r);await t.writeULE32(e.byteLength),await t.write(e)}else await t.writeULE32(0);async function o(a){e.G1.toRprLEM(i,0,a),await t.write(i)}async function l(a){e.G2.toRprLEM(n,0,a),await t.write(n)}}async function ey(t,e,a){await t.writeULE32(7);let i=t.pos;await t.writeULE64(0),await t.writeULE32(a.length);for(let i=0;i<a.length;i++)await ep(t,e,a[i]);let n=t.pos-i-8,r=t.pos;await t.writeULE64(n,i),t.pos=r}function eI(t,e,a){let i;a&&a.debug("Calculating First Challenge Hash");let n=new K.exports(64),r=new Uint8Array(2*t.G1.F.n8),o=new Uint8Array(2*t.G2.F.n8);return t.G1.toRprUncompressed(r,0,t.G1.g),t.G2.toRprUncompressed(o,0,t.G2.g),n.update(K.exports(64).digest()),i=2**e*2-1,a&&a.debug("Calculate Initial Hash: tauG1"),l(r,i),i=2**e,a&&a.debug("Calculate Initial Hash: tauG2"),l(o,i),a&&a.debug("Calculate Initial Hash: alphaTauG1"),l(r,i),a&&a.debug("Calculate Initial Hash: betaTauG1"),l(r,i),n.update(o),n.digest();function l(t,e){let i=Math.floor(e/341e3),r=e%341e3,o=new Uint8Array(341e3*t.byteLength);for(let e=0;e<341e3;e++)o.set(t,e*t.byteLength);for(let t=0;t<i;t++)n.update(o),a&&a.debug("Initial hash: "+341e3*t);for(let e=0;e<r;e++)n.update(t)}}async function eb(t,e,a,i){return eu(t,e,await tG(a,i))}async function eC(t,e,a,i){if(1==e.type){let n=await eb(t,a.nextChallenge,e.beaconHash,e.numIterationsExp);if(!t.G1.eq(e.key.tau.g1_s,n.tau.g1_s))return i&&i.error(`BEACON key (tauG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.tau.g1_sx,n.tau.g1_sx))return i&&i.error(`BEACON key (tauG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.tau.g2_spx,n.tau.g2_spx))return i&&i.error(`BEACON key (tauG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.alpha.g1_s,n.alpha.g1_s))return i&&i.error(`BEACON key (alphaG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.alpha.g1_sx,n.alpha.g1_sx))return i&&i.error(`BEACON key (alphaG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.alpha.g2_spx,n.alpha.g2_spx))return i&&i.error(`BEACON key (alphaG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.beta.g1_s,n.beta.g1_s))return i&&i.error(`BEACON key (betaG1_s) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G1.eq(e.key.beta.g1_sx,n.beta.g1_sx))return i&&i.error(`BEACON key (betaG1_sx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1;if(!t.G2.eq(e.key.beta.g2_spx,n.beta.g2_spx))return i&&i.error(`BEACON key (betaG2_spx) is not generated correctly in challenge #${e.id}  ${e.name||""}`),!1}return(e.key.tau.g2_sp=t.G2.toAffine(el(t,0,a.nextChallenge,e.key.tau.g1_s,e.key.tau.g1_sx)),e.key.alpha.g2_sp=t.G2.toAffine(el(t,1,a.nextChallenge,e.key.alpha.g1_s,e.key.alpha.g1_sx)),e.key.beta.g2_sp=t.G2.toAffine(el(t,2,a.nextChallenge,e.key.beta.g1_s,e.key.beta.g1_sx)),!0!==await tE(t,e.key.tau.g1_s,e.key.tau.g1_sx,e.key.tau.g2_sp,e.key.tau.g2_spx))?(i&&i.error("INVALID key (tau) in challenge #"+e.id),!1):!0!==await tE(t,e.key.alpha.g1_s,e.key.alpha.g1_sx,e.key.alpha.g2_sp,e.key.alpha.g2_spx)?(i&&i.error("INVALID key (alpha) in challenge #"+e.id),!1):!0!==await tE(t,e.key.beta.g1_s,e.key.beta.g1_sx,e.key.beta.g2_sp,e.key.beta.g2_spx)?(i&&i.error("INVALID key (beta) in challenge #"+e.id),!1):!0!==await tE(t,a.tauG1,e.tauG1,e.key.tau.g2_sp,e.key.tau.g2_spx)?(i&&i.error("INVALID tau*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await tE(t,e.key.tau.g1_s,e.key.tau.g1_sx,a.tauG2,e.tauG2)?(i&&i.error("INVALID tau*G2. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await tE(t,a.alphaG1,e.alphaG1,e.key.alpha.g2_sp,e.key.alpha.g2_spx)?(i&&i.error("INVALID alpha*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await tE(t,a.betaG1,e.betaG1,e.key.beta.g2_sp,e.key.beta.g2_spx)?(i&&i.error("INVALID beta*G1. challenge #"+e.id+" It does not follow the previous contribution"),!1):!0!==await tE(t,e.key.beta.g1_s,e.key.beta.g1_sx,a.betaG2,e.betaG2)?(i&&i.error("INVALID beta*G2. challenge #"+e.id+"It does not follow the previous contribution"),!1):(i&&i.info("Powers Of tau file OK!"),!0)}async function eE(t,e,a,i,n,r,o,l,s,u){let f=n[r],g=2*f.F.n8,h=e[i][0].size/g;await G(t,e,i),await F(a,i);let w=o;for(let e=0;e<h;e+=65536){let i;u&&u.debug(`Applying key: ${s}: ${e}/${h}`);let r=Math.min(h-e,65536);i=await t.read(r*g),i=await f.batchApplyKey(i,w,l),await a.write(i),w=n.Fr.mul(w,n.Fr.exp(l,r))}await B(a),await Q(t)}async function eS(t,e,a,i,n,r,o,l,s,u,f){let g=i[n],h=2*g.F.n8,w=Math.floor(1048576/h),c=o;for(let n=0;n<r;n+=w){let o;f&&f.debug(`Applying key ${u}: ${n}/${r}`);let d=Math.min(r-n,w),m=await t.read(d*h),A=await g.batchUtoLEM(m),p=await g.batchApplyKey(A,c,l);o="COMPRESSED"==s?await g.batchLEMtoC(p):await g.batchLEMtoU(p),a&&a.update(o),await e.write(o),c=i.Fr.mul(c,i.Fr.exp(l,d))}}var ev=Object.freeze({__proto__:null,newAccumulator:async function(t,e,a,i){await K.exports.ready();let n=await v(a,"ptau",1,7);await ef(n,t,e,0);let r=t.G1.oneAffine,o=t.G2.oneAffine;await F(n,2);let l=2**e*2-1;for(let t=0;t<l;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("tauG1: "+t);await B(n),await F(n,3);let s=2**e;for(let t=0;t<s;t++)await n.write(o),i&&t%1e5==0&&t&&i.log("tauG2: "+t);await B(n),await F(n,4);let u=2**e;for(let t=0;t<u;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("alphaTauG1: "+t);await B(n),await F(n,5);let f=2**e;for(let t=0;t<f;t++)await n.write(r),i&&t%1e5==0&&t&&i.log("betaTauG1: "+t);await B(n),await F(n,6),await n.write(o),await B(n),await F(n,7),await n.writeULE32(0),await B(n),await n.close();let g=eI(t,e,i);return i&&i.debug(tb(K.exports(64).digest(),"Blank Contribution Hash:")),i&&i.info(tb(g,"First Contribution Hash:")),g},exportChallenge:async function(t,e,a){let i,n;await K.exports.ready();let{fd:r,sections:o}=await S(t,"ptau",1),{curve:l,power:s}=await eg(r,o),u=await eA(r,l,o);0==u.length?(i=K.exports(64).digest(),n=eI(l,s)):(i=u[u.length-1].responseHash,n=u[u.length-1].nextChallenge),a&&a.info(tb(i,"Last Response Hash: ")),a&&a.info(tb(n,"New Challenge Hash: "));let f=await C(e),g=K.exports(64);await f.write(i),g.update(i),await w(2,"G1",2**s*2-1,"tauG1"),await w(3,"G2",2**s,"tauG2"),await w(4,"G1",2**s,"alphaTauG1"),await w(5,"G1",2**s,"betaTauG1"),await w(6,"G2",1,"betaG2"),await r.close(),await f.close();let h=g.digest();if(!tC(n,h))throw a&&a.info(tb(h,"Calc Curret Challenge Hash: ")),a&&a.error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one"),Error("PTau file is corrupted. Calculated new challenge hash does not match with the eclared one");return n;async function w(t,e,i,n){let s=l[e],u=2*s.F.n8,h=Math.floor(16777216/u);await G(r,o,t);for(let t=0;t<i;t+=h){let e;a&&a.debug(`Exporting ${n}: ${t}/${i}`);let o=Math.min(i-t,h);e=await r.read(o*u),e=await s.batchLEMtoU(e),await f.write(e),g.update(e)}await Q(r)}},importResponse:async function(t,e,a,i,n,r){let o,l;await K.exports.ready();let s=new Uint8Array(64);for(let t=0;t<64;t++)s[t]=255;let{fd:u,sections:f}=await S(t,"ptau",1),{curve:g,power:h}=await eg(u,f),w=await eA(u,g,f),c={};i&&(c.name=i);let d=2*g.F1.n8,m=g.F1.n8,A=2*g.F2.n8,p=g.F2.n8,y=await E(e);if(y.totalSize!=64+(2**h*2-1)*m+2**h*p+2**h*m+2**h*m+p+6*d+3*A)throw Error("Size of the contribution is invalid");o=w.length>0?w[w.length-1].nextChallenge:eI(g,h,r);let I=await v(a,"ptau",1,n?7:2);await ef(I,g,h);let b=await y.read(64);if(tC(s,o)&&(o=b,w[w.length-1].nextChallenge=o),!tC(b,o))throw Error("Wrong contribution. This contribution is not based on the previous hash");let C=new K.exports(64);C.update(b);let G=[];l=await L(y,I,"G1",2,2**h*2-1,[1],"tauG1"),c.tauG1=l[0],l=await L(y,I,"G2",3,2**h,[1],"tauG2"),c.tauG2=l[0],l=await L(y,I,"G1",4,2**h,[0],"alphaG1"),c.alphaG1=l[0],l=await L(y,I,"G1",5,2**h,[0],"betaG1"),c.betaG1=l[0],l=await L(y,I,"G2",6,1,[0],"betaG2"),c.betaG2=l[0],c.partialHash=C.getPartialHash();let Q=await y.read(12*g.F1.n8+6*g.F2.n8);c.key=ew(Q,0,g,!1),C.update(new Uint8Array(Q));let x=C.digest();if(r&&r.info(tb(x,"Contribution Response Hash imported: ")),n){let t=new K.exports(64);t.update(x),await T(t,I,"G1",2,2**h*2-1,"tauG1",r),await T(t,I,"G2",3,2**h,"tauG2",r),await T(t,I,"G1",4,2**h,"alphaTauG1",r),await T(t,I,"G1",5,2**h,"betaTauG1",r),await T(t,I,"G2",6,1,"betaG2",r),c.nextChallenge=t.digest(),r&&r.info(tb(c.nextChallenge,"Next Challenge Hash: "))}else c.nextChallenge=s;return w.push(c),await ey(I,g,w),await y.close(),await I.close(),await u.close(),c.nextChallenge;async function L(t,e,a,i,r,o,l){return n?await U(t,e,a,i,r,o,l):await _(t,e,a,i,r,o,l)}async function U(t,e,a,i,n,o,l){let s=g[a],u=s.F.n8,f=2*s.F.n8,h=[];await F(e,i);let w=Math.floor(16777216/f);G[i]=e.pos;for(let a=0;a<n;a+=w){r&&r.debug(`Importing ${l}: ${a}/${n}`);let i=Math.min(n-a,w),g=await t.read(i*u);C.update(g);let c=await s.batchCtoLEM(g);await e.write(c);for(let t=0;t<o.length;t++){let e=o[t];if(e>=a&&e<a+i){let t=s.fromRprLEM(c,(e-a)*f);h.push(t)}}}return await B(e),h}async function _(t,e,a,i,n,o,l){let s=g[a],u=s.F.n8,f=[],h=Math.floor(16777216/u);for(let e=0;e<n;e+=h){r&&r.debug(`Importing ${l}: ${e}/${n}`);let a=Math.min(n-e,h),i=await t.read(a*u);C.update(i);for(let t=0;t<o.length;t++){let n=o[t];if(n>=e&&n<e+a){let t=s.fromRprCompressed(i,(n-e)*u);f.push(t)}}}return f}async function T(t,e,a,i,n,r,o){let l=g[a],s=2*l.F.n8,u=Math.floor(16777216/s),f=e.pos;e.pos=G[i];for(let a=0;a<n;a+=u){o&&o.debug(`Hashing ${r}: ${a}/${n}`);let i=Math.min(n-a,u),f=await e.read(i*s),g=await l.batchLEMtoU(f);t.update(g)}e.pos=f}},verify:async function(t,e){let a;await K.exports.ready();let{fd:i,sections:n}=await S(t,"ptau",1),{curve:r,power:o,ceremonyPower:s}=await eg(i,n),u=await eA(i,r,n);e&&e.debug("power: 2**"+o),e&&e.debug("Computing initial contribution hash");let f={tauG1:r.G1.g,tauG2:r.G2.g,alphaG1:r.G1.g,betaG1:r.G1.g,betaG2:r.G2.g,nextChallenge:eI(r,s,e),responseHash:K.exports(64).digest()};if(0==u.length)return e&&e.error("This file has no contribution! It cannot be used in production"),!1;a=u.length>1?u[u.length-2]:f;let g=u[u.length-1];if(e&&e.debug("Validating contribution #"+u[u.length-1].id),!await eC(r,g,a,e))return!1;let h=K.exports(64);h.update(g.responseHash),e&&e.debug("Verifying powers in tau*G1 section");let w=await b(2,"G1","tauG1",2**o*2-1,[0,1],e);if(!0!==await tE(r,w.R1,w.R2,r.G2.g,g.tauG2))return e&&e.error("tauG1 section. Powers do not match"),!1;if(!r.G1.eq(r.G1.g,w.singularPoints[0]))return e&&e.error("First element of tau*G1 section must be the generator"),!1;if(!r.G1.eq(g.tauG1,w.singularPoints[1]))return e&&e.error("Second element of tau*G1 section does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in tau*G2 section");let c=await b(3,"G2","tauG2",2**o,[0,1],e);if(!0!==await tE(r,r.G1.g,g.tauG1,c.R1,c.R2))return e&&e.error("tauG2 section. Powers do not match"),!1;if(!r.G2.eq(r.G2.g,c.singularPoints[0]))return e&&e.error("First element of tau*G2 section must be the generator"),!1;if(!r.G2.eq(g.tauG2,c.singularPoints[1]))return e&&e.error("Second element of tau*G2 section does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in alpha*tau*G1 section");let d=await b(4,"G1","alphatauG1",2**o,[0],e);if(!0!==await tE(r,d.R1,d.R2,r.G2.g,g.tauG2))return e&&e.error("alphaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(g.alphaG1,d.singularPoints[0]))return e&&e.error("First element of alpha*tau*G1 section (alpha*G1) does not match the one in the contribution section"),!1;e&&e.debug("Verifying powers in beta*tau*G1 section");let m=await b(5,"G1","betatauG1",2**o,[0],e);if(!0!==await tE(r,m.R1,m.R2,r.G2.g,g.tauG2))return e&&e.error("betaTauG1 section. Powers do not match"),!1;if(!r.G1.eq(g.betaG1,m.singularPoints[0]))return e&&e.error("First element of beta*tau*G1 section (beta*G1) does not match the one in the contribution section"),!1;let A=await I(e);if(!r.G2.eq(g.betaG2,A))return e&&e.error("betaG2 element in betaG2 section does not match the one in the contribution section"),!1;let p=h.digest();if(o==s&&!tC(p,g.nextChallenge))return e&&e.error("Hash of the values does not match the next challenge of the last contributor in the contributions section"),!1;e&&e.info(tb(p,"Next challenge hash: ")),y(g,a);for(let t=u.length-2;t>=0;t--){let a=u[t],i=t>0?u[t-1]:f;if(!await eC(r,a,i,e))return!1;y(a,i)}if(e&&e.info("-----------------------------------------------------"),n[12]&&n[13]&&n[14]&&n[15]){if(!await C("G1",2,12,"tauG1",e)||!await C("G2",3,13,"tauG2",e)||!await C("G1",4,14,"alphaTauG1",e)||!await C("G1",5,15,"betaTauG1",e))return!1}else e&&e.warn('this file does not contain phase2 precalculated values. Please run: \n   snarkjs "powersoftau preparephase2" to prepare this file to be used in the phase2 ceremony.');return await i.close(),e&&e.info("Powers of Tau Ok!"),!0;function y(t,a){if(!e)return;e.info("-----------------------------------------------------"),e.info(`Contribution #${t.id}: ${t.name||""}`),e.info(tb(t.nextChallenge,"Next Challenge: "));let i=new Uint8Array(12*r.G1.F.n8+6*r.G2.F.n8);ec(i,0,r,t.key,!1);let n=K.exports(64);n.setPartialHash(t.partialHash),n.update(i);let o=n.digest();e.info(tb(o,"Response Hash:")),e.info(tb(a.nextChallenge,"Response Hash:")),1==t.type&&(e.info(`Beacon generator: ${tx(t.beaconHash)}`),e.info(`Beacon iterations Exp: ${t.numIterationsExp}`))}async function I(t){let e=r.G2,a=2*e.F.n8,o=new Uint8Array(a);if(!n[6])throw t.error("File has no BetaG2 section"),Error("File has no BetaG2 section");if(n[6].length>1)throw t.error("File has no BetaG2 section"),Error("File has more than one GetaG2 section");i.pos=n[6][0].p;let l=await i.read(a),s=e.fromRprLEM(l);return e.toRprUncompressed(o,0,s),h.update(o),s}async function b(t,e,a,o,l,s){let u=r[e],f=2*u.F.n8;await G(i,n,t);let g=[],w=u.zero,c=u.zero,d=u.zero;for(let t=0;t<o;t+=65536){s&&s.debug(`points relations: ${a}: ${t}/${o} `);let e=Math.min(o-t,65536),n=await i.read(e*f),r=await u.batchLEMtoU(n);h.update(r);let m=tS(4*(e-1));if(t>0){let t=u.fromRprLEM(n,0),e=tF(tS(4),0);w=u.add(w,u.timesScalar(d,e)),c=u.add(c,u.timesScalar(t,e))}let A=await u.multiExpAffine(n.slice(0,(e-1)*f),m),p=await u.multiExpAffine(n.slice(f),m);w=u.add(w,A),c=u.add(c,p),d=u.fromRprLEM(n,(e-1)*f);for(let a=0;a<l.length;a++){let i=l[a];if(i>=t&&i<t+e){let e=u.fromRprLEM(n,(i-t)*f);g.push(e)}}}return await Q(i),{R1:w,R2:c,singularPoints:g}}async function C(t,e,a,s,u){u&&u.debug(`Verifying phase2 calculated values ${s}...`);let f=r[t],g=2*f.F.n8,h=Array(8);for(let t=0;t<8;t++)h[t]=tF(tS(4),0);for(let t=0;t<=o;t++)if(!await w(t))return!1;if(2==e&&!await w(o+1))return!1;return!0;async function w(t){let w;u&&u.debug(`Power ${t}...`);let c=r.Fr.n8,d=2**t,m=new Uint32Array(d),A=new l.XY(h);u&&u.debug(`Creating random numbers Powers${t}...`);for(let e=0;e<d;e++)t==o+1&&e==d-1?m[e]=0:m[e]=A.nextU32();m=new Uint8Array(m.buffer,m.byteOffset,m.byteLength),u&&u.debug(`reading points Powers${t}...`),await G(i,n,e),w=new l.qc(d*g),t==o+1?(await i.readToBuffer(w,0,(d-1)*g),w.set(r.G1.zeroAffine,(d-1)*g)):await i.readToBuffer(w,0,d*g),await Q(i,!0);let p=await f.multiExpAffine(w,m,u,s+"_"+t);m=new l.qc(d*c),A=new l.XY(h);let y=new Uint8Array(4),I=new DataView(y.buffer);u&&u.debug(`Creating random numbers Powers${t}...`);for(let e=0;e<d;e++)(e!=d-1||t!=o+1)&&(I.setUint32(0,A.nextU32(),!0),m.set(y,e*c));u&&u.debug(`batchToMontgomery ${t}...`),m=await r.Fr.batchToMontgomery(m),u&&u.debug(`fft ${t}...`),m=await r.Fr.fft(m),u&&u.debug(`batchFromMontgomery ${t}...`),m=await r.Fr.batchFromMontgomery(m),u&&u.debug(`reading points Lagrange${t}...`),await G(i,n,a),i.pos+=g*(2**t-1),await i.readToBuffer(w,0,d*g),await Q(i,!0);let b=await f.multiExpAffine(w,m,u,s+"_"+t+"_transformed");return!!f.eq(p,b)||(u&&u.error("Phase2 caclutation does not match with powers of tau"),!1)}}},challengeContribute:async function(t,e,a,i,n){await K.exports.ready();let r=await E(e),o=16*t.F1.n64,l=16*t.F2.n64,s=(r.totalSize+o-64-l)/(4*o+l),u=s,f=0;for(;u>1;)u/=2,f+=1;if(2**f!=s)throw Error("Invalid file size");n&&n.debug("Power to tau size: "+f);let g=await tB(i),h=await C(a),w=K.exports(64);for(let t=0;t<r.totalSize;t+=r.pageSize){n&&n.debug(`Hashing challenge ${t}/${r.totalSize}`);let e=Math.min(r.totalSize-t,r.pageSize),a=await r.read(e);w.update(a)}let c=await r.read(64,0);n&&n.info(tb(c,"Claimed Previous Response Hash: "));let d=w.digest();n&&n.info(tb(d,"Current Challenge Hash: "));let m=eu(t,d,g);n&&["tau","alpha","beta"].forEach(e=>{n.debug(e+".g1_s: "+t.G1.toString(m[e].g1_s,16)),n.debug(e+".g1_sx: "+t.G1.toString(m[e].g1_sx,16)),n.debug(e+".g2_sp: "+t.G2.toString(m[e].g2_sp,16)),n.debug(e+".g2_spx: "+t.G2.toString(m[e].g2_spx,16)),n.debug("")});let A=K.exports(64);await h.write(d),A.update(d),await eS(r,h,A,t,"G1",2**f*2-1,t.Fr.one,m.tau.prvKey,"COMPRESSED","tauG1",n),await eS(r,h,A,t,"G2",2**f,t.Fr.one,m.tau.prvKey,"COMPRESSED","tauG2",n),await eS(r,h,A,t,"G1",2**f,m.alpha.prvKey,m.tau.prvKey,"COMPRESSED","alphaTauG1",n),await eS(r,h,A,t,"G1",2**f,m.beta.prvKey,m.tau.prvKey,"COMPRESSED","betaTauG1",n),await eS(r,h,A,t,"G2",1,m.beta.prvKey,m.tau.prvKey,"COMPRESSED","betaTauG2",n);let p=new Uint8Array(12*t.F1.n8+6*t.F2.n8);ec(p,0,t,m,!1),await h.write(p),A.update(p);let y=A.digest();n&&n.info(tb(y,"Contribution Response Hash: ")),await h.close(),await r.close()},beacon:async function(t,e,a,i,n,r){let o,l;let s=tQ(i);if(0==s.byteLength||2*s.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(s.length>=256)return r&&r.error("Maximum length of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;await K.exports.ready();let{fd:u,sections:f}=await S(t,"ptau",1),{curve:g,power:h,ceremonyPower:w}=await eg(u,f);if(h!=w)return r&&r.error("This file has been reduced. You cannot contribute into a reduced file."),!1;f[12]&&r&&r.warn("Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let c=await eA(u,g,f),d={name:a,type:1,numIterationsExp:n,beaconHash:s};o=c.length>0?c[c.length-1].nextChallenge:eI(g,h,r),d.key=await eb(g,o,s,n);let m=new K.exports(64);m.update(o);let A=await v(e,"ptau",1,7);await ef(A,g,h);let p=[];l=await C(2,"G1",2**h*2-1,g.Fr.e(1),d.key.tau.prvKey,"tauG1",r),d.tauG1=l[1],l=await C(3,"G2",2**h,g.Fr.e(1),d.key.tau.prvKey,"tauG2",r),d.tauG2=l[1],l=await C(4,"G1",2**h,d.key.alpha.prvKey,d.key.tau.prvKey,"alphaTauG1",r),d.alphaG1=l[0],l=await C(5,"G1",2**h,d.key.beta.prvKey,d.key.tau.prvKey,"betaTauG1",r),d.betaG1=l[0],l=await C(6,"G2",1,d.key.beta.prvKey,d.key.tau.prvKey,"betaTauG2",r),d.betaG2=l[0],d.partialHash=m.getPartialHash();let y=new Uint8Array(12*g.F1.n8+6*g.F2.n8);ec(y,0,g,d.key,!1),m.update(new Uint8Array(y));let I=m.digest();r&&r.info(tb(I,"Contribution Response Hash imported: "));let b=new K.exports(64);return b.update(I),await E(A,"G1",2,2**h*2-1,"tauG1",r),await E(A,"G2",3,2**h,"tauG2",r),await E(A,"G1",4,2**h,"alphaTauG1",r),await E(A,"G1",5,2**h,"betaTauG1",r),await E(A,"G2",6,1,"betaG2",r),d.nextChallenge=b.digest(),r&&r.info(tb(d.nextChallenge,"Next Challenge Hash: ")),c.push(d),await ey(A,g,c),await u.close(),await A.close(),I;async function C(t,e,a,i,n,r,o){let l=[];u.pos=f[t][0].p,await F(A,t),p[t]=A.pos;let s=g[e],h=2*s.F.n8,w=Math.floor(1048576/h),c=i;for(let t=0;t<a;t+=w){o&&o.debug(`applying key${r}: ${t}/${a}`);let e=Math.min(a-t,w),i=await u.read(e*h),f=await s.batchApplyKey(i,c,n),d=A.write(f),p=await s.batchLEMtoC(f);if(m.update(p),await d,0==t)for(let t=0;t<Math.min(2,a);t++)l.push(s.fromRprLEM(f,t*h));c=g.Fr.mul(c,g.Fr.exp(n,e))}return await B(A),l}async function E(t,e,a,i,n,r){let o=g[e],l=2*o.F.n8,s=Math.floor(16777216/l),u=t.pos;t.pos=p[a];for(let e=0;e<i;e+=s){r&&r.debug(`Hashing ${n}: ${e}/${i}`);let a=Math.min(i-e,s),u=await t.read(a*l),f=await o.batchLEMtoU(u);b.update(f)}t.pos=u}},contribute:async function(t,e,a,i,n){let r,o;await K.exports.ready();let{fd:l,sections:s}=await S(t,"ptau",1),{curve:u,power:f,ceremonyPower:g}=await eg(l,s);if(f!=g)throw n&&n.error("This file has been reduced. You cannot contribute into a reduced file."),Error("This file has been reduced. You cannot contribute into a reduced file.");s[12]&&n&&n.warn("WARNING: Contributing into a file that has phase2 calculated. You will have to prepare phase2 again.");let h=await eA(l,u,s),w={name:a,type:0},c=await tB(i);r=h.length>0?h[h.length-1].nextChallenge:eI(u,f,n),w.key=eu(u,r,c);let d=new K.exports(64);d.update(r);let m=await v(e,"ptau",1,7);await ef(m,u,f);let A=[];o=await b(2,"G1",2**f*2-1,u.Fr.e(1),w.key.tau.prvKey,"tauG1"),w.tauG1=o[1],o=await b(3,"G2",2**f,u.Fr.e(1),w.key.tau.prvKey,"tauG2"),w.tauG2=o[1],o=await b(4,"G1",2**f,w.key.alpha.prvKey,w.key.tau.prvKey,"alphaTauG1"),w.alphaG1=o[0],o=await b(5,"G1",2**f,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG1"),w.betaG1=o[0],o=await b(6,"G2",1,w.key.beta.prvKey,w.key.tau.prvKey,"betaTauG2"),w.betaG2=o[0],w.partialHash=d.getPartialHash();let p=new Uint8Array(12*u.F1.n8+6*u.F2.n8);ec(p,0,u,w.key,!1),d.update(new Uint8Array(p));let y=d.digest();n&&n.info(tb(y,"Contribution Response Hash imported: "));let I=new K.exports(64);return I.update(y),await C(m,"G1",2,2**f*2-1,"tauG1"),await C(m,"G2",3,2**f,"tauG2"),await C(m,"G1",4,2**f,"alphaTauG1"),await C(m,"G1",5,2**f,"betaTauG1"),await C(m,"G2",6,1,"betaG2"),w.nextChallenge=I.digest(),n&&n.info(tb(w.nextChallenge,"Next Challenge Hash: ")),h.push(w),await ey(m,u,h),await l.close(),await m.close(),y;async function b(t,e,a,i,r,o){let f=[];l.pos=s[t][0].p,await F(m,t),A[t]=m.pos;let g=u[e],h=2*g.F.n8,w=Math.floor(1048576/h),c=i;for(let t=0;t<a;t+=w){n&&n.debug(`processing: ${o}: ${t}/${a}`);let e=Math.min(a-t,w),i=await l.read(e*h),s=await g.batchApplyKey(i,c,r),A=m.write(s),p=await g.batchLEMtoC(s);if(d.update(p),await A,0==t)for(let t=0;t<Math.min(2,a);t++)f.push(g.fromRprLEM(s,t*h));c=u.Fr.mul(c,u.Fr.exp(r,e))}return await B(m),f}async function C(t,e,a,i,r){let o=u[e],l=2*o.F.n8,s=Math.floor(16777216/l),f=t.pos;t.pos=A[a];for(let e=0;e<i;e+=s){n&&e&&n.debug(`Hashing ${r}: `+e);let a=Math.min(i-e,s),u=await t.read(a*l),f=await o.batchLEMtoU(u);I.update(f)}t.pos=f}},preparePhase2:async function(t,e,a){let{fd:i,sections:n}=await S(t,"ptau",1),{curve:r,power:o}=await eg(i,n),s=await v(e,"ptau",1,11);async function u(t,e,u,f){a&&a.debug("Starting section: "+f),await F(s,e);for(let t=0;t<=o;t++)await g(t);async function g(e){let g;let h=2**e,w=r[u],c=2*w.F.n8;g=new l.qc(h*c),await G(i,n,t),2==t&&e==o+1?(await i.readToBuffer(g,0,(h-1)*c),g.set(r.G1.zeroAffine,(h-1)*c)):await i.readToBuffer(g,0,h*c),await Q(i,!0),g=await w.lagrangeEvaluations(g,"affine","affine",a,f),await s.write(g)}2==t&&await g(o+1),await B(s)}await ef(s,r,o),await U(i,n,s,2),await U(i,n,s,3),await U(i,n,s,4),await U(i,n,s,5),await U(i,n,s,6),await U(i,n,s,7),await u(2,12,"G1","tauG1"),await u(3,13,"G2","tauG2"),await u(4,14,"G1","alphaTauG1"),await u(5,15,"G1","betaTauG1"),await i.close(),await s.close()},truncate:async function(t,e,a){let{fd:i,sections:n}=await S(t,"ptau",1),{curve:r,power:o,ceremonyPower:l}=await eg(i,n),s=2*r.G1.F.n8,u=2*r.G2.F.n8;for(let t=1;t<o;t++)await f(t);return await i.close(),!0;async function f(t){let o=t.toString();for(;o.length<2;)o="0"+o;a&&a.debug("Writing Power: "+o);let f=await v(e+o+".ptau","ptau",1,11);await ef(f,r,t,l),await U(i,n,f,2,(2**t*2-1)*s),await U(i,n,f,3,2**t*u),await U(i,n,f,4,2**t*s),await U(i,n,f,5,2**t*s),await U(i,n,f,6,u),await U(i,n,f,7),await U(i,n,f,12,(2**(t+1)*2-1)*s),await U(i,n,f,13,(2**t*2-1)*u),await U(i,n,f,14,(2**t*2-1)*s),await U(i,n,f,15,(2**t*2-1)*s),await f.close()}},convert:async function(t,e,a){let{fd:i,sections:n}=await S(t,"ptau",1),{curve:r,power:o}=await eg(i,n),s=await v(e,"ptau",1,11);async function u(t,e,u,f){a&&a.debug("Starting section: "+f),await F(s,e);let g=n[e][0].size,h=i.pageSize;await G(i,n,e);for(let t=0;t<g;t+=h){let e=Math.min(g-t,h),a=await i.read(e);await s.write(a)}async function w(e){let g;let h=2**e,w=r[u],c=2*w.F.n8;g=new l.qc(h*c),await G(i,n,t),2==t&&e==o+1?(await i.readToBuffer(g,0,(h-1)*c),g.set(r.G1.zeroAffine,(h-1)*c)):await i.readToBuffer(g,0,h*c),await Q(i,!0),g=await w.lagrangeEvaluations(g,"affine","affine",a,f),await s.write(g)}await Q(i),2==t&&await w(o+1),await B(s)}await ef(s,r,o),await U(i,n,s,2),await U(i,n,s,3),await U(i,n,s,4),await U(i,n,s,5),await U(i,n,s,6),await U(i,n,s,7),await u(2,12,"G1","tauG1"),await U(i,n,s,13),await U(i,n,s,14),await U(i,n,s,15),await i.close(),await s.close()},exportJson:async function(t,e){let{fd:a,sections:i}=await S(t,"ptau",1),{curve:n,power:r}=await eg(a,i),o={};return o.q=n.q,o.power=r,o.contributions=await eA(a,n,i),o.tauG1=await l(2,"G1",2**r*2-1,"tauG1"),o.tauG2=await l(3,"G2",2**r,"tauG2"),o.alphaTauG1=await l(4,"G1",2**r,"alphaTauG1"),o.betaTauG1=await l(5,"G1",2**r,"betaTauG1"),o.betaG2=await l(6,"G2",1,"betaG2"),o.lTauG1=await s(12,"G1","lTauG1"),o.lTauG2=await s(13,"G2","lTauG2"),o.lAlphaTauG1=await s(14,"G1","lAlphaTauG2"),o.lBetaTauG1=await s(15,"G1","lBetaTauG2"),await a.close(),tL(n.Fr,o);async function l(t,r,o,l){let s=n[r],u=2*s.F.n8,f=[];await G(a,i,t);for(let t=0;t<o;t++){e&&t&&t%1e4==0&&console.log(`${l}: `+t);let i=await a.read(u);f.push(s.fromRprLEM(i,0))}return await Q(a),f}async function s(t,o,l){let s=n[o],u=2*s.F.n8,f=[];await G(a,i,t);for(let t=0;t<=r;t++){e&&console.log(`${l}: Power: ${t}`),f[t]=[];let i=2**t;for(let n=0;n<i;n++){e&&n&&n%1e4==0&&console.log(`${l}: ${n}/${i}`);let r=await a.read(u);f[t].push(s.fromRprLEM(r,0))}}return await Q(a,!0),f}}});let eF={get:function(t,e){return isNaN(e)?t[e]:t.getElement(e)},set:function(t,e,a){return isNaN(e)?(t[e]=a,!0):t.setElement(e,a)}};class eB{constructor(t){this.length=t||0,this.arr=Array(262144);for(let e=0;e<t;e+=262144)this.arr[e/262144]=Array(Math.min(262144,t-e));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,e){let a=Array(e-t);for(let i=t;i<e;i++)a[i-t]=this.getElement(i);return a}getElement(t){let e=Math.floor((t=parseInt(t))/262144),a=t%262144;return this.arr[e]?this.arr[e][a]:void 0}setElement(t,e){let a=Math.floor((t=parseInt(t))/262144);this.arr[a]||(this.arr[a]=Array(262144));let i=t%262144;return this.arr[a][i]=e,t>=this.length&&(this.length=t+1),!0}getKeys(){let t=new eG;for(let e=0;e<this.arr.length;e++)if(this.arr[e])for(let a=0;a<this.arr[e].length;a++)void 0!==this.arr[e][a]&&t.push(262144*e+a);return t}}class eG{constructor(t){return new Proxy(new eB(t),eF)}}async function eQ(t,e,a){let i;i="object"==typeof a?a:void 0===a?{singleThread:!1}:{singleThread:a};let n={};if(await G(t,e,1),n.n8=await t.readULE32(),n.prime=await L(t,n.n8),i.F){if(i.F.p!=n.prime)throw Error("Different Prime");n.F=i.F}else if(i.getFieldFromPrime)n.F=await i.getFieldFromPrime(n.prime,i.singleThread);else if(i.getCurveFromPrime)n.curve=await i.getCurveFromPrime(n.prime,i.singleThread),n.F=n.curve.Fr;else try{n.curve=await (0,l.kx)(n.prime,i.singleThread),n.F=n.curve.Fr}catch(t){n.F=new l.FX(n.prime)}return n.nVars=await t.readULE32(),n.nOutputs=await t.readULE32(),n.nPubInputs=await t.readULE32(),n.nPrvInputs=await t.readULE32(),n.nLabels=await t.readULE64(),n.nConstraints=await t.readULE32(),n.useCustomGates=void 0!==e[4]&&null!==e[4]&&void 0!==e[5]&&null!==e[5],await Q(t),n}async function ex(t,e,a,i,n){let r,o;r="object"==typeof i?i:void 0===i?{}:{logger:i,loggerCtx:n};let l=await _(t,e,2),s=0;o=a.nConstraints>1048576?new eG:[];for(let t=0;t<a.nConstraints;t++){r.logger&&t%1e5==0&&r.logger.info(`${r.loggerCtx}: Loading constraints: ${t}/${a.nConstraints}`);let e=function(){let t=[];return t[0]=u(),t[1]=u(),t[2]=u(),t}();o.push(e)}return o;function u(){let t={},e=l.slice(s,s+4);s+=4;let i=new DataView(e.buffer).getUint32(0,!0),n=l.slice(s,s+(4+a.n8)*i);s+=(4+a.n8)*i;let r=new DataView(n.buffer);for(let e=0;e<i;e++){let i=r.getUint32(e*(4+a.n8),!0),o=a.F.fromRprLE(n,e*(4+a.n8)+4);t[i]=o}return t}}async function eL(t,e,a,i,n){let r,o;r="object"==typeof i?i:void 0===i?{}:{logger:i,loggerCtx:n};let l=await _(t,e,3),s=0;o=a.nVars>1048576?new eG:[];for(let t=0;t<a.nVars;t++){r.logger&&t%1e4==0&&r.logger.info(`${r.loggerCtx}: Loading map: ${t}/${a.nVars}`);let e=function(){let t=l.slice(s,s+8);s+=8;let e=new DataView(t.buffer),a=e.getUint32(0,!0);return 4294967296*e.getUint32(4,!0)+a}();o.push(e)}return o}async function eU(t,e,a){if("object"!=typeof a)throw Error("readR1csFd: options must be an object");a.loadConstraints=!("loadConstraints"in a)||a.loadConstraints,a.loadMap="loadMap"in a&&a.loadMap,a.loadCustomGates=!("loadCustomGates"in a)||a.loadCustomGates;let i=await eQ(t,e,a);return a.loadConstraints&&(i.constraints=await ex(t,e,i,a)),a.loadMap&&(i.map=await eL(t,e,i,a)),a.loadCustomGates&&(i.useCustomGates?(i.customGates=await eT(t,e,i),i.customGatesUses=await ez(t,e,a)):(i.customGates=[],i.customGatesUses=[])),i}async function e_(t,e,a,i,n,r){let o;o="object"==typeof e?e:void 0===e?{loadConstraints:!0,loadMap:!1,loadCustomGates:!0}:{loadConstraints:e,loadMap:a,singleThread:i,logger:n,loggerCtx:r};let{fd:l,sections:s}=await S(t,"r1cs",1),u=await eU(l,s,o);return await l.close(),u}async function eT(t,e,a){await G(t,e,4);let i=await t.readULE32(),n=[];for(let e=0;e<i;e++){let e={};e.templateName=await t.readString();let i=await t.readULE32();e.parameters=Array(i);let r=await t.read(a.n8*i);for(let t=0;t<i;t++)e.parameters[t]=a.F.fromRprLE(r,t*a.n8,a.n8);n.push(e)}return await Q(t),n}async function ez(t,e,a){let i;let n=await _(t,e,5),r=new Uint32Array(n.buffer,n.byteOffset,n.byteLength/4),o=r[0],l=1;i=o>1048576?new eG:[];for(let t=0;t<o;t++){a.logger&&t%1e5==0&&a.logger.info(`${a.loggerCtx}: Loading custom gate uses: ${t}/${o}`);let e={};e.id=r[l++];let n=r[l++];e.signals=[];for(let t=0;t<n;t++){let t=r[l++],a=r[l++];e.signals.push(4294967296*a+t)}i.push(e)}return i}let eP=l.Ru.e("73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001",16),eD=l.Ru.e("21888242871839275222246405745257275088548364400416034343698204186575808495617");var eR=Object.freeze({__proto__:null,print:function(t,e,a){for(let i=0;i<t.constraints.length;i++)!function(i){let n=a=>{let i="";return Object.keys(a).forEach(n=>{let r=e.varIdx2Name[n];"one"==r&&(r="1");let o=t.curve.Fr.toString(a[n]);"1"==o&&(o=""),"-1"==o&&(o="-"),""!=i&&"-"!=o[0]&&(o="+"+o),""!=i&&(o=" "+o),i=i+o+r}),i},r=`[ ${n(i[0])} ] * [ ${n(i[1])} ] - [ ${n(i[2])} ] = 0`;a&&a.info(r)}(t.constraints[i])},info:async function(t,e){let a=await e_(t);return l.Ru.eq(a.prime,eD)?e&&e.info("Curve: bn-128"):l.Ru.eq(a.prime,eP)?e&&e.info("Curve: bls12-381"):e&&e.info(`Unknown Curve. Prime: ${l.Ru.toString(a.prime)}`),e&&e.info(`# of Wires: ${a.nVars}`),e&&e.info(`# of Constraints: ${a.nConstraints}`),e&&e.info(`# of Private Inputs: ${a.nPrvInputs}`),e&&e.info(`# of Public Inputs: ${a.nPubInputs}`),e&&e.info(`# of Labels: ${a.nLabels}`),e&&e.info(`# of Outputs: ${a.nOutputs}`),a},exportJson:async function(t,e){let a=await e_(t,!0,!0,!0,e),i=a.curve.Fr;return delete a.curve,delete a.F,tL(i,a)}});async function ek(t){let e={labelIdx2Name:["one"],varIdx2Name:["one"],componentIdx2Name:[]},a=await E(t),i=await a.read(a.totalSize),n=new TextDecoder("utf-8").decode(i).split("\n");for(let t=0;t<n.length;t++){let a=n[t].split(",");4!=a.length||(e.varIdx2Name[a[1]]?e.varIdx2Name[a[1]]+="|"+a[3]:e.varIdx2Name[a[1]]=a[3],e.labelIdx2Name[a[0]]=a[3],e.componentIdx2Name[a[2]]||(e.componentIdx2Name[a[2]]=function(t){let e=t.split(".");return e.pop(),e.join(".")}(a[3])))}return await a.close(),e}let{unstringifyBigInts:eO}=l.utils;var eM=Object.freeze({__proto__:null,calculate:t7,debug:async function(t,e,a,i,n,r){let o=eO(t),l=await E(e),s=await l.read(l.totalSize);await l.close();let u={...n,sanityCheck:!0},f=await ek(i);n.set&&(f||(f=await ek(i)),u.logSetSignal=function(t,e){r&&r.info("SET "+f.labelIdx2Name[t]+" <-- "+e.toString())}),n.get&&(f||(f=await ek(i)),u.logGetSignal=function(t,e){r&&r.info("GET "+f.labelIdx2Name[t]+" --> "+e.toString())}),n.trigger&&(f||(f=await ek(i)),u.logStartComponent=function(t){r&&r.info("START: "+f.componentIdx2Name[t])},u.logFinishComponent=function(t){r&&r.info("FINISH: "+f.componentIdx2Name[t])}),u.sym=f;let g=await t3(s,u),h=await g.calculateWitness(o,!0),w=await v(a,"wtns",2,2);await tj(w,h,g.prime),await w.close()},exportJson:async function(t){return await tZ(t)},check:async function(t,e,a){a&&a.info("WITNESS CHECKING STARTED"),a&&a.info("> Reading r1cs file");let{fd:i,sections:n}=await S(t,"r1cs",1),r=await eU(i,n,{loadConstraints:!1,loadCustomGates:!1});a&&a.info("> Reading witness file");let{fd:o,sections:s}=await S(e,"wtns",2),u=await tY(o,s);if(!l.Ru.eq(r.prime,u.q))throw Error("Curve of the witness does not match the curve of the proving key");let f=await _(o,s,2);await o.close();let g=(await k(r.prime)).Fr,h=g.n8,w=await _(i,n,2);a&&(a.info("----------------------------"),a.info("  WITNESS CHECK"),a.info(`  Curve:          ${r.curve.name}`),a.info(`  Vars (wires):   ${r.nVars}`),a.info(`  Outputs:        ${r.nOutputs}`),a.info(`  Public Inputs:  ${r.nPubInputs}`),a.info(`  Private Inputs: ${r.nPrvInputs}`),a.info(`  Labels:         ${r.nLabels}`),a.info(`  Constraints:    ${r.nConstraints}`),a.info(`  Custom Gates:   ${r.useCustomGates}`),a.info("----------------------------")),a&&a.info("> Checking witness correctness");let c=0,d=!0;for(let t=0;t<r.nConstraints;t++){a&&0!==t&&t%5e5==0&&a.info(`\xb7\xb7\xb7 processing r1cs constraints ${t}/${r.nConstraints}`);let e=A(),i=A(),n=A(),o=m(e),l=m(i),s=m(n);if(!g.eq(g.sub(g.mul(o,l),s),g.zero)){a.warn("\xb7\xb7\xb7 aborting checking process at constraint "+t),d=!1;break}}return i.close(),a&&(d?(a.info("WITNESS IS CORRECT"),a.info("WITNESS CHECKING FINISHED SUCCESSFULLY")):(a.warn("WITNESS IS NOT CORRECT"),a.warn("WITNESS CHECKING FINISHED UNSUCCESSFULLY"))),d;function m(t){let e=g.zero;return Object.keys(t).forEach(a=>{let i=g.fromRprLE(f.slice(a*h,a*h+h)),n=t[a];e=g.add(e,g.mul(i,n))}),e}function A(){let t={},e=w.slice(c,c+4);c+=4;let a=new DataView(e.buffer).getUint32(0,!0),i=w.slice(c,c+(4+r.n8)*a);c+=(4+r.n8)*a;let n=new DataView(i.buffer);for(let e=0;e<a;e++){let a=n.getUint32(e*(4+r.n8),!0),o=r.F.fromRprLE(i,e*(4+r.n8)+4);t[a]=o}return t}}});let eV={get:function(t,e){return isNaN(e)?t[e]:t.getElement(e)},set:function(t,e,a){return isNaN(e)?(t[e]=a,!0):t.setElement(e,a)}};class eq{constructor(t){this.length=t||0,this.arr=Array(262144);for(let e=0;e<t;e+=262144)this.arr[e/262144]=Array(Math.min(262144,t-e));return this}push(){for(let t=0;t<arguments.length;t++)this.setElement(this.length,arguments[t])}slice(t,e){let a=Array(e-t);for(let i=t;i<e;i++)a[i-t]=this.getElement(i);return a}getElement(t){let e=Math.floor((t=parseInt(t))/262144),a=t%262144;return this.arr[e]?this.arr[e][a]:void 0}setElement(t,e){let a=Math.floor((t=parseInt(t))/262144);this.arr[a]||(this.arr[a]=Array(262144));let i=t%262144;return this.arr[a][i]=e,t>=this.length&&(this.length=t+1),!0}getKeys(){let t=new eK;for(let e=0;e<this.arr.length;e++)if(this.arr[e])for(let a=0;a<this.arr[e].length;a++)void 0!==this.arr[e][a]&&t.push(262144*e+a);return t}}class eK{constructor(t){return new Proxy(new eq(t),eV)}}async function e$(t,e,a,i){let n,r,o;await K.exports.ready();let s=K.exports(64),{fd:u,sections:f}=await S(e,"ptau",1),{curve:g,power:h}=await eg(u,f),{fd:w,sections:c}=await S(t,"r1cs",1),d=await eQ(w,c,!1),m=await v(a,"zkey",1,10,4194304,16777216),A=2*g.G1.F.n8,p=2*g.G2.F.n8;if(d.prime!=g.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;let y=tI(d.nConstraints+d.nPubInputs+d.nOutputs+1-1)+1;if(y>h)return i&&i.error(`circuit too big for this power of tau ceremony. ${d.nConstraints}*2 > 2**${h}`),-1;if(!f[12])return i&&i.error("Powers of tau is not prepared."),-1;let I=d.nOutputs+d.nPubInputs,b=2**y;await F(m,1),await m.writeULE32(1),await B(m),await F(m,2);let C=g.q,E=(Math.floor((l.Ru.bitLength(C)-1)/64)+1)*8,G=g.r,Q=(Math.floor((l.Ru.bitLength(G)-1)/64)+1)*8,L=l.Ru.mod(l.Ru.shl(1,8*Q),G),U=g.Fr.e(l.Ru.mod(l.Ru.mul(L,L),G));await m.writeULE32(E),await x(m,C,E),await m.writeULE32(Q),await x(m,G,Q),await m.writeULE32(d.nVars),await m.writeULE32(I),await m.writeULE32(b),n=await u.read(A,f[4][0].p),await m.write(n),n=await g.G1.batchLEMtoU(n),s.update(n),r=await u.read(A,f[5][0].p),await m.write(r),r=await g.G1.batchLEMtoU(r),s.update(r),o=await u.read(p,f[6][0].p),await m.write(o),o=await g.G2.batchLEMtoU(o),s.update(o);let T=new Uint8Array(A);g.G1.toRprLEM(T,0,g.G1.g);let z=new Uint8Array(p);g.G2.toRprLEM(z,0,g.G2.g);let P=new Uint8Array(A);g.G1.toRprUncompressed(P,0,g.G1.g);let D=new Uint8Array(p);g.G2.toRprUncompressed(D,0,g.G2.g),await m.write(z),await m.write(T),await m.write(z),s.update(D),s.update(P),s.update(D),await B(m),i&&i.info("Reading r1cs");let R=await _(w,c,2),k=new eK(d.nVars),O=new eK(d.nVars),M=new eK(d.nVars),V=new eK(d.nVars-I-1),q=Array(I+1);i&&i.info("Reading tauG1");let $=await _(u,f,12,(b-1)*A,b*A);i&&i.info("Reading tauG2");let H=await _(u,f,13,(b-1)*p,b*p);i&&i.info("Reading alphatauG1");let N=await _(u,f,14,(b-1)*A,b*A);i&&i.info("Reading betatauG1");let j=await _(u,f,15,(b-1)*A,b*A);await Z(),await X(3,"G1",q,"IC"),await Y(),await tt(),await X(8,"G1",V,"C"),await X(5,"G1",k,"A"),await X(6,"G1",O,"B1"),await X(7,"G2",M,"B2");let W=s.digest();return await F(m,10),await m.write(W),await m.writeULE32(0),await B(m),i&&i.info(tb(W,"Circuit hash: ")),await m.close(),await w.close(),await u.close(),W;async function Y(){await F(m,9);let t=new l.qc(b*A);if(y<g.Fr.s){let e=await _(u,f,12,(2*b-1)*A,2*b*A);for(let a=0;a<b;a++){i&&a%1e4==0&&i.debug(`splitting buffer: ${a}/${b}`);let n=e.slice((2*a+1)*A,(2*a+1)*A+A);t.set(n,a*A)}}else if(y==g.Fr.s){let e=f[12][0].p+(2**(y+1)-1)*A;await u.readToBuffer(t,0,b*A,e+b*A)}else throw i&&i.error("Circuit too big"),Error("Circuit too big for this curve");await m.write(t),await B(m)}async function Z(){let t=new Uint8Array(12+g.Fr.n8),e=new DataView(t.buffer),a=new Uint8Array(g.Fr.n8);g.Fr.toRprLE(a,0,g.Fr.e(1));let n=0;function r(){let t=R.slice(n,n+4);return n+=4,new DataView(t.buffer).getUint32(0,!0)}let o=new eK;for(let t=0;t<d.nConstraints;t++){i&&t%1e4==0&&i.debug(`processing constraints: ${t}/${d.nConstraints}`);let e=r();for(let a=0;a<e;a++){let e=r(),a=n;n+=g.Fr.n8;let i=A*t,l=A*t;void 0===k[e]&&(k[e]=[]),k[e].push([0,i,a]),e<=I?(void 0===q[e]&&(q[e]=[]),q[e].push([3,l,a])):(void 0===V[e-I-1]&&(V[e-I-1]=[]),V[e-I-1].push([3,l,a])),o.push([0,t,e,a])}let a=r();for(let e=0;e<a;e++){let e=r(),a=n;n+=g.Fr.n8;let i=A*t,l=p*t,s=A*t;void 0===O[e]&&(O[e]=[]),O[e].push([0,i,a]),void 0===M[e]&&(M[e]=[]),M[e].push([1,l,a]),e<=I?(void 0===q[e]&&(q[e]=[]),q[e].push([2,s,a])):(void 0===V[e-I-1]&&(V[e-I-1]=[]),V[e-I-1].push([2,s,a])),o.push([1,t,e,a])}let l=r();for(let e=0;e<l;e++){let e=r(),a=n;n+=g.Fr.n8;let i=A*t;e<=I?(void 0===q[e]&&(q[e]=[]),q[e].push([0,i,a])):(void 0===V[e-I-1]&&(V[e-I-1]=[]),V[e-I-1].push([0,i,a]))}}for(let t=0;t<=I;t++){let e=A*(d.nConstraints+t),a=A*(d.nConstraints+t);void 0===k[t]&&(k[t]=[]),k[t].push([0,e,-1]),void 0===q[t]&&(q[t]=[]),q[t].push([3,a,-1]),o.push([0,d.nConstraints+t,t,-1])}await F(m,4);let s=new l.qc(o.length*(12+g.Fr.n8)+4),u=new Uint8Array(4);new DataView(u.buffer).setUint32(0,o.length,!0),s.set(u);let f=4;for(let n=0;n<o.length;n++)i&&n%1e5==0&&i.debug(`writing coeffs: ${n}/${o.length}`),function(i){let n;e.setUint32(0,i[0],!0),e.setUint32(4,i[1],!0),e.setUint32(8,i[2],!0),n=i[3]>=0?g.Fr.fromRprLE(R.slice(i[3],i[3]+g.Fr.n8),0):g.Fr.fromRprLE(a,0);let r=g.Fr.mul(n,U);g.Fr.toRprLE(t,12,r),s.set(t,f),f+=t.length}(o[n]);await m.write(s),await B(m)}async function X(t,e,a,n){let r=g[e];ti(a.length),await F(m,t);let o=[],l=0;for(;l<a.length;){let t=0;for(;l<a.length&&t<g.tm.concurrency;){i&&i.debug(`Writing points start ${n}: ${l}/${a.length}`);let r=1,s=a[l]?a[l].length:0;for(;l+r<a.length&&s+(a[l+r]?a[l+r].length:0)<32768&&r<32768;)s+=a[l+r]?a[l+r].length:0,r++;let u=a.slice(l,l+r),f=l;o.push(J(e,u,i,n).then(t=>(i&&i.debug(`Writing points end ${n}: ${f}/${a.length}`),t))),l+=r,t++}let u=await Promise.all(o);for(let t=0;t<u.length;t++){await m.write(u[t][0]);let e=await r.batchLEMtoU(u[t][0]);s.update(e)}o=[]}await B(m)}async function J(t,e,a,i){let n,r,o,s,u,f;let h=g[t],w=2*h.F.n8,c=3*h.F.n8,d=2*h.F.n8;if("G1"==t)n="g1m_timesScalarAffine",r="g1m_multiexpAffine",o="g1m_batchToAffine",s="g1m_zero";else if("G2"==t)n="g2m_timesScalarAffine",r="g2m_multiexpAffine",o="g2m_batchToAffine",s="g2m_zero";else throw Error("Invalid group");let m=0;for(let t=0;t<e.length;t++)m+=e[t]?e[t].length:0;m>32768?(u=new l.qc(m*w),f=new l.qc(m*g.Fr.n8)):(u=new Uint8Array(m*w),f=new Uint8Array(m*g.Fr.n8));let A=0,p=0,y=[$,H,N,j],I=new Uint8Array(g.Fr.n8);g.Fr.toRprLE(I,0,g.Fr.e(1));let b=0;for(let t=0;t<e.length;t++)if(e[t])for(let n=0;n<e[t].length;n++)a&&n&&n%1e4==0&&a.debug(`Configuring big array ${i}: ${n}/${e[t].length}`),u.set(y[e[t][n][0]].slice(e[t][n][1],e[t][n][1]+w),b*w),e[t][n][2]>=0?f.set(R.slice(e[t][n][2],e[t][n][2]+g.Fr.n8),b*g.Fr.n8):f.set(I,b*g.Fr.n8),b++;if(e.length>1){let t=[];t.push({cmd:"ALLOCSET",var:0,buff:u}),t.push({cmd:"ALLOCSET",var:1,buff:f}),t.push({cmd:"ALLOC",var:2,len:e.length*c}),A=0,p=0;let a=0;for(let i=0;i<e.length;i++){if(!e[i]){t.push({cmd:"CALL",fnName:s,params:[{var:2,offset:a}]}),a+=c;continue}1==e[i].length?t.push({cmd:"CALL",fnName:n,params:[{var:0,offset:A},{var:1,offset:p},{val:g.Fr.n8},{var:2,offset:a}]}):t.push({cmd:"CALL",fnName:r,params:[{var:0,offset:A},{var:1,offset:p},{val:g.Fr.n8},{val:e[i].length},{var:2,offset:a}]}),A+=w*e[i].length,p+=g.Fr.n8*e[i].length,a+=c}return t.push({cmd:"CALL",fnName:o,params:[{var:2},{val:e.length},{var:2}]}),t.push({cmd:"GET",out:0,var:2,len:e.length*d}),await g.tm.queueAction(t)}{let t=await h.multiExpAffine(u,f,a,i);return[h.toAffine(t)]}}async function tt(){ti(b-1);for(let t=0;t<b-1;t+=16384){i&&i.debug(`HashingHPoints: ${t}/${b}`);let e=Math.min(b-1,16384);await te(t,e)}}async function te(t,e){let a=await u.read(e*A,f[2][0].p+(t+b)*A),i=await u.read(e*A,f[2][0].p+t*A),n=g.tm.concurrency,r=Math.floor(e/n),o=[];for(let t=0;t<n;t++){let l;if(0==(l=t<n-1?r:e-t*r))continue;let s=a.slice(t*r*A,(t*r+l)*A),u=i.slice(t*r*A,(t*r+l)*A);o.push(ta(s,u))}let l=await Promise.all(o);for(let t=0;t<l.length;t++)s.update(l[t][0])}async function ta(t,e){let a=t.byteLength/A,i=3*g.G1.F.n8,n=[];n.push({cmd:"ALLOCSET",var:0,buff:t}),n.push({cmd:"ALLOCSET",var:1,buff:e}),n.push({cmd:"ALLOC",var:2,len:a*i});for(let t=0;t<a;t++)n.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:t*A},{var:1,offset:t*A},{var:2,offset:t*i}]});return n.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"CALL",fnName:"g1m_batchLEMtoU",params:[{var:2},{val:a},{var:2}]}),n.push({cmd:"GET",out:0,var:2,len:a*A}),await g.tm.queueAction(n)}function ti(t){let e=new Uint8Array(4);new DataView(e.buffer,e.byteOffset,e.byteLength).setUint32(0,t,!1),s.update(e)}}async function eH(t,e,a){let i,n,r,o,l,s;let{fd:u,sections:f}=await S(t,"zkey",2),g=await tD(u,f);if("groth16"!=g.protocol)throw Error("zkey file is not groth16");let h=await O(g.q),w=2*h.G1.F.n8,c=2*h.G2.F.n8,d=await tq(u,h,f),m=await C(e);await p(g.vk_alpha_1),await p(g.vk_beta_1),await y(g.vk_beta_2),await y(g.vk_gamma_2),await p(g.vk_delta_1),await y(g.vk_delta_2),i=await _(u,f,3),i=await h.G1.batchLEMtoU(i),await I("G1",i);let A=await _(u,f,9);n=await h.G1.fft(A,"affine","jacobian",a),n=(n=await h.G1.batchApplyKey(n,h.Fr.neg(h.Fr.e(2)),h.Fr.w[g.power+1],"jacobian","affine",a)).slice(0,n.byteLength-w),n=await h.G1.batchLEMtoU(n),await I("G1",n),r=await _(u,f,8),r=await h.G1.batchLEMtoU(r),await I("G1",r),o=await _(u,f,5),o=await h.G1.batchLEMtoU(o),await I("G1",o),l=await _(u,f,6),l=await h.G1.batchLEMtoU(l),await I("G1",l),s=await _(u,f,7),s=await h.G2.batchLEMtoU(s),await I("G2",s),await m.write(d.csHash),await b(d.contributions.length);for(let t=0;t<d.contributions.length;t++){let e=d.contributions[t];await p(e.deltaAfter),await p(e.delta.g1_s),await p(e.delta.g1_sx),await y(e.delta.g2_spx),await m.write(e.transcript)}async function p(t){let e=new Uint8Array(w);h.G1.toRprUncompressed(e,0,t),await m.write(e)}async function y(t){let e=new Uint8Array(c);h.G2.toRprUncompressed(e,0,t),await m.write(e)}async function I(t,e){let a;a="G1"==t?w:c;let i=new Uint8Array(4);new DataView(i.buffer,i.byteOffset,i.byteLength).setUint32(0,e.byteLength/a,!1),await m.write(i),await m.write(e)}async function b(t){let e=new Uint8Array(4);new DataView(e.buffer,e.byteOffset,e.byteLength).setUint32(0,t,!1),await m.write(e)}await u.close(),await m.close()}async function eN(t,e,a,i,n){let r,o;let{fd:l,sections:s}=await S(t,"zkey",2),u=await tD(l,s,!1);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");let f=await O(u.q),g=2*f.G1.F.n8,h=2*f.G2.F.n8,w=await tq(l,f,s),c={},d=await E(e);d.pos=3*g+3*h+8+g*u.nVars+4+g*(u.domainSize-1)+4+g*u.nVars+4+g*u.nVars+4+h*u.nVars,c.csHash=await d.read(64);let m=await d.readUBE32();c.contributions=[];for(let t=0;t<m;t++){let e={delta:{}};e.deltaAfter=await Q(d),e.delta.g1_s=await Q(d),e.delta.g1_sx=await Q(d),e.delta.g2_spx=await x(d),e.transcript=await d.read(64),t<w.contributions.length&&(e.type=w.contributions[t].type,1==e.type&&(e.beaconHash=w.contributions[t].beaconHash,e.numIterationsExp=w.contributions[t].numIterationsExp),w.contributions[t].name&&(e.name=w.contributions[t].name)),c.contributions.push(e)}if(!tC(c.csHash,w.csHash))return n&&n.error("Hash of the original circuit does not match with the MPC one"),!1;if(w.contributions.length>c.contributions.length)return n&&n.error("The impoerted file does not include new contributions"),!1;for(let t=0;t<w.contributions.length;t++){var A,p;if(A=w.contributions[t],p=c.contributions[t],!(f.G1.eq(A.deltaAfter,p.deltaAfter)&&f.G1.eq(A.delta.g1_s,p.delta.g1_s)&&f.G1.eq(A.delta.g1_sx,p.delta.g1_sx)&&f.G2.eq(A.delta.g2_spx,p.delta.g2_spx)&&tC(A.transcript,p.transcript)))return n&&n.error(`Previous contribution ${t} does not match`),!1}if(i)for(let t=w.contributions.length;t<c.contributions.length;t++)c.contributions[t].name=i;let y=await v(a,"zkey",1,10);if(d.pos=0,d.pos+=g,d.pos+=g,d.pos+=h,d.pos+=h,u.vk_delta_1=await Q(d),u.vk_delta_2=await x(d),await tU(y,u),await d.readUBE32()!=u.nPublic+1)return n&&n.error("Invalid number of points in IC"),await y.discard(),!1;if(d.pos+=g*(u.nPublic+1),await U(l,s,y,3),await U(l,s,y,4),await d.readUBE32()!=u.domainSize-1)return n&&n.error("Invalid number of points in H"),await y.discard(),!1;let I=await d.read(g*(u.domainSize-1)),b=await f.G1.batchUtoLEM(I);(r=new Uint8Array(u.domainSize*g)).set(b),f.G1.toRprLEM(r,g*(u.domainSize-1),f.G1.zeroAffine);let C=f.Fr.neg(f.Fr.inv(f.Fr.e(2))),G=f.Fr.inv(f.Fr.w[u.power+1]);if(r=await f.G1.batchApplyKey(r,C,G,"affine","jacobian",n),r=await f.G1.ifft(r,"jacobian","affine",n),await F(y,9),await y.write(r),await B(y),await d.readUBE32()!=u.nVars-u.nPublic-1)return n&&n.error("Invalid number of points in L"),await y.discard(),!1;if(o=await d.read(g*(u.nVars-u.nPublic-1)),o=await f.G1.batchUtoLEM(o),await F(y,8),await y.write(o),await B(y),await d.readUBE32()!=u.nVars)return n&&n.error("Invalid number of points in A"),await y.discard(),!1;if(d.pos+=g*u.nVars,await U(l,s,y,5),await d.readUBE32()!=u.nVars)return n&&n.error("Invalid number of points in B1"),await y.discard(),!1;if(d.pos+=g*u.nVars,await U(l,s,y,6),await d.readUBE32()!=u.nVars)return n&&n.error("Invalid number of points in B2"),await y.discard(),!1;return d.pos+=h*u.nVars,await U(l,s,y,7),await t$(y,f,c),await d.close(),await y.close(),await l.close(),!0;async function Q(t){let e=await t.read(2*f.G1.F.n8);return f.G1.fromRprUncompressed(e,0)}async function x(t){let e=await t.read(2*f.G2.F.n8);return f.G2.fromRprUncompressed(e,0)}}async function ej(t,e,a,i){await K.exports.ready();let{fd:n,sections:r}=await S(a,"zkey",2),o=await tD(n,r,!1);if("groth16"!=o.protocol)throw Error("zkey file is not groth16");let s=await O(o.q),u=2*s.G1.F.n8,f=await tq(n,s,r),g=K.exports(64);g.update(f.csHash);let h=s.G1.g;for(let t=0;t<f.contributions.length;t++){let e=f.contributions[t],a=function(t){let e=t.getPartialHash(),a=K.exports(64);return a.setPartialHash(e),a}(g);if(tH(a,s,e.delta.g1_s),tH(a,s,e.delta.g1_sx),!tC(a.digest(),e.transcript))return console.log(`INVALID(${t}): Inconsistent transcript `),!1;let i=eo(s,e.transcript);if(!0!==await tE(s,e.delta.g1_s,e.delta.g1_sx,i,e.delta.g2_spx))return console.log(`INVALID(${t}): public key G1 and G2 do not have the same ration `),!1;if(!0!==await tE(s,h,e.deltaAfter,i,e.delta.g2_spx))return console.log(`INVALID(${t}): deltaAfter does not fillow the public key `),!1;if(1==e.type){let a=await tG(e.beaconHash,e.numIterationsExp),i=s.Fr.fromRng(a),n=s.G1.toAffine(s.G1.fromRng(a)),r=s.G1.toAffine(s.G1.timesFr(n,i));if(!0!==s.G1.eq(n,e.delta.g1_s))return console.log(`INVALID(${t}): Key of the beacon does not match. g1_s `),!1;if(!0!==s.G1.eq(r,e.delta.g1_sx))return console.log(`INVALID(${t}): Key of the beacon does not match. g1_sx `),!1}tN(g,s,e);let n=K.exports(64);tN(n,s,e),e.contributionHash=n.digest(),h=e.deltaAfter}let{fd:w,sections:c}=await S(t,"zkey",2),d=await tD(w,c,!1);if("groth16"!=d.protocol)throw Error("zkeyinit file is not groth16");if(!l.Ru.eq(d.q,o.q)||!l.Ru.eq(d.r,o.r)||d.n8q!=o.n8q||d.n8r!=o.n8r)return i&&i.error("INVALID:  Different curves"),!1;if(d.nVars!=o.nVars||d.nPublic!=o.nPublic||d.domainSize!=o.domainSize)return i&&i.error("INVALID:  Different circuit parameters"),!1;if(!s.G1.eq(o.vk_alpha_1,d.vk_alpha_1))return i&&i.error("INVALID:  Invalid alpha1"),!1;if(!s.G1.eq(o.vk_beta_1,d.vk_beta_1))return i&&i.error("INVALID:  Invalid beta1"),!1;if(!s.G2.eq(o.vk_beta_2,d.vk_beta_2))return i&&i.error("INVALID:  Invalid beta2"),!1;if(!s.G2.eq(o.vk_gamma_2,d.vk_gamma_2))return i&&i.error("INVALID:  Invalid gamma2"),!1;if(!s.G1.eq(o.vk_delta_1,h))return i&&i.error("INVALID:  Invalid delta1"),!1;if(!0!==await tE(s,s.G1.g,h,s.G2.g,o.vk_delta_2))return i&&i.error("INVALID:  Invalid delta2"),!1;let m=await tq(w,s,c);if(!tC(f.csHash,m.csHash))return i&&i.error("INVALID:  Circuit does not match"),!1;if(r[8][0].size!=u*(o.nVars-o.nPublic-1))return i&&i.error("INVALID:  Invalid L section size"),!1;if(r[9][0].size!=u*o.domainSize)return i&&i.error("INVALID:  Invalid H section size"),!1;if(!await T(n,r,w,c,3))return i&&i.error("INVALID:  IC section is not identical"),!1;if(!await T(n,r,w,c,4))return i&&i.error("Coeffs section is not identical"),!1;if(!await T(n,r,w,c,5))return i&&i.error("A section is not identical"),!1;if(!await T(n,r,w,c,6))return i&&i.error("B1 section is not identical"),!1;if(!await T(n,r,w,c,7))return i&&i.error("B2 section is not identical"),!1;if(!0!==await A("G1",w,c,n,r,8,o.vk_delta_2,d.vk_delta_2,"L section"))return i&&i.error("L section does not match"),!1;if(!0!==await p())return i&&i.error("H section does not match"),!1;i&&i.info(tb(f.csHash,"Circuit Hash: ")),await n.close(),await w.close();for(let t=f.contributions.length-1;t>=0;t--){let e=f.contributions[t];i&&i.info("-------------------------"),i&&i.info(tb(e.contributionHash,`contribution #${t+1} ${e.name?e.name:""}:`)),1==e.type&&(i&&i.info(`Beacon generator: ${tx(e.beaconHash)}`),i&&i.info(`Beacon iterations Exp: ${e.numIterationsExp}`))}return i&&i.info("-------------------------"),i&&i.info("ZKey Ok!"),!0;async function A(t,e,a,n,r,o,l,u,f){let g=s[t],h=2*g.F.n8;await G(e,a,o),await G(n,r,o);let w=g.zero,c=g.zero,d=a[o][0].size/h;for(let t=0;t<d;t+=1048576){i&&i.debug(`Same ratio check ${f}:  ${t}/${d}`);let a=Math.min(d-t,1048576),r=await e.read(a*h),o=await n.read(a*h),l=tS(4*a),s=await g.multiExpAffine(r,l),u=await g.multiExpAffine(o,l);w=g.add(w,s),c=g.add(c,u)}return await Q(e),await Q(n),0==d||!0===await tE(s,w,c,l,u)}async function p(){let t;let a=s.G1,u=s.Fr,f=2*a.F.n8,{fd:g,sections:h}=await S(e,"ptau",1),w=new l.qc(o.domainSize*o.n8r),c=Array(8);for(let t=0;t<8;t++)c[t]=tF(tS(4),0);let m=new l.XY(c);for(let t=0;t<o.domainSize-1;t++){let e=u.fromRng(m);u.toRprLE(w,t*o.n8r,e)}u.toRprLE(w,(o.domainSize-1)*o.n8r,u.zero);let A=a.zero;for(let t=0;t<o.domainSize;t+=1048576){i&&i.debug(`H Verification(tau):  ${t}/${o.domainSize}`);let e=Math.min(o.domainSize-t,1048576),n=await g.read(f*e,h[2][0].p+o.domainSize*f+t*f),r=await g.read(f*e,h[2][0].p+t*f),l=await y(n,r),s=w.slice(t*o.n8r,(t+e)*o.n8r),u=await a.multiExpAffine(l,s);A=a.add(A,u)}if(w=await u.batchToMontgomery(w),o.power<u.s)t=u.neg(u.e(2));else{let e=2**u.s,a=u.exp(u.shift,e);t=u.sub(a,u.one)}let p=o.power<u.s?u.w[o.power+1]:u.shift;w=await u.batchApplyKey(w,t,p),w=await u.fft(w),w=await u.batchFromMontgomery(w),await G(n,r,9);let I=a.zero;for(let t=0;t<o.domainSize;t+=1048576){i&&i.debug(`H Verification(lagrange):  ${t}/${o.domainSize}`);let e=Math.min(o.domainSize-t,1048576),r=await n.read(f*e),l=w.slice(t*o.n8r,(t+e)*o.n8r),s=await a.multiExpAffine(r,l);I=a.add(I,s)}return await Q(n),!0===await tE(s,A,I,o.vk_delta_2,d.vk_delta_2)}async function y(t,e){let a=2*s.G1.F.n8,i=t.byteLength/a,n=s.tm.concurrency,r=Math.floor(i/n),o=[];for(let a=0;a<n;a++){let l;if(0==(l=a<n-1?r:i-a*r))continue;let s=t.slice(a*r*u,(a*r+l)*u),f=e.slice(a*r*u,(a*r+l)*u);o.push(I(s,f))}let l=await Promise.all(o),f=new Uint8Array(i*a),g=0;for(let t=0;t<l.length;t++)f.set(l[t][0],g),g+=l[t][0].byteLength;return f}async function I(t,e){let a=2*s.G1.F.n8,i=3*s.G1.F.n8,n=t.byteLength/a,r=[];r.push({cmd:"ALLOCSET",var:0,buff:t}),r.push({cmd:"ALLOCSET",var:1,buff:e}),r.push({cmd:"ALLOC",var:2,len:n*i});for(let t=0;t<n;t++)r.push({cmd:"CALL",fnName:"g1m_subAffine",params:[{var:0,offset:t*a},{var:1,offset:t*a},{var:2,offset:t*i}]});return r.push({cmd:"CALL",fnName:"g1m_batchToAffine",params:[{var:2},{val:n},{var:2}]}),r.push({cmd:"GET",out:0,var:2,len:n*a}),await s.tm.queueAction(r)}}async function eW(t,e,a,i){let n={type:"bigMem"};return await e$(t,e,n,i),await ej(n,e,a,i)}async function eY(t,e,a,i,n){await K.exports.ready();let{fd:r,sections:o}=await S(t,"zkey",2),l=await tD(r,o);if("groth16"!=l.protocol)throw Error("zkey file is not groth16");let s=await O(l.q),u=await tq(r,s,o),f=await v(e,"zkey",1,10),g=await tB(i),h=K.exports(64);h.update(u.csHash);for(let t=0;t<u.contributions.length;t++)tN(h,s,u.contributions[t]);let w={};w.delta={},w.delta.prvKey=s.Fr.fromRng(g),w.delta.g1_s=s.G1.toAffine(s.G1.fromRng(g)),w.delta.g1_sx=s.G1.toAffine(s.G1.timesFr(w.delta.g1_s,w.delta.prvKey)),tH(h,s,w.delta.g1_s),tH(h,s,w.delta.g1_sx),w.transcript=h.digest(),w.delta.g2_sp=eo(s,w.transcript),w.delta.g2_spx=s.G2.toAffine(s.G2.timesFr(w.delta.g2_sp,w.delta.prvKey)),l.vk_delta_1=s.G1.timesFr(l.vk_delta_1,w.delta.prvKey),l.vk_delta_2=s.G2.timesFr(l.vk_delta_2,w.delta.prvKey),w.deltaAfter=l.vk_delta_1,w.type=0,a&&(w.name=a),u.contributions.push(w),await tU(f,l),await U(r,o,f,3),await U(r,o,f,4),await U(r,o,f,5),await U(r,o,f,6),await U(r,o,f,7);let c=s.Fr.inv(w.delta.prvKey);await eE(r,o,f,8,s,"G1",c,s.Fr.e(1),"L Section",n),await eE(r,o,f,9,s,"G1",c,s.Fr.e(1),"H Section",n),await t$(f,s,u),await r.close(),await f.close();let d=K.exports(64);tN(d,s,w);let m=d.digest();return n&&n.info(tb(u.csHash,"Circuit Hash: ")),n&&n.info(tb(m,"Contribution Hash: ")),m}async function eZ(t,e,a,i,n,r){await K.exports.ready();let o=tQ(i);if(0==o.byteLength||2*o.byteLength!=i.length)return r&&r.error("Invalid Beacon Hash. (It must be a valid hexadecimal sequence)"),!1;if(o.length>=256)return r&&r.error("Maximum length of beacon hash is 255 bytes"),!1;if((n=parseInt(n))<10||n>63)return r&&r.error("Invalid numIterationsExp. (Must be between 10 and 63)"),!1;let{fd:l,sections:s}=await S(t,"zkey",2),u=await tD(l,s);if("groth16"!=u.protocol)throw Error("zkey file is not groth16");let f=await O(u.q),g=await tq(l,f,s),h=await v(e,"zkey",1,10),w=await tG(o,n),c=K.exports(64);c.update(g.csHash);for(let t=0;t<g.contributions.length;t++)tN(c,f,g.contributions[t]);let d={};d.delta={},d.delta.prvKey=f.Fr.fromRng(w),d.delta.g1_s=f.G1.toAffine(f.G1.fromRng(w)),d.delta.g1_sx=f.G1.toAffine(f.G1.timesFr(d.delta.g1_s,d.delta.prvKey)),tH(c,f,d.delta.g1_s),tH(c,f,d.delta.g1_sx),d.transcript=c.digest(),d.delta.g2_sp=eo(f,d.transcript),d.delta.g2_spx=f.G2.toAffine(f.G2.timesFr(d.delta.g2_sp,d.delta.prvKey)),u.vk_delta_1=f.G1.timesFr(u.vk_delta_1,d.delta.prvKey),u.vk_delta_2=f.G2.timesFr(u.vk_delta_2,d.delta.prvKey),d.deltaAfter=u.vk_delta_1,d.type=1,d.numIterationsExp=n,d.beaconHash=o,a&&(d.name=a),g.contributions.push(d),await tU(h,u),await U(l,s,h,3),await U(l,s,h,4),await U(l,s,h,5),await U(l,s,h,6),await U(l,s,h,7);let m=f.Fr.inv(d.delta.prvKey);await eE(l,s,h,8,f,"G1",m,f.Fr.e(1),"L Section",r),await eE(l,s,h,9,f,"G1",m,f.Fr.e(1),"H Section",r),await t$(h,f,g),await l.close(),await h.close();let A=K.exports(64);tN(A,f,d);let p=A.digest();return r&&r.info(tb(p,"Contribution Hash: ")),p}async function eX(t){let e=await tM(t,!0);return delete e.curve,delete e.F,l.utils.stringifyBigInts(e)}async function eJ(t,e,a,i,n){await K.exports.ready();let r=await tB(i),o=t.Fr.fromRng(r),l=t.Fr.inv(o),s=2*t.G1.F.n8,u=2*t.G2.F.n8,f=await E(e),g=await C(a);await x(s),await x(s),await x(u),await x(u);let h=await L(),w=t.G1.timesFr(h,o);await _(w);let c=await U(),d=t.G2.timesFr(c,o);await T(d);let m=await f.readUBE32();await g.writeUBE32(m),await x(m*s);let A=await f.readUBE32();await g.writeUBE32(A),await eS(f,g,null,t,"G1",A,l,t.Fr.e(1),"UNCOMPRESSED","H",n);let p=await f.readUBE32();await g.writeUBE32(p),await eS(f,g,null,t,"G1",p,l,t.Fr.e(1),"UNCOMPRESSED","L",n);let y=await f.readUBE32();await g.writeUBE32(y),await x(y*s);let I=await f.readUBE32();await g.writeUBE32(I),await x(I*s);let b=await f.readUBE32();await g.writeUBE32(b),await x(b*u);let S=K.exports(64),v={};v.csHash=await f.read(64),S.update(v.csHash);let F=await f.readUBE32();v.contributions=[];for(let e=0;e<F;e++){let e={delta:{}};e.deltaAfter=await L(),e.delta.g1_s=await L(),e.delta.g1_sx=await L(),e.delta.g2_spx=await U(),e.transcript=await f.read(64),v.contributions.push(e),tN(S,t,e)}let B={};B.delta={},B.delta.prvKey=o,B.delta.g1_s=t.G1.toAffine(t.G1.fromRng(r)),B.delta.g1_sx=t.G1.toAffine(t.G1.timesFr(B.delta.g1_s,o)),tH(S,t,B.delta.g1_s),tH(S,t,B.delta.g1_sx),B.transcript=S.digest(),B.delta.g2_sp=eo(t,B.transcript),B.delta.g2_spx=t.G2.toAffine(t.G2.timesFr(B.delta.g2_sp,o)),B.deltaAfter=w,B.type=0,v.contributions.push(B),await g.write(v.csHash),await g.writeUBE32(v.contributions.length);for(let t=0;t<v.contributions.length;t++){let e=v.contributions[t];await _(e.deltaAfter),await _(e.delta.g1_s),await _(e.delta.g1_sx),await T(e.delta.g2_spx),await g.write(e.transcript)}let G=K.exports(64);tN(G,t,B);let Q=G.digest();return n&&n.info(tb(Q,"Contribution Hash: ")),await g.close(),await f.close(),Q;async function x(t){let e=2*f.pageSize;for(let a=0;a<t;a+=e){let i=Math.min(t-a,e),n=await f.read(i);await g.write(n)}}async function L(){let e=await f.read(2*t.G1.F.n8);return t.G1.fromRprUncompressed(e,0)}async function U(){let e=await f.read(2*t.G2.F.n8);return t.G2.fromRprUncompressed(e,0)}async function _(e){let a=new Uint8Array(s);t.G1.toRprUncompressed(a,0,e),await g.write(a)}async function T(e){let a=new Uint8Array(u);t.G2.toRprUncompressed(a,0,e),await g.write(a)}}let{stringifyBigInts:e1}=l.utils;async function e2(t,e){let a;e&&e.info("EXPORT VERIFICATION KEY STARTED");let{fd:i,sections:n}=await S(t,"zkey",2),r=await tD(i,n);if(e&&e.info("> Detected protocol: "+r.protocol),"groth16"===r.protocol)a=await e0(r,i,n);else if("plonk"===r.protocol)a=await e8(r);else if(r.protocolId&&10===r.protocolId)a=await e3(r);else throw Error("zkey file protocol unrecognized");return await i.close(),e&&e.info("EXPORT VERIFICATION KEY FINISHED"),a}async function e0(t,e,a){let i=await O(t.q),n=2*i.G1.F.n8,r=await i.pairing(t.vk_alpha_1,t.vk_beta_2),o={protocol:t.protocol,curve:i.name,nPublic:t.nPublic,vk_alpha_1:i.G1.toObject(t.vk_alpha_1),vk_beta_2:i.G2.toObject(t.vk_beta_2),vk_gamma_2:i.G2.toObject(t.vk_gamma_2),vk_delta_2:i.G2.toObject(t.vk_delta_2),vk_alphabeta_12:i.Gt.toObject(r)};await G(e,a,3),o.IC=[];for(let a=0;a<=t.nPublic;a++){let t=await e.read(n),a=i.G1.toObject(t);o.IC.push(a)}return await Q(e),o=e1(o)}async function e8(t){let e=await O(t.q);return e1({protocol:t.protocol,curve:e.name,nPublic:t.nPublic,power:t.power,k1:e.Fr.toObject(t.k1),k2:e.Fr.toObject(t.k2),Qm:e.G1.toObject(t.Qm),Ql:e.G1.toObject(t.Ql),Qr:e.G1.toObject(t.Qr),Qo:e.G1.toObject(t.Qo),Qc:e.G1.toObject(t.Qc),S1:e.G1.toObject(t.S1),S2:e.G1.toObject(t.S2),S3:e.G1.toObject(t.S3),X_2:e.G2.toObject(t.X_2),w:e.Fr.toObject(e.Fr.w[t.power])})}async function e3(t,e){let a=await O(t.q);return e1({protocol:t.protocol,curve:a.name,nPublic:t.nPublic,power:t.power,k1:a.Fr.toObject(t.k1),k2:a.Fr.toObject(t.k2),w:a.Fr.toObject(a.Fr.w[t.power]),w3:a.Fr.toObject(t.w3),w4:a.Fr.toObject(t.w4),w8:a.Fr.toObject(t.w8),wr:a.Fr.toObject(t.wr),X_2:a.G2.toObject(t.X_2),C0:a.G1.toObject(t.C0)})}var e4={};let{unstringifyBigInts:e6,stringifyBigInts:e5}=l.utils;async function e7(t,e,a){a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER STARTED");let i=await M(t.curve),n=u(t.w3);t.w3_2=f(i.Fr.square(n));let r=u(t.w4);t.w4_2=f(i.Fr.square(r)),t.w4_3=f(i.Fr.mul(i.Fr.square(r),r));let o=u(t.w8),l=i.Fr.one;for(let e=1;e<8;e++)l=i.Fr.mul(l,o),t["w8_"+e]=f(l);let s=e[t.protocol];return a&&a.info("FFLONK EXPORT SOLIDITY VERIFIER FINISHED"),e4.render(s,t);function u(t){let e=e6(t);return i.Fr.fromObject(e)}function f(t){return e5(i.Fr.toObject(t))}}async function e9(t,e,a){let i=await e2(t,a);if("fflonk"===i.protocol)return e7(i,e,a);let n=e[i.protocol];return e4.render(n,i)}var at=Object.freeze({__proto__:null,newZKey:e$,exportBellman:eH,importBellman:eN,verifyFromR1cs:eW,verifyFromInit:ej,contribute:eY,beacon:eZ,exportJson:eX,bellmanContribute:eJ,exportVerificationKey:e2,exportSolidityVerifier:e9});async function ae(t,e,a,i){globalThis.gc&&globalThis.gc(),await K.exports.ready();let{fd:n,sections:r}=await S(e,"ptau",1),{curve:o,power:s}=await eg(n,r),{fd:u,sections:f}=await S(t,"r1cs",1),g=await eU(u,f,{loadConstraints:!0,loadCustomGates:!0}),h=2*o.G1.F.n8,w=o.G1,c=2*o.G2.F.n8,d=o.Fr,m=o.Fr.n8;i&&i.info("Reading r1cs"),await _(u,f,2);let A=new eK,p=new eK,y=g.nVars,I=g.nOutputs+g.nPubInputs;await P(o.Fr,g,i),globalThis.gc&&globalThis.gc();let b=await v(a,"zkey",1,14,4194304,16777216);if(g.prime!=o.r)return i&&i.error("r1cs curve does not match powers of tau ceremony curve"),-1;let C=tI(A.length-1)+1;C<3&&(C=3);let E=2**C;if(i&&i.info("Plonk constraints: "+A.length),C>s)return i&&i.error(`circuit too big for this power of tau ceremony. ${A.length} > 2**${s}`),-1;if(!r[12])return i&&i.error("Powers of tau is not prepared."),-1;let G=new l.qc(E*h),Q=r[12][0].p+(2**C-1)*h;await n.readToBuffer(G,0,E*h,Q);let[L,U]=function(){let t=d.two;for(;a(t,[],C);)d.add(t,d.one);let e=d.add(t,d.one);for(;a(e,[t],C);)d.add(e,d.one);return[t,e];function a(t,e,a){let i=2**a,n=d.one;for(let r=0;r<i;r++){if(d.eq(t,n))return!0;for(let a=0;a<e.length;a++)if(d.eq(t,d.mul(e[a],n)))return!0;n=d.mul(n,d.w[a])}return!1}}(),T={};await O(3,"Additions"),globalThis.gc&&globalThis.gc(),await D(4,0,"Amap"),globalThis.gc&&globalThis.gc(),await D(5,1,"Bmap"),globalThis.gc&&globalThis.gc(),await D(6,2,"Cmap"),globalThis.gc&&globalThis.gc(),await R(7,3,"Qm"),globalThis.gc&&globalThis.gc(),await R(8,4,"Ql"),globalThis.gc&&globalThis.gc(),await R(9,5,"Qr"),globalThis.gc&&globalThis.gc(),await R(10,6,"Qo"),globalThis.gc&&globalThis.gc(),await R(11,7,"Qc"),globalThis.gc&&globalThis.gc(),await M(12,"sigma"),globalThis.gc&&globalThis.gc(),await V(13,"lagrange polynomials"),globalThis.gc&&globalThis.gc(),await F(b,14);let z=new l.qc((E+6)*h);async function P(t,e,a){function i(t){let e=Object.keys(t);for(let a=0;a<e.length;a++)0n==t[e[a]]&&delete t[e[a]]}function n(e,a,n){let r={};for(let i in e)void 0===r[i]?r[i]=t.mul(a,e[i]):r[i]=t.add(r[i],t.mul(a,e[i]));for(let e in n)void 0===r[e]?r[e]=n[e]:r[e]=t.add(r[e],n[e]);return i(r),r}function r(e,a){let i={k:t.zero,s:[],coefs:[]},n=[];for(let a in e)0==a?i.k=t.add(i.k,e[a]):0n!=e[a]&&n.push([Number(a),e[a]]);for(;n.length>a;){let e=n.shift(),a=n.shift(),i=e[0],r=a[0],o=y++,l=t.zero,s=t.neg(e[1]),u=t.neg(a[1]),f=t.one,g=t.zero;A.push([i,r,o,l,s,u,f,g]),p.push([i,r,e[1],a[1]]),n.push([o,t.one])}for(let t=0;t<n.length;t++)i.s[t]=n[t][0],i.coefs[t]=n[t][1];for(;i.coefs.length<a;)i.s.push(0),i.coefs.push(t.zero);return i}function o(e){let a=r(e,3),i=a.s[0],n=a.s[1],o=a.s[2],l=t.zero,s=a.coefs[0],u=a.coefs[1],f=a.coefs[2],g=a.k;A.push([i,n,o,l,s,u,f,g])}function l(e){let a=t.zero,i=0,n=Object.keys(e);for(let r=0;r<n.length;r++)0n==e[n[r]]?delete e[n[r]]:0==n[r]?a=t.add(a,e[n[r]]):i++;return i>0?i.toString():a!=t.zero?"k":"0"}for(let e=1;e<=I;e++){let a=e,i=t.zero,n=t.one,r=t.zero,o=t.zero,l=t.zero;A.push([a,0,0,i,n,r,o,l])}for(let s=0;s<e.constraints.length;s++)a&&s%1e4==0&&a.debug(`processing constraints: ${s}/${e.nConstraints}`),function(e,a,s){let u=l(e),f=l(a);"0"===u||"0"===f?(i(s),o(s)):"k"===u?o(n(a,e[0],s)):"k"===f?o(n(e,a[0],s)):function(e,a,i){let n=r(e,1),o=r(a,1),l=r(i,1),s=n.s[0],u=o.s[0],f=l.s[0],g=t.mul(n.coefs[0],o.coefs[0]),h=t.mul(n.coefs[0],o.k),w=t.mul(n.k,o.coefs[0]),c=t.neg(l.coefs[0]),d=t.sub(t.mul(n.k,o.k),l.k);A.push([s,u,f,g,h,w,c,d])}(e,a,s)}(...e.constraints[s])}async function D(t,e,a){await F(b,t);for(let t=0;t<A.length;t++)await b.writeULE32(A[t][e]),i&&t%1e6==0&&i.debug(`writing ${a}: ${t}/${A.length}`);await B(b)}async function R(t,e,a){let n=new l.qc(E*m);for(let t=0;t<A.length;t++)n.set(A[t][e],t*m),i&&t%1e6==0&&i.debug(`writing ${a}: ${t}/${A.length}`);await F(b,t),await k(n),await B(b),n=await d.batchFromMontgomery(n),T[a]=await o.G1.multiExpAffine(G,n,i,"multiexp "+a)}async function k(t){let e=await d.ifft(t),a=new l.qc(E*m*4);a.set(e,0);let i=await d.fft(a);await b.write(e),await b.write(i)}async function O(t,e){await F(b,t);let a=new Uint8Array(8+2*m),n=new DataView(a.buffer);for(let t=0;t<p.length;t++){let r=p[t],o=0;n.setUint32(o,r[0],!0),o+=4,n.setUint32(o,r[1],!0),o+=4,a.set(r[2],o),o+=m,a.set(r[3],o),o+=m,await b.write(a),i&&t%1e6==0&&i.debug(`writing ${e}: ${t}/${p.length}`)}await B(b)}async function M(t,e){let a=new l.qc(m*E*3),n=new eK(y),r=new eK(y),s=d.one;for(let t=0;t<E;t++)t<A.length?(h(A[t][0],t),h(A[t][1],E+t),h(A[t][2],2*E+t)):(h(0,t),h(0,E+t),h(0,2*E+t)),s=d.mul(s,d.w[C]),i&&t%1e6==0&&i.debug(`writing ${e} phase1: ${t}/${A.length}`);for(let t=0;t<y;t++)void 0!==r[t]?a.set(n[t],r[t]*m):console.log("Variable not used"),i&&t%1e6==0&&i.debug(`writing ${e} phase2: ${t}/${y}`);globalThis.gc&&globalThis.gc(),await F(b,t);let u=a.slice(0,E*m);await k(u),globalThis.gc&&globalThis.gc();let f=a.slice(E*m,E*m*2);await k(f),globalThis.gc&&globalThis.gc();let g=a.slice(E*m*2,E*m*3);function h(t,e){let i;void 0===n[t]?r[t]=e:a.set(n[t],e*m),i=e<E?s:e<2*E?d.mul(s,L):d.mul(s,U),n[t]=i}await k(g),globalThis.gc&&globalThis.gc(),await B(b),u=await d.batchFromMontgomery(u),f=await d.batchFromMontgomery(f),g=await d.batchFromMontgomery(g),T.S1=await o.G1.multiExpAffine(G,u,i,"multiexp S1"),globalThis.gc&&globalThis.gc(),T.S2=await o.G1.multiExpAffine(G,f,i,"multiexp S2"),globalThis.gc&&globalThis.gc(),T.S3=await o.G1.multiExpAffine(G,g,i,"multiexp S3"),globalThis.gc&&globalThis.gc()}async function V(t,e){await F(b,t);let a=Math.max(I,1);for(let t=0;t<a;t++){let n=new l.qc(E*m);n.set(d.one,t*m),await k(n),i&&i.debug(`writing ${e} ${t}/${a}`)}await B(b)}async function q(){let t;await F(b,1),await b.writeULE32(2),await B(b),await F(b,2);let e=o.q,a=(Math.floor((l.Ru.bitLength(e)-1)/64)+1)*8,i=o.r,s=(Math.floor((l.Ru.bitLength(i)-1)/64)+1)*8;await b.writeULE32(a),await x(b,e,a),await b.writeULE32(s),await x(b,i,s),await b.writeULE32(y),await b.writeULE32(I),await b.writeULE32(E),await b.writeULE32(p.length),await b.writeULE32(A.length),await b.write(L),await b.write(U),await b.write(w.toAffine(T.Qm)),await b.write(w.toAffine(T.Ql)),await b.write(w.toAffine(T.Qr)),await b.write(w.toAffine(T.Qo)),await b.write(w.toAffine(T.Qc)),await b.write(w.toAffine(T.S1)),await b.write(w.toAffine(T.S2)),await b.write(w.toAffine(T.S3)),t=await n.read(c,r[3][0].p+c),await b.write(t),await B(b)}await n.readToBuffer(z,0,(E+6)*h,r[2][0].p),await b.write(z),await B(b),globalThis.gc&&globalThis.gc(),await q(),await b.close(),await u.close(),await n.close(),i&&i.info("Setup Finished")}class aa{constructor(t,e){this.curve=t,this.logger=e,this.resetProof()}resetProof(){this.polynomials={},this.evaluations={}}addPolynomial(t,e){t in this.polynomials&&this.logger.warn(`proof: polynomial.${t} already exist in proof`),this.polynomials[t]=e}getPolynomial(t){return t in this.polynomials||this.logger.warn(`proof: polynomial ${t} does not exist in proof`),this.polynomials[t]}addEvaluation(t,e){t in this.evaluations&&this.logger.warn(`proof: evaluations.${t} already exist in proof`),this.evaluations[t]=e}getEvaluation(t){return t in this.evaluations||this.logger.warn(`proof: evaluation ${t} does not exist in proof`),this.evaluations[t]}toObjectProof(t=!0){let e=t?{polynomials:{},evaluations:{}}:{};return Object.keys(this.polynomials).forEach(a=>{let i=this.curve.G1.toObject(this.polynomials[a]);t?e.polynomials[a]=i:e[a]=i}),Object.keys(this.evaluations).forEach(a=>{let i=this.curve.Fr.toObject(this.evaluations[a]);t?e.evaluations[a]=i:e[a]=i}),e}fromObjectProof(t){this.resetProof(),Object.keys(t.polynomials).forEach(e=>{this.polynomials[e]=this.curve.G1.fromObject(t.polynomials[e])}),Object.keys(t.evaluations).forEach(e=>{this.evaluations[e]=this.curve.Fr.fromObject(t.evaluations[e])})}}var ai={exports:{}};!function(){var t="input is invalid type",e="object"==typeof window,a=e?window:{};a.JS_SHA3_NO_WINDOW&&(e=!1);var i=!e&&"object"==typeof self;!a.JS_SHA3_NO_NODE_JS&&"object"==typeof s&&s.versions&&s.versions.node?a=q:i&&(a=self);var n=!a.JS_SHA3_NO_COMMON_JS&&ai.exports,r=!a.JS_SHA3_NO_ARRAY_BUFFER&&"undefined"!=typeof ArrayBuffer,o="0123456789abcdef".split(""),l=[4,1024,262144,67108864],u=[0,8,16,24],f=[1,0,32898,0,32906,2147483648,2147516416,2147483648,32907,0,2147483649,0,2147516545,2147483648,32777,2147483648,138,0,136,0,2147516425,0,2147483658,0,2147516555,0,139,2147483648,32905,2147483648,32771,2147483648,32770,2147483648,128,2147483648,32778,0,2147483658,2147483648,2147516545,2147483648,32896,2147483648,2147483649,0,2147516424,2147483648],g=[224,256,384,512],h=[128,256],w=["hex","buffer","arrayBuffer","array","digest"],c={128:168,256:136};(a.JS_SHA3_NO_NODE_JS||!Array.isArray)&&(Array.isArray=function(t){return"[object Array]"===Object.prototype.toString.call(t)}),r&&(a.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW||!ArrayBuffer.isView)&&(ArrayBuffer.isView=function(t){return"object"==typeof t&&t.buffer&&t.buffer.constructor===ArrayBuffer});for(var d=function(t,e,a){return function(i){return new x(t,e,t).update(i)[a]()}},m=function(t,e,a){return function(i,n){return new x(t,e,n).update(i)[a]()}},A=function(t,e,a){return function(e,i,n,r){return C["cshake"+t].update(e,i,n,r)[a]()}},p=function(t,e,a){return function(e,i,n,r){return C["kmac"+t].update(e,i,n,r)[a]()}},y=function(t,e,a,i){for(var n=0;n<w.length;++n){var r=w[n];t[r]=e(a,i,r)}return t},I=function(t,e){var a=d(t,e,"hex");return a.create=function(){return new x(t,e,t)},a.update=function(t){return a.create().update(t)},y(a,d,t,e)},b=[{name:"keccak",padding:[1,256,65536,16777216],bits:g,createMethod:I},{name:"sha3",padding:[6,1536,393216,100663296],bits:g,createMethod:I},{name:"shake",padding:[31,7936,2031616,520093696],bits:h,createMethod:function(t,e){var a=m(t,e,"hex");return a.create=function(a){return new x(t,e,a)},a.update=function(t,e){return a.create(e).update(t)},y(a,m,t,e)}},{name:"cshake",padding:l,bits:h,createMethod:function(t,e){var a=c[t],i=A(t,e,"hex");return i.create=function(i,n,r){return n||r?new x(t,e,i).bytepad([n,r],a):C["shake"+t].create(i)},i.update=function(t,e,a,n){return i.create(e,a,n).update(t)},y(i,A,t,e)}},{name:"kmac",padding:l,bits:h,createMethod:function(t,e){var a=c[t],i=p(t,e,"hex");return i.create=function(i,n,r){return new L(t,e,n).bytepad(["KMAC",r],a).bytepad([i],a)},i.update=function(t,e,a,n){return i.create(t,a,n).update(e)},y(i,p,t,e)}}],C={},E=[],S=0;S<b.length;++S)for(var v=b[S],F=v.bits,B=0;B<F.length;++B){var G=v.name+"_"+F[B];if(E.push(G),C[G]=v.createMethod(F[B],v.padding),"sha3"!==v.name){var Q=v.name+F[B];E.push(Q),C[Q]=C[G]}}function x(t,e,a){this.blocks=[],this.s=[],this.padding=e,this.outputBits=a,this.reset=!0,this.finalized=!1,this.block=0,this.start=0,this.blockCount=1600-(t<<1)>>5,this.byteCount=this.blockCount<<2,this.outputBlocks=a>>5,this.extraBytes=(31&a)>>3;for(var i=0;i<50;++i)this.s[i]=0}function L(t,e,a){x.call(this,t,e,a)}x.prototype.update=function(e){if(this.finalized)throw Error("finalize already called");var a,i=typeof e;if("string"!==i){if("object"===i){if(null===e)throw Error(t);if(r&&e.constructor===ArrayBuffer)e=new Uint8Array(e);else if(!Array.isArray(e)&&(!r||!ArrayBuffer.isView(e)))throw Error(t)}else throw Error(t);a=!0}for(var n,o,l=this.blocks,s=this.byteCount,f=e.length,g=this.blockCount,h=0,w=this.s;h<f;){if(this.reset)for(n=1,this.reset=!1,l[0]=this.block;n<g+1;++n)l[n]=0;if(a)for(n=this.start;h<f&&n<s;++h)l[n>>2]|=e[h]<<u[3&n++];else for(n=this.start;h<f&&n<s;++h)(o=e.charCodeAt(h))<128?l[n>>2]|=o<<u[3&n++]:(o<2048?l[n>>2]|=(192|o>>6)<<u[3&n++]:(o<55296||o>=57344?l[n>>2]|=(224|o>>12)<<u[3&n++]:(o=65536+((1023&o)<<10|1023&e.charCodeAt(++h)),l[n>>2]|=(240|o>>18)<<u[3&n++],l[n>>2]|=(128|o>>12&63)<<u[3&n++]),l[n>>2]|=(128|o>>6&63)<<u[3&n++]),l[n>>2]|=(128|63&o)<<u[3&n++]);if(this.lastByteIndex=n,n>=s){for(this.start=n-s,this.block=l[g],n=0;n<g;++n)w[n]^=l[n];U(w),this.reset=!0}else this.start=n}return this},x.prototype.encode=function(t,e){var a=255&t,i=1,n=[a];for(t>>=8,a=255&t;a>0;)n.unshift(a),t>>=8,a=255&t,++i;return e?n.push(i):n.unshift(i),this.update(n),n.length},x.prototype.encodeString=function(e){var a,i=typeof e;if("string"!==i){if("object"===i){if(null===e)throw Error(t);if(r&&e.constructor===ArrayBuffer)e=new Uint8Array(e);else if(!Array.isArray(e)&&(!r||!ArrayBuffer.isView(e)))throw Error(t)}else throw Error(t);a=!0}var n=0,o=e.length;if(a)n=o;else for(var l=0;l<e.length;++l){var s=e.charCodeAt(l);s<128?n+=1:s<2048?n+=2:s<55296||s>=57344?n+=3:(s=65536+((1023&s)<<10|1023&e.charCodeAt(++l)),n+=4)}return n+=this.encode(8*n),this.update(e),n},x.prototype.bytepad=function(t,e){for(var a=this.encode(e),i=0;i<t.length;++i)a+=this.encodeString(t[i]);var n=e-a%e,r=[];return r.length=n,this.update(r),this},x.prototype.finalize=function(){if(!this.finalized){this.finalized=!0;var t=this.blocks,e=this.lastByteIndex,a=this.blockCount,i=this.s;if(t[e>>2]|=this.padding[3&e],this.lastByteIndex===this.byteCount)for(e=1,t[0]=t[a];e<a+1;++e)t[e]=0;for(t[a-1]|=2147483648,e=0;e<a;++e)i[e]^=t[e];U(i)}},x.prototype.toString=x.prototype.hex=function(){this.finalize();for(var t,e=this.blockCount,a=this.s,i=this.outputBlocks,n=this.extraBytes,r=0,l=0,s="";l<i;){for(r=0;r<e&&l<i;++r,++l)s+=o[(t=a[r])>>4&15]+o[15&t]+o[t>>12&15]+o[t>>8&15]+o[t>>20&15]+o[t>>16&15]+o[t>>28&15]+o[t>>24&15];l%e==0&&(U(a),r=0)}return n&&(s+=o[(t=a[r])>>4&15]+o[15&t],n>1&&(s+=o[t>>12&15]+o[t>>8&15]),n>2&&(s+=o[t>>20&15]+o[t>>16&15])),s},x.prototype.arrayBuffer=function(){this.finalize();for(var t,e=this.blockCount,a=this.s,i=this.outputBlocks,n=this.extraBytes,r=0,o=0,l=this.outputBits>>3,s=new Uint32Array(t=new ArrayBuffer(n?i+1<<2:l));o<i;){for(r=0;r<e&&o<i;++r,++o)s[o]=a[r];o%e==0&&U(a)}return n&&(s[r]=a[r],t=t.slice(0,l)),t},x.prototype.buffer=x.prototype.arrayBuffer,x.prototype.digest=x.prototype.array=function(){this.finalize();for(var t,e,a=this.blockCount,i=this.s,n=this.outputBlocks,r=this.extraBytes,o=0,l=0,s=[];l<n;){for(o=0;o<a&&l<n;++o,++l)t=l<<2,e=i[o],s[t]=255&e,s[t+1]=e>>8&255,s[t+2]=e>>16&255,s[t+3]=e>>24&255;l%a==0&&U(i)}return r&&(t=l<<2,e=i[o],s[t]=255&e,r>1&&(s[t+1]=e>>8&255),r>2&&(s[t+2]=e>>16&255)),s},L.prototype=new x,L.prototype.finalize=function(){return this.encode(this.outputBits,!0),x.prototype.finalize.call(this)};var U=function(t){var e,a,i,n,r,o,l,s,u,g,h,w,c,d,m,A,p,y,I,b,C,E,S,v,F,B,G,Q,x,L,U,_,T,z,P,D,R,k,O,M,V,q,K,$,H,N,j,W,Y,Z,X,J,tt,te,ta,ti,tn,tr,to,tl,ts,tu,tf;for(i=0;i<48;i+=2)n=t[0]^t[10]^t[20]^t[30]^t[40],r=t[1]^t[11]^t[21]^t[31]^t[41],o=t[2]^t[12]^t[22]^t[32]^t[42],l=t[3]^t[13]^t[23]^t[33]^t[43],s=t[4]^t[14]^t[24]^t[34]^t[44],u=t[5]^t[15]^t[25]^t[35]^t[45],g=t[6]^t[16]^t[26]^t[36]^t[46],h=t[7]^t[17]^t[27]^t[37]^t[47],w=t[8]^t[18]^t[28]^t[38]^t[48],c=t[9]^t[19]^t[29]^t[39]^t[49],e=w^(o<<1|l>>>31),a=c^(l<<1|o>>>31),t[0]^=e,t[1]^=a,t[10]^=e,t[11]^=a,t[20]^=e,t[21]^=a,t[30]^=e,t[31]^=a,t[40]^=e,t[41]^=a,e=n^(s<<1|u>>>31),a=r^(u<<1|s>>>31),t[2]^=e,t[3]^=a,t[12]^=e,t[13]^=a,t[22]^=e,t[23]^=a,t[32]^=e,t[33]^=a,t[42]^=e,t[43]^=a,e=o^(g<<1|h>>>31),a=l^(h<<1|g>>>31),t[4]^=e,t[5]^=a,t[14]^=e,t[15]^=a,t[24]^=e,t[25]^=a,t[34]^=e,t[35]^=a,t[44]^=e,t[45]^=a,e=s^(w<<1|c>>>31),a=u^(c<<1|w>>>31),t[6]^=e,t[7]^=a,t[16]^=e,t[17]^=a,t[26]^=e,t[27]^=a,t[36]^=e,t[37]^=a,t[46]^=e,t[47]^=a,e=g^(n<<1|r>>>31),a=h^(r<<1|n>>>31),t[8]^=e,t[9]^=a,t[18]^=e,t[19]^=a,t[28]^=e,t[29]^=a,t[38]^=e,t[39]^=a,t[48]^=e,t[49]^=a,d=t[0],m=t[1],N=t[11]<<4|t[10]>>>28,j=t[10]<<4|t[11]>>>28,Q=t[20]<<3|t[21]>>>29,x=t[21]<<3|t[20]>>>29,tl=t[31]<<9|t[30]>>>23,ts=t[30]<<9|t[31]>>>23,q=t[40]<<18|t[41]>>>14,K=t[41]<<18|t[40]>>>14,z=t[2]<<1|t[3]>>>31,P=t[3]<<1|t[2]>>>31,A=t[13]<<12|t[12]>>>20,p=t[12]<<12|t[13]>>>20,W=t[22]<<10|t[23]>>>22,Y=t[23]<<10|t[22]>>>22,L=t[33]<<13|t[32]>>>19,U=t[32]<<13|t[33]>>>19,tu=t[42]<<2|t[43]>>>30,tf=t[43]<<2|t[42]>>>30,te=t[5]<<30|t[4]>>>2,ta=t[4]<<30|t[5]>>>2,D=t[14]<<6|t[15]>>>26,R=t[15]<<6|t[14]>>>26,y=t[25]<<11|t[24]>>>21,I=t[24]<<11|t[25]>>>21,Z=t[34]<<15|t[35]>>>17,X=t[35]<<15|t[34]>>>17,_=t[45]<<29|t[44]>>>3,T=t[44]<<29|t[45]>>>3,v=t[6]<<28|t[7]>>>4,F=t[7]<<28|t[6]>>>4,ti=t[17]<<23|t[16]>>>9,tn=t[16]<<23|t[17]>>>9,k=t[26]<<25|t[27]>>>7,O=t[27]<<25|t[26]>>>7,b=t[36]<<21|t[37]>>>11,C=t[37]<<21|t[36]>>>11,J=t[47]<<24|t[46]>>>8,tt=t[46]<<24|t[47]>>>8,$=t[8]<<27|t[9]>>>5,H=t[9]<<27|t[8]>>>5,B=t[18]<<20|t[19]>>>12,G=t[19]<<20|t[18]>>>12,tr=t[29]<<7|t[28]>>>25,to=t[28]<<7|t[29]>>>25,M=t[38]<<8|t[39]>>>24,V=t[39]<<8|t[38]>>>24,E=t[48]<<14|t[49]>>>18,S=t[49]<<14|t[48]>>>18,t[0]=d^~A&y,t[1]=m^~p&I,t[10]=v^~B&Q,t[11]=F^~G&x,t[20]=z^~D&k,t[21]=P^~R&O,t[30]=$^~N&W,t[31]=H^~j&Y,t[40]=te^~ti&tr,t[41]=ta^~tn&to,t[2]=A^~y&b,t[3]=p^~I&C,t[12]=B^~Q&L,t[13]=G^~x&U,t[22]=D^~k&M,t[23]=R^~O&V,t[32]=N^~W&Z,t[33]=j^~Y&X,t[42]=ti^~tr&tl,t[43]=tn^~to&ts,t[4]=y^~b&E,t[5]=I^~C&S,t[14]=Q^~L&_,t[15]=x^~U&T,t[24]=k^~M&q,t[25]=O^~V&K,t[34]=W^~Z&J,t[35]=Y^~X&tt,t[44]=tr^~tl&tu,t[45]=to^~ts&tf,t[6]=b^~E&d,t[7]=C^~S&m,t[16]=L^~_&v,t[17]=U^~T&F,t[26]=M^~q&z,t[27]=V^~K&P,t[36]=Z^~J&$,t[37]=X^~tt&H,t[46]=tl^~tu&te,t[47]=ts^~tf&ta,t[8]=E^~d&A,t[9]=S^~m&p,t[18]=_^~v&B,t[19]=T^~F&G,t[28]=q^~z&D,t[29]=K^~P&R,t[38]=J^~$&N,t[39]=tt^~H&j,t[48]=tu^~te&ti,t[49]=tf^~ta&tn,t[0]^=f[i],t[1]^=f[i+1]};if(n)ai.exports=C;else for(S=0;S<E.length;++S)a[E[S]]=C[E[S]]}();let{keccak256:an}=ai.exports;class ar{constructor(t){this.G1=t.G1,this.Fr=t.Fr,this.reset()}reset(){this.data=[]}addPolCommitment(t){this.data.push({type:0,data:t})}addScalar(t){this.data.push({type:1,data:t})}getChallenge(){if(0===this.data.length)throw Error("Keccak256Transcript: No data to generate a transcript");let t=0,e=0;this.data.forEach(a=>0===a.type?t++:e++);let a=new Uint8Array(e*this.Fr.n8+t*this.G1.F.n8*2),i=0;for(let t=0;t<this.data.length;t++)0===this.data[t].type?(this.G1.toRprUncompressed(a,i,this.data[t].data),i+=2*this.G1.F.n8):(this.Fr.toRprBE(a,i,this.data[t].data),i+=this.Fr.n8);let n=l.Ru.fromRprBE(new Uint8Array(an.arrayBuffer(a)));return this.Fr.e(n)}}class ao{static getZ1(t){return[t.zero,t.add(t.e(-1),t.w[2]),t.e(-2),t.sub(t.e(-1),t.w[2])]}static getZ2(t){return[t.zero,t.add(t.zero,t.mul(t.e(-2),t.w[2])),t.e(4),t.sub(t.zero,t.mul(t.e(-2),t.w[2]))]}static getZ3(t){return[t.zero,t.add(t.e(2),t.mul(t.e(2),t.w[2])),t.e(-8),t.sub(t.e(2),t.mul(t.e(2),t.w[2]))]}static mul2(t,e,a,i,n,r){let o;let l=this.getZ1(r),s=r.mul(t,e),u=r.mul(t,i),f=r.mul(a,e),g=r.mul(a,i);return o=r.add(u,f),n&&(o=r.add(o,r.mul(l[n],g))),[s,o]}static mul3(t,e,a,i,n,r,o,l){let s,u;let f=this.getZ1(l),g=this.getZ2(l),h=l.mul(t,e),w=l.mul(t,n),c=l.mul(i,e),d=l.mul(i,n);s=l.mul(h,a);let m=l.mul(c,a);m=l.add(m,l.mul(w,a)),m=l.add(m,l.mul(h,r));let A=l.mul(d,a);if(A=l.add(A,l.mul(w,r)),A=l.add(A,l.mul(c,r)),u=m,o){let t=l.mul(d,r);u=l.add(u,l.mul(f[o],A)),u=l.add(u,l.mul(g[o],t))}return[s,u]}static mul4(t,e,a,i,n,r,o,l,s,u){let f,g;let h=this.getZ1(u),w=this.getZ2(u),c=this.getZ3(u),d=u.mul(t,e),m=u.mul(t,r),A=u.mul(n,e),p=u.mul(n,r),y=u.mul(a,i),I=u.mul(a,l),b=u.mul(o,i),C=u.mul(o,l);f=u.mul(d,y);let E=u.mul(A,y);E=u.add(E,u.mul(m,y)),E=u.add(E,u.mul(d,b)),E=u.add(E,u.mul(d,I));let S=u.mul(p,y);S=u.add(S,u.mul(A,b)),S=u.add(S,u.mul(A,I)),S=u.add(S,u.mul(m,b)),S=u.add(S,u.mul(m,I)),S=u.add(S,u.mul(d,C));let v=u.mul(m,C);v=u.add(v,u.mul(A,C)),v=u.add(v,u.mul(p,I)),v=u.add(v,u.mul(p,b));let F=u.mul(p,C);return g=E,s&&(g=u.add(g,u.mul(h[s],S)),g=u.add(g,u.mul(w[s],v)),g=u.add(g,u.mul(c[s],F))),[f,g]}}class al{constructor(t,e,a){this.coef=t,this.curve=e,this.Fr=e.Fr,this.G1=e.G1,this.logger=a}static async fromEvaluations(t,e,a){return new al(await e.Fr.ifft(t),e,a)}static fromCoefficientsArray(t,e,a){let i=e.Fr,n=t.length>32768?new l.qc(t.length*i.n8):new Uint8Array(t.length*i.n8);for(let e=0;e<t.length;e++)n.set(t[e],e*i.n8);return new al(n,e,a)}static fromPolynomial(t,e,a){let i=t.length(),n=e.Fr,r=i>32768?new l.qc(i*n.n8):new Uint8Array(i*n.n8);return r.set(t.coef.slice(),0),new al(r,e,a)}isEqual(t){let e=this.degree();if(e!==t.degree())return!1;for(let a=0;a<e+1;a++)if(!this.Fr.eq(this.getCoef(a),t.getCoef(a)))return!1;return!0}blindCoefficients(t){t=t||[];let e=this.length()+t.length>32768?new l.qc((this.length()+t.length)*this.Fr.n8):new Uint8Array((this.length()+t.length)*this.Fr.n8);e.set(this.coef,0);for(let a=0;a<t.length;a++)e.set(this.Fr.add(e.slice((this.length()+a)*this.Fr.n8,(this.length()+a+1)*this.Fr.n8),t[a]),(this.length()+a)*this.Fr.n8),e.set(this.Fr.sub(e.slice(a*this.Fr.n8,(a+1)*this.Fr.n8),t[a]),a*this.Fr.n8);this.coef=e}getCoef(t){let e=t*this.Fr.n8;return e+this.Fr.n8>this.coef.byteLength?this.Fr.zero:this.coef.slice(e,e+this.Fr.n8)}setCoef(t,e){if(t>this.length()-1)throw Error("Coef index is not available");this.coef.set(e,t*this.Fr.n8)}static async to4T(t,e,a,i){a=a||[];let n=await i.ifft(t),r=4*e>32768?new l.qc(4*e*i.n8):new Uint8Array(4*e*i.n8);r.set(n,0);let o=await i.fft(r);if(0===a.length)return[n,o];let s=e+a.length>32768?new l.qc((e+a.length)*i.n8):new Uint8Array((e+a.length)*i.n8);s.set(n,0);for(let t=0;t<a.length;t++)s.set(i.add(s.slice((e+t)*i.n8,(e+t+1)*i.n8),a[t]),(e+t)*i.n8),s.set(i.sub(s.slice(t*i.n8,(t+1)*i.n8),a[t]),t*i.n8);return[s,o]}length(){let t=this.coef.byteLength/this.Fr.n8;if(t!==Math.floor(this.coef.byteLength/this.Fr.n8))throw Error("Polynomial coefficients buffer has incorrect size");return 0===t&&this.logger&&this.logger.warn("Polynomial has length zero"),t}degree(){for(let t=this.length()-1;t>0;t--){let e=t*this.Fr.n8;if(!this.Fr.eq(this.Fr.zero,this.coef.slice(e,e+this.Fr.n8)))return t}return 0}evaluate(t){let e=this.Fr.zero;for(let a=this.degree()+1;a>0;a--){let i=a*this.Fr.n8,n=this.coef.slice(i-this.Fr.n8,i);e=this.Fr.add(n,this.Fr.mul(e,t))}return e}fastEvaluate(t){let e=this.Fr,a=this.degree()+1,i=parseInt(a/3),n=a-3*i,r=[],o=[];o[0]=e.one;for(let a=0;a<3;a++){r[a]=e.zero;let l=2===a?i+n:i;for(let n=l;n>0;n--)r[a]=e.add(this.getCoef(a*i+n-1),e.mul(r[a],t)),0===a&&(o[0]=e.mul(o[0],t))}for(let t=1;t<3;t++)r[0]=e.add(r[0],e.mul(o[t-1],r[t])),o[t]=e.mul(o[t-1],o[0]);return r[0]}add(t,e){let a=!1;t.length()>this.length()&&(a=!0);let i=this.length(),n=t.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?t.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==e&&(s=this.Fr.mul(s,e)),a?t.coef.set(this.Fr.add(l,s),o):this.coef.set(this.Fr.add(l,s),o)}a&&(delete this.coef,this.coef=t.coef)}sub(t,e){let a=!1;t.length()>this.length()&&(a=!0);let i=this.length(),n=t.length();for(let r=0;r<Math.max(i,n);r++){let o=r*this.Fr.n8,l=r<i?this.coef.slice(o,o+this.Fr.n8):this.Fr.zero,s=r<n?t.coef.slice(o,o+this.Fr.n8):this.Fr.zero;void 0!==e&&(s=this.Fr.mul(s,e)),a?t.coef.set(this.Fr.sub(l,s),o):this.coef.set(this.Fr.sub(l,s),o)}a&&(delete this.coef,this.coef=t.coef)}mulScalar(t){for(let e=0;e<this.length();e++){let a=e*this.Fr.n8;this.coef.set(this.Fr.mul(this.coef.slice(a,a+this.Fr.n8),t),a)}}addScalar(t){let e=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.add(e,t),0)}subScalar(t){let e=0===this.length()?this.Fr.zero:this.coef.slice(0,this.Fr.n8);this.coef.set(this.Fr.sub(e,t),0)}byXSubValue(t){let e=this.Fr,a=e.eq(e.zero,this.getCoef(this.length()-1))?this.length():this.length()+1,i=new al(a>32768?new l.qc(a*e.n8):new Uint8Array(a*e.n8),this.curve,this.logger);i.coef.set(this.coef.slice(0,(a-1)*e.n8),32),this.mulScalar(e.neg(t)),i.add(this),this.coef=i.coef}byXNSubValue(t,e){let a=this.Fr,i=this.length()-t-1>=this.degree()?this.length():this.length()+t,n=new al(i>32768?new l.qc(i*a.n8):new Uint8Array(i*a.n8),this.curve,this.logger);n.coef.set(this.coef.slice(0,(this.degree()+1)*32),32*t),this.mulScalar(e),n.add(this),this.coef=n.coef}divBy(t){let e=this.Fr,a=this.degree(),i=t.degree(),n=new al(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new l.qc(this.length()*e.n8):new Uint8Array(this.length()*e.n8);for(let r=a-i;r>=0;r--){this.setCoef(r,e.div(n.getCoef(r+i),t.getCoef(i)));for(let a=0;a<=i;a++)n.setCoef(r+a,e.sub(n.getCoef(r+a),e.mul(this.getCoef(r),t.getCoef(a))))}return n}divByMonic(t,e){let a=this.Fr,i=this.degree(),n=new al(this.length()>32768?new l.qc(this.length()*a.n8):new Uint8Array(this.length()*a.n8),this.curve,this.logger),r=[];for(let e=0;e<t;e++)n.setCoef(i-e-t,this.getCoef(i-e)),r[e]=this.getCoef(i-e);for(let o=0;o<t;o++)for(let l=i-2*t-o;l>=0&&!(l<0);l-=t){let i=o;r[i]=a.add(this.getCoef(l+t),a.mul(r[i],e)),n.setCoef(l,r[i])}this.coef=n.coef}divByVanishing(t,e){if(this.degree()<t)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new al(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new l.qc(this.length()*a.n8):new Uint8Array(this.length()*a.n8);for(let n=this.length()-1;n>=t;n--){let r=i.getCoef(n);a.eq(a.zero,r)||(i.setCoef(n,a.zero),i.setCoef(n-t,a.add(i.getCoef(n-t),a.mul(e,r))),this.setCoef(n-t,a.add(this.getCoef(n-t),r)))}return i}divByVanishing2(t,e){if(this.degree()<t)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let a=this.Fr,i=new al(this.coef,this.curve,this.logger);this.coef=this.length()>32768?new l.qc(this.length()*a.n8):new Uint8Array(this.length()*a.n8);let n=this.length()-t,r=Math.floor(n/3),o=n-2*r;console.log(n),console.log(r+"  "+o);for(let n=0;n<3;n++){console.log("> Thread "+n);for(let l=0===n?o:r;l>0;l--){let s=l-1;0!==n&&(s+=(n-1)*r+o);let u=s+t,f=i.getCoef(u);a.eq(a.zero,f)||(i.setCoef(u,a.zero),i.setCoef(s,a.add(i.getCoef(s),a.mul(e,f))),this.setCoef(s,a.add(this.getCoef(s),f)),console.log(s+" <-- "+u))}}return this.print(),i}fastDivByVanishing(t){let e=this.Fr;for(let a=0;a<t.length;a++){let i=t[a][0],n=t[a][1];if(this.degree()<i)throw Error("divByVanishing polynomial divisor must be of degree lower than the dividend polynomial");let r=this.length()-i,o=Math.floor(r/5/i),s=o*i,u=r-5*s,f=new al(this.length()>32768?new l.qc(this.length()*e.n8):new Uint8Array(this.length()*e.n8),this.curve,this.logger),g=this.coef;this.coef=f.coef,f.coef=g;for(let t=0;t<5;t++){let a=(t+1)*s+u;for(let t=0;t<i;t++)this.setCoef(a+t-i,f.getCoef(a+t));for(let t=0;t<s-i;t++){let r=a-t-1,o=e.add(f.getCoef(r),e.mul(n,this.getCoef(r)));this.setCoef(r-i,o)}}let h=u;for(let t=0;t<i&&h;t++)this.setCoef(u-t-1,f.getCoef(u+i-t-1)),h--;for(let t=0;t<h;t++){let a=u-t-1,r=e.add(f.getCoef(a),e.mul(n,this.getCoef(a)));this.setCoef(a-i,r)}let w=[],c=e.one;for(let t=0;t<o;t++)c=e.mul(c,n);let d=e.one;for(let t=5;t>0;t--){let a=t-1,n=a*s+u;w[a]=[];for(let r=0;r<i;r++)w[a][r]=this.getCoef(n+r),5!==t&&(w[a][r]=e.add(w[a][r],e.mul(c,w[a+1][r])));d=e.mul(d,c)}for(let t=0;t<5;t++){let a=t*s+u,r=n,o=i-1,l=0===t?u:s;for(let s=0;s<l;s++){let l=a-s-1,u=e.add(this.getCoef(l),e.mul(r,w[t][o]));this.setCoef(l,u),0===o?(o=i-1,r=e.mul(r,n)):o--}}}}divByXSubValue(t){let e=this.length()>32768?new l.qc(this.length()*this.Fr.n8):new Uint8Array(this.length()*this.Fr.n8);e.set(this.Fr.zero,(this.length()-1)*this.Fr.n8),e.set(this.coef.slice((this.length()-1)*this.Fr.n8,this.length()*this.Fr.n8),(this.length()-2)*this.Fr.n8);for(let a=this.length()-3;a>=0;a--){let i=a*this.Fr.n8;e.set(this.Fr.add(this.coef.slice(i+this.Fr.n8,i+2*this.Fr.n8),this.Fr.mul(t,e.slice(i+this.Fr.n8,i+2*this.Fr.n8))),a*this.Fr.n8)}if(!this.Fr.eq(this.coef.slice(0,this.Fr.n8),this.Fr.mul(this.Fr.neg(t),e.slice(0,this.Fr.n8))))throw Error("Polynomial does not divide");this.coef=e}divZh(t,e=4){for(let e=0;e<t;e++){let t=e*this.Fr.n8;this.coef.set(this.Fr.neg(this.coef.slice(t,t+this.Fr.n8)),t)}let a=this.coef.byteLength/this.Fr.n8;for(let i=t;i<a;i++){let a=i*this.Fr.n8,n=this.Fr.sub(this.coef.slice((i-t)*this.Fr.n8,(i-t)*this.Fr.n8+this.Fr.n8),this.coef.slice(a,a+this.Fr.n8));if(this.coef.set(n,a),i>t*(e-1)-e&&!this.Fr.isZero(n))throw Error("Polynomial is not divisible")}return this}divByZerofier(t,e){let a=this.Fr,i=a.inv(e),n=a.neg(i),r=a.eq(a.one,n),o=a.eq(a.negone,n);if(!r)for(let e=0;e<t;e++){let t;let i=e*this.Fr.n8;t=o?a.neg(this.coef.slice(i,i+this.Fr.n8)):a.mul(n,this.coef.slice(i,i+this.Fr.n8)),this.coef.set(t,i)}r=a.eq(a.one,i),o=a.eq(a.negone,i);for(let e=t;e<this.length();e++){let n=e*this.Fr.n8,l=(e-t)*this.Fr.n8,s=this.Fr.sub(this.coef.slice(l,l+this.Fr.n8),this.coef.slice(n,n+this.Fr.n8));if(r||(s=o?a.neg(s):a.mul(i,s)),this.coef.set(s,n),e>this.length()-t-1&&!this.Fr.isZero(s))throw Error("Polynomial is not divisible")}return this}byX(){let t=this.length()+1>32768?new l.qc(this.coef.byteLength+this.Fr.n8):new Uint8Array(this.coef.byteLength+this.Fr.n8);t.set(this.Fr.zero,0),t.set(this.coef,this.Fr.n8),this.coef=t}static async expX(t,e,a=!1){let i=t.Fr;if(e<1)throw Error("Compute a new polynomial to a zero or negative number is not allowed");if(1===e)return await al.fromEvaluations(t.coef,curve,t.logger);let n=a?t.degree():t.length()-1,r=n*e+1>32768?new l.qc((n*e+1)*i.n8):new Uint8Array((n*e+1)*i.n8);r.set(t.getCoef(0),0);for(let a=1;a<=n;a++){let n=a*i.n8,o=t.getCoef(a);r.set(o,n*e)}return new al(r,t.curve,t.logger)}split(t,e,a){if(t<1)throw Error(`Polynomials can't be split in ${t} parts`);if(1===t)return[this];if(0!==a.length&&a.length<t-1)throw Error(`Blinding factors length must be ${t-1}`);let i=(e+1)*this.Fr.n8,n=[],r=Math.ceil((this.degree()+1)*this.Fr.n8/i);if(r<t)for(let e=r;e<t;e++)n[e]=new al(new Uint8Array(this.Fr.n8),this.curve,this.logger);t=Math.min(t,r);for(let e=0;e<t;e++){let r=t-1===e,o=r?this.coef.byteLength-(t-1)*i:i+this.Fr.n8,s=o/this.Fr.n8>32768?new l.qc(o):new Uint8Array(o);n[e]=new al(s,this.curve,this.logger);let u=e*i,f=r?this.coef.byteLength:(e+1)*i;if(n[e].coef.set(this.coef.slice(u,f),0),r||n[e].coef.set(a[e],i),0!==e){let t=this.Fr.sub(n[e].coef.slice(0,this.Fr.n8),a[e-1]);n[e].coef.set(t,0)}r&&n[e].truncate()}return n}truncate(){let t=this.degree();if(t+1<this.coef.byteLength/this.Fr.n8){let e=t+1>32768?new l.qc((t+1)*this.Fr.n8):new Uint8Array((t+1)*this.Fr.n8);e.set(this.coef.slice(0,(t+1)*this.Fr.n8),0),this.coef=e}}static lagrangePolynomialInterpolation(t,e,a){let i=a.Fr,n=r(0);for(let e=1;e<t.length;e++)n.add(r(e));return n;function r(n){let r;for(let e=0;e<t.length;e++)e!==n&&(void 0===r?((r=new al(t.length>32768?new l.qc(t.length*i.n8):new Uint8Array(t.length*i.n8),a)).setCoef(0,i.neg(t[e])),r.setCoef(1,i.one)):r.byXSubValue(t[e]));let o=r.evaluate(t[n]);o=i.inv(o);let s=i.mul(e[n],o);return r.mulScalar(s),r}}static zerofierPolynomial(t,e){let a=e.Fr,i=new al(t.length+1>32768?new l.qc((t.length+1)*a.n8):new Uint8Array((t.length+1)*a.n8),e);i.setCoef(0,a.neg(t[0])),i.setCoef(1,a.one);for(let e=1;e<t.length;e++)i.byXSubValue(t[e]);return i}print(){let t=this.Fr,e="";for(let a=this.degree();a>=0;a--){let i=this.getCoef(a);!t.eq(t.zero,i)&&(t.isNegative(i)?e+=" - ":a!==this.degree()&&(e+=" + "),e+=t.toString(i),a>0&&(e+=a>1?"x^"+a:"x"))}console.log(e)}async multiExponentiation(t,e){let a=this.coef.byteLength/this.Fr.n8,i=t.slice(0,a*this.G1.F.n8*2),n=await this.Fr.batchFromMontgomery(this.coef),r=await this.G1.multiExpAffine(i,n,this.logger,e);return this.G1.toAffine(r)}}class as{constructor(t,e,a){this.eval=t,this.curve=e,this.Fr=e.Fr,this.logger=a}static async fromPolynomial(t,e,a,i){let n=new l.qc(t.length()*e*a.Fr.n8);return n.set(t.coef,0),new as(await a.Fr.fft(n),a,i)}getEvaluation(t){let e=t*this.Fr.n8;if(e+this.Fr.n8>this.eval.byteLength)throw Error("Evaluations.getEvaluation() out of bounds");return this.eval.slice(e,e+this.Fr.n8)}length(){let t=this.eval.byteLength/this.Fr.n8;if(t!==Math.floor(this.eval.byteLength/this.Fr.n8))throw Error("Polynomial evaluations buffer has incorrect size");return 0===t&&this.logger.warn("Polynomial has length zero"),t}}let{stringifyBigInts:au}=l.utils;async function af(t,e,a,i){let{fd:n,sections:r}=await S(e,"wtns",2);a&&a.debug("> Reading witness file");let o=await tY(n,r);a&&a.debug("> Reading zkey file");let{fd:s,sections:u}=await S(t,"zkey",2),f=await tD(s,u,void 0,i);if("plonk"!=f.protocol)throw Error("zkey file is not plonk");if(!l.Ru.eq(f.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!=f.nVars-f.nAdditions)throw Error(`Invalid witness length. Circuit: ${f.nVars}, witness: ${o.nWitness}, ${f.nAdditions}`);let g=f.curve,h=g.Fr,w=g.Fr.n8,c=f.domainSize*w;a&&(a.debug("----------------------------"),a.debug("  PLONK PROVE SETTINGS"),a.debug(`  Curve:         ${g.name}`),a.debug(`  Circuit power: ${f.power}`),a.debug(`  Domain size:   ${f.domainSize}`),a.debug(`  Vars:          ${f.nVars}`),a.debug(`  Public vars:   ${f.nPublic}`),a.debug(`  Constraints:   ${f.nConstraints}`),a.debug(`  Additions:     ${f.nAdditions}`),a.debug("----------------------------")),a&&a.debug("> Reading witness file data");let d=await _(n,r,2);d.set(h.zero,0);let m=new l.qc(w*f.nAdditions),A={},p={},y={},I={},b=new aa(g,a),C=new ar(g);a&&a.debug("> Reading Section 3. Additions"),await B(),a&&a.debug("> Reading Section 12. Sigma1, Sigma2 & Sigma 3"),a&&a.debug("\xb7\xb7\xb7 Reading Sigma polynomials "),p.Sigma1=new al(new l.qc(c),g,a),p.Sigma2=new al(new l.qc(c),g,a),p.Sigma3=new al(new l.qc(c),g,a),await s.readToBuffer(p.Sigma1.coef,0,c,u[12][0].p),await s.readToBuffer(p.Sigma2.coef,0,c,u[12][0].p+5*c),await s.readToBuffer(p.Sigma3.coef,0,c,u[12][0].p+10*c),a&&a.debug("\xb7\xb7\xb7 Reading Sigma evaluations"),y.Sigma1=new as(new l.qc(4*c),g,a),y.Sigma2=new as(new l.qc(4*c),g,a),y.Sigma3=new as(new l.qc(4*c),g,a),await s.readToBuffer(y.Sigma1.eval,0,4*c,u[12][0].p+c),await s.readToBuffer(y.Sigma2.eval,0,4*c,u[12][0].p+6*c),await s.readToBuffer(y.Sigma3.eval,0,4*c,u[12][0].p+11*c),a&&a.debug("> Reading Section 14. Powers of Tau");let E=await _(s,u,14),v=[];for(let t=1;t<=f.nPublic;t++){let e=d.slice(t*h.n8,t*h.n8+h.n8);v.push(l.Ru.fromRprLE(e))}a&&a.debug(""),a&&a.debug("> ROUND 1"),await x(),a&&a.debug("> ROUND 2"),await U(),a&&a.debug("> ROUND 3"),await z(),a&&a.debug("> ROUND 4"),await D(),a&&a.debug("> ROUND 5"),await R(),await s.close(),await n.close();let F=b.toObjectProof(!1);return F.protocol="plonk",F.curve=g.name,a&&a.debug("PLONK PROVER FINISHED"),{proof:au(F),publicSignals:au(v)};async function B(){a&&a.debug("\xb7\xb7\xb7 Computing additions");let t=await _(s,u,3),e=8+2*w;for(let i=0;i<f.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.debug(`    addition ${i}/${f.nAdditions}`);let n=i*e,r=G(t,n),o=G(t,n+=4);n+=4;let l=t.slice(n,n+w);n+=w;let s=t.slice(n,n+w),u=Q(r),g=Q(o),c=h.add(h.mul(l,u),h.mul(s,g));m.set(c,w*i)}}function G(t,e){let a=t.slice(e,e+4);return new DataView(a.buffer,a.byteOffset,a.byteLength).getUint32(0,!0)}function Q(t){return t<f.nVars-f.nAdditions?d.slice(t*w,t*w+w):t<f.nVars?m.slice((t-(f.nVars-f.nAdditions))*w,(t-(f.nVars-f.nAdditions))*w+w):g.Fr.zero}async function x(){I.b=[];for(let t=1;t<=11;t++)I.b[t]=g.Fr.random();a&&a.debug("> Computing A, B, C wire polynomials"),await L(),a&&a.debug("> Computing A, B, C MSM");let t=await p.A.multiExponentiation(E,"A"),e=await p.B.multiExponentiation(E,"B"),i=await p.C.multiExponentiation(E,"C");return b.addPolynomial("A",t),b.addPolynomial("B",e),b.addPolynomial("C",i),0}async function L(){a&&a.debug("\xb7\xb7\xb7 Reading data from zkey file"),A.A=new l.qc(c),A.B=new l.qc(c),A.C=new l.qc(c);let t=await _(s,u,4),e=await _(s,u,5),i=await _(s,u,6);for(let a=0;a<f.nConstraints;a++){let n=a*w,r=4*a,o=G(t,r);A.A.set(Q(o),n);let l=G(e,r);A.B.set(Q(l),n);let s=G(i,r);A.C.set(Q(s),n)}if(A.A=await h.batchToMontgomery(A.A),A.B=await h.batchToMontgomery(A.B),A.C=await h.batchToMontgomery(A.C),a&&a.debug("\xb7\xb7\xb7 Computing A ifft"),p.A=await al.fromEvaluations(A.A,g,a),a&&a.debug("\xb7\xb7\xb7 Computing B ifft"),p.B=await al.fromEvaluations(A.B,g,a),a&&a.debug("\xb7\xb7\xb7 Computing C ifft"),p.C=await al.fromEvaluations(A.C,g,a),a&&a.debug("\xb7\xb7\xb7 Computing A fft"),y.A=await as.fromPolynomial(p.A,4,g,a),a&&a.debug("\xb7\xb7\xb7 Computing B fft"),y.B=await as.fromPolynomial(p.B,4,g,a),a&&a.debug("\xb7\xb7\xb7 Computing C fft"),y.C=await as.fromPolynomial(p.C,4,g,a),p.A.blindCoefficients([I.b[2],I.b[1]]),p.B.blindCoefficients([I.b[4],I.b[3]]),p.C.blindCoefficients([I.b[6],I.b[5]]),p.A.degree()>=f.domainSize+2)throw Error("A Polynomial is not well calculated");if(p.B.degree()>=f.domainSize+2)throw Error("B Polynomial is not well calculated");if(p.C.degree()>=f.domainSize+2)throw Error("C Polynomial is not well calculated")}async function U(){a&&a.debug("> Computing challenges beta and gamma"),C.reset(),C.addPolCommitment(f.Qm),C.addPolCommitment(f.Ql),C.addPolCommitment(f.Qr),C.addPolCommitment(f.Qo),C.addPolCommitment(f.Qc),C.addPolCommitment(f.S1),C.addPolCommitment(f.S2),C.addPolCommitment(f.S3);for(let t=0;t<f.nPublic;t++)C.addScalar(A.A.slice(t*w,t*w+w));C.addPolCommitment(b.getPolynomial("A")),C.addPolCommitment(b.getPolynomial("B")),C.addPolCommitment(b.getPolynomial("C")),I.beta=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.beta: "+h.toString(I.beta,16)),C.reset(),C.addScalar(I.beta),I.gamma=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.gamma: "+h.toString(I.gamma,16)),a&&a.debug("> Computing Z polynomial"),await T(),a&&a.debug("> Computing Z MSM");let t=await p.Z.multiExponentiation(E,"Z");b.addPolynomial("Z",t)}async function T(){a&&a.debug("\xb7\xb7\xb7 Computing Z evaluations");let t=new l.qc(c),e=new l.qc(c);t.set(h.one,0),e.set(h.one,0);let i=h.one;for(let a=0;a<f.domainSize;a++){let n=a*w,r=A.A.slice(n,n+w),o=A.B.slice(n,n+w),l=A.C.slice(n,n+w),s=h.mul(I.beta,i),u=h.add(r,s);u=h.add(u,I.gamma);let g=h.add(o,h.mul(f.k1,s));g=h.add(g,I.gamma);let c=h.add(l,h.mul(f.k2,s));c=h.add(c,I.gamma);let d=h.mul(u,h.mul(g,c)),m=h.add(r,h.mul(y.Sigma1.getEvaluation(4*a),I.beta));m=h.add(m,I.gamma);let p=h.add(o,h.mul(y.Sigma2.getEvaluation(4*a),I.beta));p=h.add(p,I.gamma);let b=h.add(l,h.mul(y.Sigma3.getEvaluation(4*a),I.beta));b=h.add(b,I.gamma);let C=h.mul(m,h.mul(p,b));d=h.mul(t.slice(n,n+w),d),t.set(d,(a+1)%f.domainSize*w),C=h.mul(e.slice(n,n+w),C),e.set(C,(a+1)%f.domainSize*w),i=h.mul(i,h.w[f.power])}e=await h.batchInverse(e);for(let a=0;a<f.domainSize;a++){let i=a*w,n=h.mul(t.slice(i,i+w),e.slice(i,i+w));t.set(n,i)}if(A.Z=t,!h.eq(t.slice(0,w),h.one))throw Error("Copy constraints does not match");if(a&&a.debug("\xb7\xb7\xb7 Computing Z ifft"),p.Z=await al.fromEvaluations(A.Z,g,a),a&&a.debug("\xb7\xb7\xb7 Computing Z fft"),y.Z=await as.fromPolynomial(p.Z,4,g,a),p.Z.blindCoefficients([I.b[9],I.b[8],I.b[7]]),p.Z.degree()>=f.domainSize+3)throw Error("Z Polynomial is not well calculated");delete A.Z}async function z(){a&&a.debug("> Computing challenge alpha"),C.reset(),C.addScalar(I.beta),C.addScalar(I.gamma),C.addPolCommitment(b.getPolynomial("Z")),I.alpha=C.getChallenge(),I.alpha2=h.square(I.alpha),a&&a.debug("\xb7\xb7\xb7 challenges.alpha: "+h.toString(I.alpha,16)),a&&a.debug("> Computing T polynomial"),await P(),a&&a.debug("> Computing T MSM");let t=await p.T1.multiExponentiation(E,"T1"),e=await p.T2.multiExponentiation(E,"T2"),i=await p.T3.multiExponentiation(E,"T3");b.addPolynomial("T1",t),b.addPolynomial("T2",e),b.addPolynomial("T3",i)}async function P(){a&&a.debug(`\xb7\xb7\xb7 Reading sections 8, 9, 7, 10, 11. Q selectors`),y.QL=new as(new l.qc(4*c),g,a),y.QR=new as(new l.qc(4*c),g,a),y.QM=new as(new l.qc(4*c),g,a),y.QO=new as(new l.qc(4*c),g,a),y.QC=new as(new l.qc(4*c),g,a),await s.readToBuffer(y.QL.eval,0,4*c,u[8][0].p+c),await s.readToBuffer(y.QR.eval,0,4*c,u[9][0].p+c),await s.readToBuffer(y.QM.eval,0,4*c,u[7][0].p+c),await s.readToBuffer(y.QO.eval,0,4*c,u[10][0].p+c),await s.readToBuffer(y.QC.eval,0,4*c,u[11][0].p+c),y.Lagrange=new as(new l.qc(4*c*f.nPublic),g,a);for(let t=0;t<f.nPublic;t++)await s.readToBuffer(y.Lagrange.eval,t*c*4,4*c,u[13][0].p+5*t*c+c);A.T=new l.qc(4*c),A.Tz=new l.qc(4*c),a&&a.debug("\xb7\xb7\xb7 Computing T evaluations");let t=h.one;for(let e=0;e<4*f.domainSize;e++){a&&0!==e&&e%1e5==0&&a.debug(`      T evaluation ${e}/${4*f.domainSize}`);let i=y.A.getEvaluation(e),n=y.B.getEvaluation(e),r=y.C.getEvaluation(e),o=y.Z.getEvaluation(e),l=y.Z.getEvaluation((4*f.domainSize+4+e)%(4*f.domainSize)),s=y.QM.getEvaluation(e),u=y.QL.getEvaluation(e),g=y.QR.getEvaluation(e),c=y.QO.getEvaluation(e),d=y.QC.getEvaluation(e),m=y.Sigma1.getEvaluation(e),p=y.Sigma2.getEvaluation(e),b=y.Sigma3.getEvaluation(e),C=h.add(I.b[2],h.mul(I.b[1],t)),E=h.add(I.b[4],h.mul(I.b[3],t)),S=h.add(I.b[6],h.mul(I.b[5],t)),v=h.square(t),F=h.add(h.add(h.mul(I.b[7],v),h.mul(I.b[8],t)),I.b[9]),B=h.mul(t,h.w[f.power]),G=h.square(B),Q=h.add(h.add(h.mul(I.b[7],G),h.mul(I.b[8],B)),I.b[9]),x=h.zero;for(let t=0;t<f.nPublic;t++){let a=4*t*f.domainSize+e,i=y.Lagrange.getEvaluation(a),n=A.A.slice(t*w,(t+1)*w);x=h.sub(x,h.mul(i,n))}let[L,U]=ao.mul2(i,n,C,E,e%4,h);L=h.mul(L,s),U=h.mul(U,s),L=h.add(L,h.mul(i,u)),U=h.add(U,h.mul(C,u)),L=h.add(L,h.mul(n,g)),U=h.add(U,h.mul(E,g)),L=h.add(L,h.mul(r,c)),U=h.add(U,h.mul(S,c)),L=h.add(L,x),L=h.add(L,d);let _=h.mul(I.beta,t),T=i;T=h.add(T,_),T=h.add(T,I.gamma);let z=n;z=h.add(z,h.mul(_,f.k1)),z=h.add(z,I.gamma);let P=r;P=h.add(P,h.mul(_,f.k2)),P=h.add(P,I.gamma);let[D,R]=ao.mul4(T,z,P,o,C,E,S,F,e%4,h);D=h.mul(D,I.alpha),R=h.mul(R,I.alpha);let k=i;k=h.add(k,h.mul(I.beta,m)),k=h.add(k,I.gamma);let O=n;O=h.add(O,h.mul(I.beta,p)),O=h.add(O,I.gamma);let M=r;M=h.add(M,h.mul(I.beta,b)),M=h.add(M,I.gamma);let[V,q]=ao.mul4(k,O,M,l,C,E,S,Q,e%4,h);V=h.mul(V,I.alpha),q=h.mul(q,I.alpha);let K=h.sub(o,h.one);K=h.mul(K,y.Lagrange.getEvaluation(e)),K=h.mul(K,I.alpha2);let $=h.mul(F,y.Lagrange.getEvaluation(e));$=h.mul($,I.alpha2);let H=h.add(h.sub(h.add(L,D),V),K),N=h.add(h.sub(h.add(U,R),q),$);A.T.set(H,e*w),A.Tz.set(N,e*w),t=h.mul(t,h.w[f.power+2])}if(a&&a.debug("\xb7\xb7\xb7 Computing T ifft"),p.T=await al.fromEvaluations(A.T,g,a),a&&a.debug("\xb7\xb7\xb7 Computing T / ZH"),p.T.divZh(f.domainSize,4),a&&a.debug("\xb7\xb7\xb7 Computing Tz ifft"),p.Tz=await al.fromEvaluations(A.Tz,g,a),p.T.add(p.Tz),p.T.degree()>=3*f.domainSize+6)throw Error("T Polynomial is not well calculated");a&&a.debug("\xb7\xb7\xb7 Computing T1, T2, T3 polynomials"),p.T1=new al(new l.qc((f.domainSize+1)*w),g,a),p.T2=new al(new l.qc((f.domainSize+1)*w),g,a),p.T3=new al(new l.qc((f.domainSize+6)*w),g,a),p.T1.coef.set(p.T.coef.slice(0,c),0),p.T2.coef.set(p.T.coef.slice(c,2*c),0),p.T3.coef.set(p.T.coef.slice(2*c,3*c+6*w),0),p.T1.setCoef(f.domainSize,I.b[10]);let e=h.sub(p.T2.getCoef(0),I.b[10]);p.T2.setCoef(0,e),p.T2.setCoef(f.domainSize,I.b[11]);let i=h.sub(p.T3.getCoef(0),I.b[11]);p.T3.setCoef(0,i)}async function D(){a&&a.debug("> Computing challenge xi"),C.reset(),C.addScalar(I.alpha),C.addPolCommitment(b.getPolynomial("T1")),C.addPolCommitment(b.getPolynomial("T2")),C.addPolCommitment(b.getPolynomial("T3")),I.xi=C.getChallenge(),I.xiw=h.mul(I.xi,h.w[f.power]),a&&a.debug("\xb7\xb7\xb7 challenges.xi: "+h.toString(I.xi,16)),b.addEvaluation("eval_a",p.A.evaluate(I.xi)),b.addEvaluation("eval_b",p.B.evaluate(I.xi)),b.addEvaluation("eval_c",p.C.evaluate(I.xi)),b.addEvaluation("eval_s1",p.Sigma1.evaluate(I.xi)),b.addEvaluation("eval_s2",p.Sigma2.evaluate(I.xi)),b.addEvaluation("eval_zw",p.Z.evaluate(I.xiw))}async function R(){a&&a.debug("> Computing challenge v"),C.reset(),C.addScalar(I.xi),C.addScalar(b.getEvaluation("eval_a")),C.addScalar(b.getEvaluation("eval_b")),C.addScalar(b.getEvaluation("eval_c")),C.addScalar(b.getEvaluation("eval_s1")),C.addScalar(b.getEvaluation("eval_s2")),C.addScalar(b.getEvaluation("eval_zw")),I.v=[],I.v[1]=C.getChallenge(),a&&a.debug("\xb7\xb7\xb7 challenges.v: "+h.toString(I.v[1],16));for(let t=2;t<6;t++)I.v[t]=h.mul(I.v[t-1],I.v[1]);a&&a.debug("> Computing linearisation polynomial R(X)"),await k(),a&&a.debug("> Computing opening proof polynomial Wxi(X) polynomial"),p.Wxi=new al(new l.qc(c+6*w),g,a),p.Wxi.add(p.R),p.Wxi.add(p.A,I.v[1]),p.Wxi.add(p.B,I.v[2]),p.Wxi.add(p.C,I.v[3]),p.Wxi.add(p.Sigma1,I.v[4]),p.Wxi.add(p.Sigma2,I.v[5]),p.Wxi.subScalar(h.mul(I.v[1],b.evaluations.eval_a)),p.Wxi.subScalar(h.mul(I.v[2],b.evaluations.eval_b)),p.Wxi.subScalar(h.mul(I.v[3],b.evaluations.eval_c)),p.Wxi.subScalar(h.mul(I.v[4],b.evaluations.eval_s1)),p.Wxi.subScalar(h.mul(I.v[5],b.evaluations.eval_s2)),p.Wxi.divByZerofier(1,I.xi),a&&a.debug("> Computing opening proof polynomial Wxiw(X) polynomial"),O(),a&&a.debug("> Computing Wxi, Wxiw MSM");let t=await p.Wxi.multiExponentiation(E,"Wxi"),e=await p.Wxiw.multiExponentiation(E,"Wxiw");b.addPolynomial("Wxi",t),b.addPolynomial("Wxiw",e)}async function k(){let t=g.Fr;p.QL=new al(new l.qc(c),g,a),p.QR=new al(new l.qc(c),g,a),p.QM=new al(new l.qc(c),g,a),p.QO=new al(new l.qc(c),g,a),p.QC=new al(new l.qc(c),g,a),await s.readToBuffer(p.QL.coef,0,c,u[8][0].p),await s.readToBuffer(p.QR.coef,0,c,u[9][0].p),await s.readToBuffer(p.QM.coef,0,c,u[7][0].p),await s.readToBuffer(p.QO.coef,0,c,u[10][0].p),await s.readToBuffer(p.QC.coef,0,c,u[11][0].p),I.xin=I.xi;for(let e=0;e<f.power;e++)I.xin=t.square(I.xin);I.zh=t.sub(I.xin,t.one);let e=[],i=t.e(f.domainSize),n=t.one;for(let a=1;a<=Math.max(1,f.nPublic);a++)e[a]=t.div(t.mul(n,I.zh),t.mul(i,t.sub(I.xi,n))),n=t.mul(n,t.w[f.power]);let r=t.div(t.sub(I.xin,t.one),t.mul(i,t.sub(I.xi,t.one)));if(a){a.debug("Lagrange Evaluations: ");for(let i=1;i<e.length;i++)a.debug(`L${i}(xi)=`+t.toString(e[i],16))}let o=t.zero;for(let a=0;a<v.length;a++){let i=t.e(v[a]);o=t.sub(o,t.mul(i,e[a+1]))}a&&a.debug("PI: "+t.toString(o,16));let h=t.mul(b.evaluations.eval_a,b.evaluations.eval_b),d=b.evaluations.eval_a,m=t.mul(I.beta,I.xi);d=t.add(d,m),d=t.add(d,I.gamma);let A=b.evaluations.eval_b;A=t.add(A,t.mul(m,f.k1)),A=t.add(A,I.gamma);let y=b.evaluations.eval_c;y=t.add(y,t.mul(m,f.k2)),y=t.add(y,I.gamma);let C=t.mul(t.mul(t.mul(d,A),y),I.alpha),E=b.evaluations.eval_a;E=t.add(E,t.mul(I.beta,b.evaluations.eval_s1)),E=t.add(E,I.gamma);let S=b.evaluations.eval_b;S=t.add(S,t.mul(I.beta,b.evaluations.eval_s2)),S=t.add(S,I.gamma);let F=t.mul(E,S);F=t.mul(F,b.evaluations.eval_zw),F=t.mul(F,I.alpha);let B=t.mul(r,I.alpha2);p.R=new al(new l.qc((f.domainSize+6)*w),g,a),p.R.add(p.QM,h),p.R.add(p.QL,b.evaluations.eval_a),p.R.add(p.QR,b.evaluations.eval_b),p.R.add(p.QO,b.evaluations.eval_c),p.R.add(p.QC),p.R.add(p.Z,C),p.R.sub(p.Sigma3,t.mul(F,I.beta)),p.R.add(p.Z,B);let G=al.fromPolynomial(p.T3,g,a);G.mulScalar(t.square(I.xin)),G.add(p.T2,I.xin),G.add(p.T1),G.mulScalar(I.zh),p.R.sub(G);let Q=t.sub(o,t.mul(F,t.add(b.evaluations.eval_c,I.gamma)));Q=t.sub(Q,B),a&&a.debug("r0: "+t.toString(Q,16)),p.R.addScalar(Q)}async function O(){p.Wxiw=al.fromPolynomial(p.Z,g,a),p.Wxiw.subScalar(b.evaluations.eval_zw),p.Wxiw.divByZerofier(1,I.xiw)}}let{unstringifyBigInts:ag}=l.utils;async function ah(t,e,a,i,n,r){let o=ag(t),l={type:"mem"};return await t7(o,e,l,n),await af(a,l,i,r)}let{unstringifyBigInts:aw}=l.utils;async function ac(t,e,a,i){let n=aw(t);a=aw(a);let r=aw(e),o=await M(n.curve),l=o.Fr,s=o.G1;i&&i.info("PLONK VERIFIER STARTED");let u=function(t,e){let a=t.G1,i=t.Fr,n={};return n.A=a.fromObject(e.A),n.B=a.fromObject(e.B),n.C=a.fromObject(e.C),n.Z=a.fromObject(e.Z),n.T1=a.fromObject(e.T1),n.T2=a.fromObject(e.T2),n.T3=a.fromObject(e.T3),n.eval_a=i.fromObject(e.eval_a),n.eval_b=i.fromObject(e.eval_b),n.eval_c=i.fromObject(e.eval_c),n.eval_zw=i.fromObject(e.eval_zw),n.eval_s1=i.fromObject(e.eval_s1),n.eval_s2=i.fromObject(e.eval_s2),n.Wxi=a.fromObject(e.Wxi),n.Wxiw=a.fromObject(e.Wxiw),n}(o,a);if(n=function(t,e){let a=t.G1,i=t.G2,n=t.Fr;return e.Qm=a.fromObject(e.Qm),e.Ql=a.fromObject(e.Ql),e.Qr=a.fromObject(e.Qr),e.Qo=a.fromObject(e.Qo),e.Qc=a.fromObject(e.Qc),e.S1=a.fromObject(e.S1),e.S2=a.fromObject(e.S2),e.S3=a.fromObject(e.S3),e.k1=n.fromObject(e.k1),e.k2=n.fromObject(e.k2),e.X_2=i.fromObject(e.X_2),e}(o,n),!function(t,e){let a=t.G1;return!!(a.isValid(e.A)&&a.isValid(e.B)&&a.isValid(e.C)&&a.isValid(e.Z)&&a.isValid(e.T1)&&a.isValid(e.T2)&&a.isValid(e.T3)&&a.isValid(e.Wxi)&&a.isValid(e.Wxiw))}(o,u))return i.error("Proof is not well constructed"),!1;if(r.length!=n.nPublic)return i.error("Invalid number of public inputs"),!1;let f=function(t,e,a,i){let n=t.Fr,r={},o=new ar(t);o.addPolCommitment(i.Qm),o.addPolCommitment(i.Ql),o.addPolCommitment(i.Qr),o.addPolCommitment(i.Qo),o.addPolCommitment(i.Qc),o.addPolCommitment(i.S1),o.addPolCommitment(i.S2),o.addPolCommitment(i.S3);for(let t=0;t<a.length;t++)o.addScalar(n.e(a[t]));o.addPolCommitment(e.A),o.addPolCommitment(e.B),o.addPolCommitment(e.C),r.beta=o.getChallenge(),o.reset(),o.addScalar(r.beta),r.gamma=o.getChallenge(),o.reset(),o.addScalar(r.beta),o.addScalar(r.gamma),o.addPolCommitment(e.Z),r.alpha=o.getChallenge(),o.reset(),o.addScalar(r.alpha),o.addPolCommitment(e.T1),o.addPolCommitment(e.T2),o.addPolCommitment(e.T3),r.xi=o.getChallenge(),o.reset(),o.addScalar(r.xi),o.addScalar(e.eval_a),o.addScalar(e.eval_b),o.addScalar(e.eval_c),o.addScalar(e.eval_s1),o.addScalar(e.eval_s2),o.addScalar(e.eval_zw),r.v=[],r.v[1]=o.getChallenge();for(let t=2;t<6;t++)r.v[t]=n.mul(r.v[t-1],r.v[1]);return o.reset(),o.addPolCommitment(e.Wxi),o.addPolCommitment(e.Wxiw),r.u=o.getChallenge(),r}(o,u,r,n);if(i){i.debug("beta: "+l.toString(f.beta,16)),i.debug("gamma: "+l.toString(f.gamma,16)),i.debug("alpha: "+l.toString(f.alpha,16)),i.debug("xi: "+l.toString(f.xi,16));for(let t=1;t<6;t++)i&&i.debug("v: "+l.toString(f.v[t],16));i.debug("u: "+l.toString(f.u,16))}let g=function(t,e,a){let i=t.Fr,n=e.xi,r=1;for(let t=0;t<a.power;t++)n=i.square(n),r*=2;e.xin=n,e.zh=i.sub(n,i.one);let o=[],l=i.e(r),s=i.one;for(let t=1;t<=Math.max(1,a.nPublic);t++)o[t]=i.div(i.mul(s,e.zh),i.mul(l,i.sub(e.xi,s))),s=i.mul(s,i.w[a.power]);return o}(o,f,n);if(i)for(let t=1;t<g.length;t++)i.debug(`L${t}(xi)=`+l.toString(g[t],16));if(r.length!=n.nPublic)return i.error("Number of public signals does not match with vk"),!1;let h=function(t,e,a){let i=t.Fr,n=i.zero;for(let t=0;t<e.length;t++){let r=i.e(e[t]);n=i.sub(n,i.mul(r,a[t+1]))}return n}(o,r,g);i&&i.debug("PI(xi): "+l.toString(h,16));let w=function(t,e,a,i,n){let r=t.Fr,o=r.mul(n,r.square(a.alpha)),l=r.add(e.eval_a,r.mul(a.beta,e.eval_s1));l=r.add(l,a.gamma);let s=r.add(e.eval_b,r.mul(a.beta,e.eval_s2));s=r.add(s,a.gamma);let u=r.add(e.eval_c,a.gamma),f=r.mul(r.mul(l,s),u);return f=r.mul(f,e.eval_zw),f=r.mul(f,a.alpha),r.sub(r.sub(i,o),f)}(o,u,f,h,g[1]);i&&i.debug("r0: "+l.toString(w,16));let c=function(t,e,a,i,n){let r=t.G1,o=t.Fr,l=r.timesFr(i.Qm,o.mul(e.eval_a,e.eval_b));l=r.add(l,r.timesFr(i.Ql,e.eval_a)),l=r.add(l,r.timesFr(i.Qr,e.eval_b)),l=r.add(l,r.timesFr(i.Qo,e.eval_c)),l=r.add(l,i.Qc);let s=o.mul(a.beta,a.xi),u=o.add(o.add(e.eval_a,s),a.gamma),f=o.add(o.add(e.eval_b,o.mul(s,i.k1)),a.gamma),g=o.add(o.add(e.eval_c,o.mul(s,i.k2)),a.gamma),h=o.mul(o.mul(o.mul(u,f),g),a.alpha),w=o.mul(n,o.square(a.alpha)),c=r.timesFr(e.Z,o.add(o.add(h,w),a.u)),d=o.add(o.add(e.eval_a,o.mul(a.beta,e.eval_s1)),a.gamma),m=o.add(o.add(e.eval_b,o.mul(a.beta,e.eval_s2)),a.gamma),A=o.mul(o.mul(a.alpha,a.beta),e.eval_zw),p=r.timesFr(i.S3,o.mul(o.mul(d,m),A)),y=e.T1,I=r.timesFr(e.T2,a.xin),b=r.timesFr(e.T3,o.square(a.xin)),C=r.add(y,r.add(I,b));return C=r.timesFr(C,a.zh),r.sub(r.sub(r.add(l,c),p),C)}(o,u,f,n,g[1]);i&&i.debug("D: "+s.toString(s.toAffine(c),16));let d=function(t,e,a,i,n){let r=t.G1,o=r.add(n,r.timesFr(e.A,a.v[1]));return o=r.add(o,r.timesFr(e.B,a.v[2])),o=r.add(o,r.timesFr(e.C,a.v[3])),o=r.add(o,r.timesFr(i.S1,a.v[4])),o=r.add(o,r.timesFr(i.S2,a.v[5]))}(o,u,f,n,c);i&&i.debug("F: "+s.toString(s.toAffine(d),16));let m=function(t,e,a,i){let n=t.G1,r=t.Fr,o=r.add(r.neg(i),r.mul(a.v[1],e.eval_a));return o=r.add(o,r.mul(a.v[2],e.eval_b)),o=r.add(o,r.mul(a.v[3],e.eval_c)),o=r.add(o,r.mul(a.v[4],e.eval_s1)),o=r.add(o,r.mul(a.v[5],e.eval_s2)),o=r.add(o,r.mul(a.u,e.eval_zw)),n.timesFr(n.one,o)}(o,u,f,w);i&&i.debug("E: "+s.toString(s.toAffine(m),16));let A=await ad(o,u,f,n,m,d);return i&&(A?i.info("OK!"):i.warn("Invalid Proof")),A}async function ad(t,e,a,i,n,r){let o=t.G1,l=t.Fr,s=e.Wxi;s=o.add(s,o.timesFr(e.Wxiw,a.u));let u=o.timesFr(e.Wxi,a.xi),f=l.mul(l.mul(a.u,a.xi),l.w[i.power]);return u=o.add(u,o.timesFr(e.Wxiw,f)),u=o.add(u,r),u=o.sub(u,n),await t.pairingEq(o.neg(s),i.X_2,u,t.G2.one)}let{unstringifyBigInts:am}=l.utils;function aA(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`"0x${e}"`}var ap=Object.freeze({__proto__:null,setup:ae,fullProve:ah,prove:af,verify:ac,exportSolidityCallData:async function(t,e){let a=am(t),i=am(e);await M(a.curve);let n="";for(let t=0;t<i.length;t++)""!=n&&(n+=","),n+=aA(i[t]);return`[${aA(a.A[0])}, ${aA(a.A[1])},${aA(a.B[0])},${aA(a.B[1])},${aA(a.C[0])},${aA(a.C[1])},${aA(a.Z[0])},${aA(a.Z[1])},${aA(a.T1[0])},${aA(a.T1[1])},${aA(a.T2[0])},${aA(a.T2[1])},${aA(a.T3[0])},${aA(a.T3[1])},${aA(a.Wxi[0])},${aA(a.Wxi[1])},${aA(a.Wxiw[0])},${aA(a.Wxiw[1])},${aA(a.eval_a)},${aA(a.eval_b)},${aA(a.eval_c)},${aA(a.eval_s1)},${aA(a.eval_s2)},${aA(a.eval_zw)}][${n}]`}});function ay(t,e){return[t,0,0,e.one,e.zero,e.zero,e.zero,e.zero]}function aI(t,e,a,i,n,r,o,l){return[t,e,a,i,n,r,o,l]}function ab(t,e,a,i,n,r,o,l,s){return[t,e,a,i,n,r,o,l]}class aC{constructor(t,e,a,i,n){this.Fr=t,this.logger=n,this.fnGetAdditionConstraint=a,this.fnGetMultiplicationConstraint=i}processR1csConstraint(t,e,a,i){this.normalizeLinearCombination(e),this.normalizeLinearCombination(a),this.normalizeLinearCombination(i);let n=this.getLinearCombinationType(e),r=this.getLinearCombinationType(a);if(0===n||0===r)return this.processR1csAdditionConstraint(t,i);if(1===n){let n=this.joinLinearCombinations(a,i,e[0]);return this.processR1csAdditionConstraint(t,n)}if(1!==r)return this.processR1csMultiplicationConstraint(t,e,a,i);{let n=this.joinLinearCombinations(e,i,a[0]);return this.processR1csAdditionConstraint(t,n)}}getLinearCombinationType(t){let e=this.Fr.zero,a=0,i=Object.keys(t);for(let n=0;n<i.length;n++)0n==t[i[n]]?delete t[i[n]]:0==i[n]?e=this.Fr.add(e,t[i[n]]):a++;return a>0?2:this.Fr.isZero(e)?0:1}normalizeLinearCombination(t){let e=Object.keys(t);for(let a=0;a<e.length;a++)this.Fr.isZero(t[e[a]])&&delete t[e[a]];return t}joinLinearCombinations(t,e,a){let i={};for(let e in t)void 0===i[e]?i[e]=this.Fr.mul(a,t[e]):i[e]=this.Fr.add(i[e],this.Fr.mul(a,t[e]));for(let t in e)void 0===i[t]?i[t]=e[t]:i[t]=this.Fr.add(i[t],e[t]);return this.normalizeLinearCombination(i)}reduceCoefs(t,e,a,i,n){let r={k:this.Fr.zero,signals:[],coefs:[]},o=[];for(let t in i)0==t?r.k=this.Fr.add(r.k,i[t]):0n!=i[t]&&o.push([Number(t),i[t]]);for(;o.length>n;){let i=o.shift(),n=o.shift(),r=t.nVars++,l=this.fnGetAdditionConstraint(i[0],n[0],r,this.Fr.neg(i[1]),this.Fr.neg(n[1]),this.Fr.zero,this.Fr.one,this.Fr.zero);e.push(l),a.push([i[0],n[0],i[1],n[1]]),o.push([r,this.Fr.one])}for(let t=0;t<o.length;t++)r.signals[t]=o[t][0],r.coefs[t]=o[t][1];for(;r.coefs.length<n;)r.signals.push(0),r.coefs.push(this.Fr.zero);return r}processR1csAdditionConstraint(t,e){let a=[],i=[],n=this.reduceCoefs(t,a,i,e,3),r=this.fnGetAdditionConstraint(n.signals[0],n.signals[1],n.signals[2],n.coefs[0],n.coefs[1],this.Fr.zero,n.coefs[2],n.k);return a.push(r),[a,i]}processR1csMultiplicationConstraint(t,e,a,i){let n=[],r=[],o=this.reduceCoefs(t,n,r,e,1),l=this.reduceCoefs(t,n,r,a,1),s=this.reduceCoefs(t,n,r,i,1),u=this.fnGetMultiplicationConstraint(o.signals[0],l.signals[0],s.signals[0],this.Fr.mul(o.coefs[0],l.k),this.Fr.mul(o.k,l.coefs[0]),this.Fr.mul(o.coefs[0],l.coefs[0]),this.Fr.neg(s.coefs[0]),this.Fr.sub(this.Fr.mul(o.k,l.k),s.k));return n.push(u),[n,r]}}class aE{constructor(t,e,a){this.n=t,this.polynomials=Array(t).fill(void 0),this.curve=e,this.Fr=e.Fr,this.G1=e.G1,this.logger=a}addPolynomial(t,e){if(t>this.n-1)throw Error("CPolynomial:addPolynomial, cannot add a polynomial to a position greater than n-1");this.polynomials[t]=e}degree(){return Math.max(...this.polynomials.map((t,e)=>void 0===t?0:t.degree()*this.n+e))}getPolynomial(){let t=this.polynomials.map(t=>void 0===t?0:t.degree()),e=this.degree(),a=2**(tI(e-1)+1),i=this.Fr.n8,n=new al(new l.qc(a*i),this.curve,this.logger);for(let a=0;a<e;a++){let e=a*i,r=e*this.n;for(let o=0;o<this.n;o++)void 0!==this.polynomials[o]&&a<=t[o]&&n.coef.set(this.polynomials[o].coef.slice(e,e+i),r+o*i)}return n}async multiExponentiation(t,e){let a=this.getPolynomial(),i=a.coef.byteLength/this.Fr.n8,n=t.slice(0,i*this.G1.F.n8*2),r=await this.Fr.batchFromMontgomery(a.coef),o=await this.G1.multiExpAffine(n,r,this.logger,e);return this.G1.toAffine(o)}}async function aS(t,e,a,i){let n,r,o;i&&i.info("FFLONK SETUP STARTED"),globalThis.gc&&globalThis.gc(),i&&i.info("> Reading PTau file");let{fd:s,sections:u}=await S(e,"ptau",1);if(!u[12])throw Error("Powers of Tau is not well prepared. Section 12 missing.");i&&i.info("> Getting curve from PTau settings");let{curve:f}=await eg(s,u);i&&i.info("> Reading r1cs file");let{fd:g,sections:h}=await S(t,"r1cs",1),w=await eU(g,h,{loadConstraints:!1,loadCustomGates:!0});if(w.prime!==f.r)throw Error("r1cs curve does not match powers of tau ceremony curve");let c=f.Fr,d=f.Fr.n8,m=2*f.G1.F.n8,A=2*f.G2.F.n8,p={},y={},I={nVars:w.nVars,nPublic:w.nOutputs+w.nPubInputs},b=new eK,C=new eK;if(i&&i.info("> Processing FFlonk constraints"),await z(f.Fr,w,i),globalThis.gc&&globalThis.gc(),I.cirPower=Math.max(3,tI(b.length+2-1)+1),I.domainSize=2**I.cirPower,u[2][0].size<(9*I.domainSize+18)*m)throw Error("Powers of Tau is not big enough for this circuit size. Section 2 too small.");if(u[3][0].size<A)throw Error("Powers of Tau is not well prepared. Section 3 too small.");i&&(i.info("----------------------------"),i.info("  FFLONK SETUP SETTINGS"),i.info(`  Curve:         ${f.name}`),i.info(`  Circuit power: ${I.cirPower}`),i.info(`  Domain size:   ${I.domainSize}`),i.info(`  Vars:          ${I.nVars}`),i.info(`  Public vars:   ${I.nPublic}`),i.info(`  Constraints:   ${b.length}`),i.info(`  Additions:     ${C.length}`),i.info("----------------------------")),i&&i.info("> computing k1 and k2");let[E,G]=function(){let t=c.two;for(;a(t,[],I.cirPower);)c.add(t,c.one);let e=c.add(t,c.one);for(;a(e,[t],I.cirPower);)c.add(e,c.one);return[t,e];function a(t,e,a){let i=2**a,n=c.one;for(let r=0;r<i;r++){if(c.eq(t,n))return!0;for(let a=0;a<e.length;a++)if(c.eq(t,c.mul(e[a],n)))return!0;n=c.mul(n,c.w[a])}return!1}}();i&&i.info("> computing w3");let Q=(r=c.e(31624),o=l.Ru.div(0x810b7bdd032f006f40d60f3c0403964dc08a6b6bef43d6d8b505398a8000000n,l.Ru.e(3)),c.exp(r,o));i&&i.info("> computing w4");let L=c.w[2];i&&i.info("> computing w8");let U=c.w[3];i&&i.info("> computing wr");let T=function(t,e){let a=e.e(0x108c3d36f14c2facdf4d615f022a01cfcf001cc24e3db9d89373caf21d767f0n);return e.exp(a,2**(28-t))}(I.cirPower,f.Fr);return await P(),await g.close(),await s.close(),i&&i.info("FFLONK SETUP FINISHED"),0;async function z(t,e,a){for(let e=0;e<I.nPublic;e++)b.push(ay(e+1,t));let i=new aC(t,ay,aI,ab,a),n=await _(g,h,2),r=0;for(let t=0;t<e.nConstraints;t++){a&&0!==t&&t%5e5==0&&a.info(`    processing r1cs constraints ${t}/${e.nConstraints}`);let[n,r]=i.processR1csConstraint(I,...function(){let t=[];return t[0]=o(),t[1]=o(),t[2]=o(),t}());b.push(...n),C.push(...r)}function o(){let t={},a=n.slice(r,r+4);r+=4;let i=new DataView(a.buffer).getUint32(0,!0),o=n.slice(r,r+(4+e.n8)*i);r+=(4+e.n8)*i;let l=new DataView(o.buffer);for(let a=0;a<i;a++){let i=l.getUint32(a*(4+e.n8),!0),n=e.F.fromRprLE(o,a*(4+e.n8)+4);t[i]=n}return t}return 0}async function P(){i&&i.info("> Writing the zkey file");let t=await v(a,"zkey",1,17,4194304,16777216);i&&i.info(`\xb7\xb7\xb7 Writing Section 1. Zkey Header`),await D(t),i&&i.info(`\xb7\xb7\xb7 Writing Section 3. Additions`),await R(t),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 4. A Map`),await k(t,4,0,"A map"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 5. B Map`),await k(t,5,1,"B map"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 6. C Map`),await k(t,6,2,"C map"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 7. QL`),await O(t,7,3,"QL"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 8. QR`),await O(t,8,4,"QR"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 9. QM`),await O(t,9,5,"QM"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 10. QO`),await O(t,10,6,"QO"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 11. QC`),await O(t,11,7,"QC"),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Sections 12,13,14. Sigma1, Sigma2 & Sigma 3`),await M(t),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 15. Lagrange Polynomials`),await V(t),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 16. Powers of Tau`),await q(t),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 17. C0`),await K(t),globalThis.gc&&globalThis.gc(),i&&i.info(`\xb7\xb7\xb7 Writing Section 2. FFlonk Header`),await $(t),globalThis.gc&&globalThis.gc(),i&&i.info("> Writing the zkey file finished"),await t.close()}async function D(t){await F(t,1),await t.writeULE32(10),await B(t)}async function R(t){await F(t,3);let e=new Uint8Array(8+2*d),a=new DataView(e.buffer);for(let n=0;n<C.length;n++){i&&0!==n&&n%5e5==0&&i.info(`      writing Additions: ${n}/${C.length}`);let r=C[n];a.setUint32(0,r[0],!0),a.setUint32(4,r[1],!0),e.set(r[2],8),e.set(r[3],8+d),await t.write(e)}await B(t)}async function k(t,e,a,n){await F(t,e);for(let e=0;e<b.length;e++)i&&0!==e&&e%5e5==0&&i.info(`      writing witness ${n}: ${e}/${b.length}`),await t.writeULE32(b[e][a]);await B(t)}async function O(t,e,a,n){let r=new l.qc(I.domainSize*d);for(let t=0;t<b.length;t++)r.set(b[t][a],t*d),i&&0!==t&&t%5e5==0&&i.info(`      writing ${n}: ${t}/${b.length}`);p[n]=await al.fromEvaluations(r,f,i),y[n]=await as.fromPolynomial(p[n],4,f,i),await F(t,e),await t.write(p[n].coef),await t.write(y[n].eval),await B(t)}async function M(t){let e=new l.qc(d*I.domainSize*3),a=new eK(I.nVars),n=new eK(I.nVars),r=c.one;for(let t=0;t<I.domainSize;t++)t<b.length?(o(b[t][0],t),o(b[t][1],I.domainSize+t),o(b[t][2],2*I.domainSize+t)):t<I.domainSize-2?(o(0,t),o(0,I.domainSize+t),o(0,2*I.domainSize+t)):(e.set(r,t*d),e.set(c.mul(r,E),(I.domainSize+t)*d),e.set(c.mul(r,G),(2*I.domainSize+t)*d)),r=c.mul(r,c.w[I.cirPower]),i&&0!==t&&t%5e5==0&&i.info(`      writing sigma phase1: ${t}/${b.length}`);for(let t=0;t<I.nVars;t++)void 0!==n[t]?e.set(a[t],n[t]*d):console.log("Variable not used"),i&&0!==t&&t%5e5==0&&i.info(`      writing sigma phase2: ${t}/${I.nVars}`);globalThis.gc&&globalThis.gc();for(let a=0;a<3;a++){let n=0===a?12:1===a?13:14,r="S"+(a+1);p[r]=await al.fromEvaluations(e.slice(I.domainSize*d*a,I.domainSize*d*(a+1)),f,i),y[r]=await as.fromPolynomial(p[r],4,f,i),await F(t,n),await t.write(p[r].coef),await t.write(y[r].eval),await B(t),globalThis.gc&&globalThis.gc()}return 0;function o(t,i){let o;void 0===a[t]?n[t]=i:e.set(a[t],i*d),o=i<I.domainSize?r:i<2*I.domainSize?c.mul(r,E):c.mul(r,G),a[t]=o}}async function V(t){await F(t,15);let e=Math.max(I.nPublic,1);for(let a=0;a<e;a++){let e=new l.qc(I.domainSize*d);e.set(c.one,a*d),await H(t,e)}await B(t)}async function q(t){await F(t,16),n=new l.qc((9*I.domainSize+18)*m),await s.readToBuffer(n,0,(9*I.domainSize+18)*m,u[2][0].p),await t.write(n),await B(t)}async function K(t){let e=new aE(8,f,i);if(e.addPolynomial(0,p.QL),e.addPolynomial(1,p.QR),e.addPolynomial(2,p.QO),e.addPolynomial(3,p.QM),e.addPolynomial(4,p.QC),e.addPolynomial(5,p.S1),e.addPolynomial(6,p.S2),e.addPolynomial(7,p.S3),p.C0=e.getPolynomial(),p.C0.degree()>=8*I.domainSize)throw Error("C0 Polynomial is not well calculated");await F(t,17),await t.write(p.C0.coef),await B(t)}async function $(t){let e;await F(t,2);let a=f.q,i=(Math.floor((l.Ru.bitLength(a)-1)/64)+1)*8;await t.writeULE32(i),await x(t,a,i);let r=f.r,o=(Math.floor((l.Ru.bitLength(r)-1)/64)+1)*8;await t.writeULE32(o),await x(t,r,o),await t.writeULE32(I.nVars),await t.writeULE32(I.nPublic),await t.writeULE32(I.domainSize),await t.writeULE32(C.length),await t.writeULE32(b.length),await t.write(E),await t.write(G),await t.write(Q),await t.write(L),await t.write(U),await t.write(T),e=await s.read(A,u[3][0].p+A),await t.write(e);let g=await p.C0.multiExponentiation(n,"C0");await t.write(g),await B(t)}async function H(t,e){let[a,i]=await al.to4T(e,I.domainSize,[],c);return await t.write(a),await t.write(i),[a,i]}}let{stringifyBigInts:av}=l.utils;async function aF(t,e,a,i){a&&a.info("FFLONK PROVER STARTED"),a&&a.info("> Reading witness file");let{fd:n,sections:r}=await S(e,"wtns",2),o=await tY(n,r);a&&a.info("> Reading zkey file");let{fd:s,sections:u}=await S(t,"zkey",2),f=await tD(s,u,void 0,i);if(10!==f.protocolId)throw Error("zkey file is not fflonk");if(!l.Ru.eq(f.r,o.q))throw Error("Curve of the witness does not match the curve of the proving key");if(o.nWitness!==f.nVars-f.nAdditions)throw Error(`Invalid witness length. Circuit: ${f.nVars}, witness: ${o.nWitness}, ${f.nAdditions}`);let g=f.curve,h=g.Fr,w=g.Fr.n8,c=2*g.G1.F.n8,d=f.domainSize*w;a&&(a.info("----------------------------"),a.info("  FFLONK PROVE SETTINGS"),a.info(`  Curve:         ${g.name}`),a.info(`  Circuit power: ${f.power}`),a.info(`  Domain size:   ${f.domainSize}`),a.info(`  Vars:          ${f.nVars}`),a.info(`  Public vars:   ${f.nPublic}`),a.info(`  Constraints:   ${f.nConstraints}`),a.info(`  Additions:     ${f.nAdditions}`),a.info("----------------------------")),a&&a.info("> Reading witness file data");let m=await _(n,r,2);await n.close(),m.set(h.zero,0);let A=new l.qc(f.nAdditions*w),p={},y={},I={},b={},C={},E={},v=new aa(g,a);a&&a.info("> Reading Section 3. Additions"),await Q(),a&&a.info("> Reading Sections 12,13,14. Sigma1, Sigma2 & Sigma 3"),a&&a.info("\xb7\xb7\xb7 Reading Sigma polynomials "),y.Sigma1=new al(new l.qc(d),g,a),y.Sigma2=new al(new l.qc(d),g,a),y.Sigma3=new al(new l.qc(d),g,a),await s.readToBuffer(y.Sigma1.coef,0,d,u[12][0].p),await s.readToBuffer(y.Sigma2.coef,0,d,u[13][0].p),await s.readToBuffer(y.Sigma3.coef,0,d,u[14][0].p),a&&a.info("\xb7\xb7\xb7 Reading Sigma evaluations"),I.Sigma1=new as(new l.qc(4*d),g,a),I.Sigma2=new as(new l.qc(4*d),g,a),I.Sigma3=new as(new l.qc(4*d),g,a),await s.readToBuffer(I.Sigma1.eval,0,4*d,u[12][0].p+d),await s.readToBuffer(I.Sigma2.eval,0,4*d,u[13][0].p+d),await s.readToBuffer(I.Sigma3.eval,0,4*d,u[14][0].p+d),a&&a.info("> Reading Section 16. Powers of Tau");let F=new l.qc(16*f.domainSize*c);await s.readToBuffer(F,0,(9*f.domainSize+18)*c,u[16][0].p),globalThis.gc&&globalThis.gc(),a&&a.info(""),a&&a.info("> ROUND 1"),await U(),delete y.T0,delete I.QL,delete I.QR,delete I.QM,delete I.QO,delete I.QC,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 2"),await T(),delete p.A,delete p.B,delete p.C,delete I.A,delete I.B,delete I.C,delete I.Sigma1,delete I.Sigma2,delete I.Sigma3,delete I.lagrange1,delete I.Z,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 3"),await z(),delete y.A,delete y.B,delete y.C,delete y.Z,delete y.T1,delete y.T2,delete y.Sigma1,delete y.Sigma2,delete y.Sigma3,delete y.QL,delete y.QR,delete y.QM,delete y.QC,delete y.QO,globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 4"),await P(),globalThis.gc&&globalThis.gc(),a&&a.info("> ROUND 5"),await D(),delete y.C0,delete y.C1,delete y.C2,delete y.R1,delete y.R2,delete y.F,delete y.L,delete y.ZT,delete y.ZTS2,await s.close(),globalThis.gc&&globalThis.gc(),v.addEvaluation("inv",function(){let t=C.xi;for(let e=0;e<f.power;e++)t=h.square(t);b.zh=h.sub(t,h.one),function(t,e,a,i){let n=i.Fr,r=e.length,o=n.mul(n.e(r),n.exp(e[0],r-2));for(let i=0;i<r;i++){let l=e[(r-1)*i%r],s=n.sub(a,e[i]);t[["LiS0_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(b,E.S0.h0w8,C.y,g),function(t,e,a,i){let n=i.Fr,r=e.length,o=n.mul(n.e(r),n.exp(e[0],r-2));for(let i=0;i<r;i++){let l=e[(r-1)*i%r],s=n.sub(a,e[i]);t[["LiS1_"+(i+1)]]=n.mul(n.mul(o,l),s)}}(b,E.S1.h1w4,C.y,g),function(t,e,a,i,n,r,o){let l=o.Fr,s=l.mul(l.e(3),e[0]),u=l.sub(n,r),f=l.mul(s,u);for(let a=0;a<3;a++){let n=e[2*a%3],r=l.sub(i,e[a]);t[["LiS2_"+(a+1)]]=l.mul(f,l.mul(n,r))}let g=l.mul(l.e(3),a[0]),h=l.sub(r,n);f=l.mul(g,h);for(let e=0;e<3;e++){let n=a[2*e%3],r=l.sub(i,a[e]);t[["LiS2_"+(e+1+3)]]=l.mul(f,l.mul(n,r))}}(b,E.S2.h2w3,E.S2.h3w3,C.y,C.xi,C.xiw,g);let e=Math.max(1,f.nPublic),a=h.one;for(let t=0;t<e;t++)b["Li_"+(t+1)]=h.mul(h.e(f.domainSize),h.sub(C.xi,a)),a=h.mul(a,h.w[f.power]);let i=h.one;for(let t of Object.values(b))if(Array.isArray(t))for(let e of t)i=h.mul(i,e);else i=h.mul(i,t);return h.inv(i)}());let B=v.toObjectProof();B.protocol="fflonk",B.curve=g.name;let G=[];for(let t=1;t<=f.nPublic;t++){let e=t*w,a=m.slice(e,e+w);G.push(l.Ru.fromRprLE(a))}return a&&a.info("FFLONK PROVER FINISHED"),{proof:av(B),publicSignals:av(G)};async function Q(){a&&a.info("\xb7\xb7\xb7 Computing additions");let t=await _(s,u,3),e=8+2*w;for(let i=0;i<f.nAdditions;i++){a&&0!==i&&i%1e5==0&&a.info(`    addition ${i}/${f.nAdditions}`);let n=i*e,r=x(t,n),o=x(t,n+=4);n+=4;let l=t.slice(n,n+w);n+=w;let s=t.slice(n,n+w),u=L(r),g=L(o),c=h.add(h.mul(l,u),h.mul(s,g));A.set(c,w*i)}}function x(t,e){let a=t.slice(e,e+4);return new DataView(a.buffer,a.byteOffset,a.byteLength).getUint32(0,!0)}function L(t){let e=f.nVars-f.nAdditions;if(t<e)return m.slice(t*w,t*w+w);if(t<f.nVars){let a=(t-e)*w;return A.slice(a,a+w)}return h.zero}async function U(){C.b=[];for(let t=1;t<=9;t++)C.b[t]=h.random();a&&a.info("> Computing A, B, C wire polynomials"),await e(),a&&a.info("> Computing T0 polynomial"),await i(),a&&a.info("> Computing C1 polynomial"),await n(),a&&a.info("> Computing C1 multi exponentiation");let t=await y.C1.multiExponentiation(F,"C1");return v.addPolynomial("C1",t),0;async function e(){a&&a.info("\xb7\xb7\xb7 Reading data from zkey file"),p.A=new l.qc(d),p.B=new l.qc(d),p.C=new l.qc(d);let t=await _(s,u,4),e=await _(s,u,5),i=await _(s,u,6);for(let a=0;a<f.nConstraints;a++){let n=a*w,r=4*a,o=x(t,r);p.A.set(L(o),n);let l=x(e,r);p.B.set(L(l),n);let s=x(i,r);p.C.set(L(s),n)}if(p.A.set(C.b[1],d-64),p.A.set(C.b[2],d-32),p.B.set(C.b[3],d-64),p.B.set(C.b[4],d-32),p.C.set(C.b[5],d-64),p.C.set(C.b[6],d-32),p.A=await h.batchToMontgomery(p.A),p.B=await h.batchToMontgomery(p.B),p.C=await h.batchToMontgomery(p.C),a&&a.info("\xb7\xb7\xb7 Computing A ifft"),y.A=await al.fromEvaluations(p.A,g,a),a&&a.info("\xb7\xb7\xb7 Computing B ifft"),y.B=await al.fromEvaluations(p.B,g,a),a&&a.info("\xb7\xb7\xb7 Computing C ifft"),y.C=await al.fromEvaluations(p.C,g,a),a&&a.info("\xb7\xb7\xb7 Computing A fft"),I.A=await as.fromPolynomial(y.A,4,g,a),a&&a.info("\xb7\xb7\xb7 Computing B fft"),I.B=await as.fromPolynomial(y.B,4,g,a),a&&a.info("\xb7\xb7\xb7 Computing C fft"),I.C=await as.fromPolynomial(y.C,4,g,a),y.A.degree()>=f.domainSize)throw Error("A Polynomial is not well calculated");if(y.B.degree()>=f.domainSize)throw Error("B Polynomial is not well calculated");if(y.C.degree()>=f.domainSize)throw Error("C Polynomial is not well calculated")}async function i(){a&&a.info(`\xb7\xb7\xb7 Reading sections 7, 8, 9, 10, 11. Q selectors`),I.QL=new as(new l.qc(4*d),g,a),I.QR=new as(new l.qc(4*d),g,a),I.QM=new as(new l.qc(4*d),g,a),I.QO=new as(new l.qc(4*d),g,a),I.QC=new as(new l.qc(4*d),g,a),await s.readToBuffer(I.QL.eval,0,4*d,u[7][0].p+d),await s.readToBuffer(I.QR.eval,0,4*d,u[8][0].p+d),await s.readToBuffer(I.QM.eval,0,4*d,u[9][0].p+d),await s.readToBuffer(I.QO.eval,0,4*d,u[10][0].p+d),await s.readToBuffer(I.QC.eval,0,4*d,u[11][0].p+d);let t=await _(s,u,15);I.lagrange1=new as(t,g,a),p.T0=new l.qc(4*d),a&&a.info("\xb7\xb7\xb7 Computing T0 evaluations");for(let t=0;t<4*f.domainSize;t++){a&&0!==t&&t%1e5==0&&a.info(`      T0 evaluation ${t}/${4*f.domainSize}`);let e=I.A.getEvaluation(t),i=I.B.getEvaluation(t),n=I.C.getEvaluation(t),r=I.QL.getEvaluation(t),o=I.QR.getEvaluation(t),l=I.QM.getEvaluation(t),s=I.QO.getEvaluation(t),u=I.QC.getEvaluation(t),g=h.zero;for(let e=0;e<f.nPublic;e++){let a=5*e*f.domainSize+f.domainSize+t,i=I.lagrange1.getEvaluation(a),n=p.A.slice(e*w,(e+1)*w);g=h.sub(g,h.mul(i,n))}let c=h.mul(e,r),d=h.mul(i,o),m=h.mul(h.mul(e,i),l),A=h.mul(n,s),y=h.add(c,h.add(d,h.add(m,h.add(A,h.add(u,g)))));p.T0.set(y,t*w)}if(a&&a.info("buffer T0: "+p.T0.byteLength/w),a&&a.info("\xb7\xb7\xb7 Computing T0 ifft"),y.T0=await al.fromEvaluations(p.T0,g,a),a&&a.info("T0 length: "+y.T0.length()),a&&a.info("T0 degree: "+y.T0.degree()),a&&a.info("\xb7\xb7\xb7 Computing T0 / ZH"),y.T0.divByZerofier(f.domainSize,h.one),y.T0.degree()>=2*f.domainSize-2)throw Error(`T0 Polynomial is not well calculated (degree is ${y.T0.degree()} and must be less than ${2*f.domainSize+2}`);delete p.T0}async function n(){let t=new aE(4,g,a);if(t.addPolynomial(0,y.A),t.addPolynomial(1,y.B),t.addPolynomial(2,y.C),t.addPolynomial(3,y.T0),y.C1=t.getPolynomial(),y.C1.degree()>=8*f.domainSize-8)throw Error("C1 Polynomial is not well calculated")}}async function T(){a&&a.info("> Computing challenges beta and gamma");let t=new ar(g);t.addPolCommitment(f.C0);for(let e=0;e<f.nPublic;e++)t.addScalar(p.A.slice(e*w,e*w+w));t.addPolCommitment(v.getPolynomial("C1")),C.beta=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.beta: "+h.toString(C.beta)),t.reset(),t.addScalar(C.beta),C.gamma=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.gamma: "+h.toString(C.gamma)),a&&a.info("> Computing Z polynomial"),await i(),a&&a.info("> Computing T1 polynomial"),await n(),a&&a.info("> Computing T2 polynomial"),await r(),a&&a.info("> Computing C2 polynomial"),await o(),a&&a.info("> Computing C2 multi exponentiation");let e=await y.C2.multiExponentiation(F,"C2");return v.addPolynomial("C2",e),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing Z evaluations");let t=new l.qc(d),e=new l.qc(d);t.set(h.one,0),e.set(h.one,0);let i=h.one;for(let n=0;n<f.domainSize;n++){a&&0!==n&&n%1e5==0&&a.info(`    Z evaluation ${n}/${f.domainSize}`);let r=n*w,o=h.mul(C.beta,i),l=p.A.slice(r,r+w);l=h.add(l,o),l=h.add(l,C.gamma);let s=p.B.slice(r,r+w);s=h.add(s,h.mul(f.k1,o)),s=h.add(s,C.gamma);let u=p.C.slice(r,r+w);u=h.add(u,h.mul(f.k2,o)),u=h.add(u,C.gamma);let g=h.mul(l,h.mul(s,u)),c=p.A.slice(r,r+w);c=h.add(c,h.mul(C.beta,I.Sigma1.getEvaluation(4*n))),c=h.add(c,C.gamma);let d=p.B.slice(r,r+w);d=h.add(d,h.mul(C.beta,I.Sigma2.getEvaluation(4*n))),d=h.add(d,C.gamma);let m=p.C.slice(r,r+w);m=h.add(m,h.mul(C.beta,I.Sigma3.getEvaluation(4*n))),m=h.add(m,C.gamma);let A=h.mul(c,h.mul(d,m));g=h.mul(t.slice(r,r+w),g),t.set(g,(n+1)%f.domainSize*w),A=h.mul(e.slice(r,r+w),A),e.set(A,(n+1)%f.domainSize*w),i=h.mul(i,h.w[f.power])}e=await h.batchInverse(e);for(let a=0;a<f.domainSize;a++){let i=a*w,n=h.mul(t.slice(i,i+w),e.slice(i,i+w));t.set(n,i)}if(p.Z=t,!h.eq(t.slice(0,w),h.one))throw Error("Copy constraints does not match");if(a&&a.info("\xb7\xb7\xb7 Computing Z ifft"),y.Z=await al.fromEvaluations(p.Z,g,a),a&&a.info("\xb7\xb7\xb7 Computing Z fft"),I.Z=await as.fromPolynomial(y.Z,4,g,a),y.Z.blindCoefficients([C.b[9],C.b[8],C.b[7]]),y.Z.degree()>=f.domainSize+3)throw Error("Z Polynomial is not well calculated");delete p.Z}async function n(){a&&a.info("\xb7\xb7\xb7 Computing T1 evaluations"),p.T1=new l.qc(2*d),p.T1z=new l.qc(2*d);let t=h.one;for(let e=0;e<2*f.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`    T1 evaluation ${e}/${4*f.domainSize}`);let i=h.square(t),n=I.Z.getEvaluation(2*e),r=h.add(h.add(h.mul(C.b[7],i),h.mul(C.b[8],t)),C.b[9]),o=I.lagrange1.getEvaluation(f.domainSize+2*e),l=h.mul(h.sub(n,h.one),o),s=h.mul(r,o);p.T1.set(l,e*w),p.T1z.set(s,e*w),t=h.mul(t,h.w[f.power+1])}if(a&&a.info("\xb7\xb7\xb7 Computing T1 ifft"),y.T1=await al.fromEvaluations(p.T1,g,a),y.T1.divByZerofier(f.domainSize,h.one),a&&a.info("\xb7\xb7\xb7 Computing T1z ifft"),y.T1z=await al.fromEvaluations(p.T1z,g,a),y.T1.add(y.T1z),y.T1.degree()>=f.domainSize+2)throw Error("T1 Polynomial is not well calculated");delete p.T1,delete p.T1z,delete y.T1z}async function r(){a&&a.info("\xb7\xb7\xb7 Computing T2 evaluations"),p.T2=new l.qc(4*d),p.T2z=new l.qc(4*d);let t=h.one;for(let e=0;e<4*f.domainSize;e++){a&&0!==e&&e%1e5==0&&a.info(`    T2 evaluation ${e}/${4*f.domainSize}`);let i=h.square(t),n=h.mul(t,h.w[f.power]),r=h.square(n),o=I.A.getEvaluation(e),l=I.B.getEvaluation(e),s=I.C.getEvaluation(e),u=I.Z.getEvaluation(e),g=I.Z.getEvaluation((4*f.domainSize+4+e)%(4*f.domainSize)),c=h.add(h.add(h.mul(C.b[7],i),h.mul(C.b[8],t)),C.b[9]),d=h.add(h.add(h.mul(C.b[7],r),h.mul(C.b[8],n)),C.b[9]),m=I.Sigma1.getEvaluation(e),A=I.Sigma2.getEvaluation(e),y=I.Sigma3.getEvaluation(e),b=h.mul(C.beta,t),E=h.add(o,b);E=h.add(E,C.gamma);let S=h.add(l,h.mul(b,f.k1));S=h.add(S,C.gamma);let v=h.add(s,h.mul(b,f.k2));v=h.add(v,C.gamma);let F=h.mul(h.mul(h.mul(E,S),v),u),B=h.mul(h.mul(h.mul(E,S),v),c),G=h.add(o,h.mul(C.beta,m));G=h.add(G,C.gamma);let Q=h.add(l,h.mul(C.beta,A));Q=h.add(Q,C.gamma);let x=h.add(s,h.mul(C.beta,y));x=h.add(x,C.gamma);let L=h.mul(h.mul(h.mul(G,Q),x),g),U=h.mul(h.mul(h.mul(G,Q),x),d),_=h.sub(F,L),T=h.sub(B,U);p.T2.set(_,e*w),p.T2z.set(T,e*w),t=h.mul(t,h.w[f.power+2])}if(a&&a.info("\xb7\xb7\xb7 Computing T2 ifft"),y.T2=await al.fromEvaluations(p.T2,g,a),a&&a.info("\xb7\xb7\xb7 Computing T2 / ZH"),y.T2.divByZerofier(f.domainSize,h.one),a&&a.info("\xb7\xb7\xb7 Computing T2z ifft"),y.T2z=await al.fromEvaluations(p.T2z,g,a),y.T2.add(y.T2z),y.T2.degree()>=3*f.domainSize)throw Error("T2 Polynomial is not well calculated");delete p.T2,delete p.T2z,delete y.T2z}async function o(){let t=new aE(3,g,a);if(t.addPolynomial(0,y.Z),t.addPolynomial(1,y.T1),t.addPolynomial(2,y.T2),y.C2=t.getPolynomial(),y.C2.degree()>=9*f.domainSize)throw Error("C2 Polynomial is not well calculated")}}async function z(){a&&a.info("> Computing challenge xi");let t=new ar(g);t.addScalar(C.gamma),t.addPolCommitment(v.getPolynomial("C2")),C.xiSeed=t.getChallenge();let e=h.square(C.xiSeed);E.w8=[],E.w8[0]=h.one;for(let t=1;t<8;t++)E.w8[t]=h.mul(E.w8[t-1],f.w8);E.w4=[],E.w4[0]=h.one;for(let t=1;t<4;t++)E.w4[t]=h.mul(E.w4[t-1],f.w4);E.w3=[],E.w3[0]=h.one,E.w3[1]=f.w3,E.w3[2]=h.square(f.w3),E.S0={},E.S0.h0w8=[],E.S0.h0w8[0]=h.mul(e,C.xiSeed);for(let t=1;t<8;t++)E.S0.h0w8[t]=h.mul(E.S0.h0w8[0],E.w8[t]);E.S1={},E.S1.h1w4=[],E.S1.h1w4[0]=h.square(E.S0.h0w8[0]);for(let t=1;t<4;t++)E.S1.h1w4[t]=h.mul(E.S1.h1w4[0],E.w4[t]);E.S2={},E.S2.h2w3=[],E.S2.h2w3[0]=h.mul(E.S1.h1w4[0],e),E.S2.h2w3[1]=h.mul(E.S2.h2w3[0],E.w3[1]),E.S2.h2w3[2]=h.mul(E.S2.h2w3[0],E.w3[2]),E.S2.h3w3=[],E.S2.h3w3[0]=h.mul(E.S2.h2w3[0],f.wr),E.S2.h3w3[1]=h.mul(E.S2.h3w3[0],E.w3[1]),E.S2.h3w3[2]=h.mul(E.S2.h3w3[0],E.w3[2]),C.xi=h.mul(h.square(E.S2.h2w3[0]),E.S2.h2w3[0]),a&&a.info("\xb7\xb7\xb7 challenges.xi: "+h.toString(C.xi)),y.QL=new al(new l.qc(d),g,a),y.QR=new al(new l.qc(d),g,a),y.QM=new al(new l.qc(d),g,a),y.QO=new al(new l.qc(d),g,a),y.QC=new al(new l.qc(d),g,a),await s.readToBuffer(y.QL.coef,0,d,u[7][0].p),await s.readToBuffer(y.QR.coef,0,d,u[8][0].p),await s.readToBuffer(y.QM.coef,0,d,u[9][0].p),await s.readToBuffer(y.QO.coef,0,d,u[10][0].p),await s.readToBuffer(y.QC.coef,0,d,u[11][0].p),a&&a.info("\xb7\xb7\xb7 Computing evaluations"),v.addEvaluation("ql",y.QL.evaluate(C.xi)),v.addEvaluation("qr",y.QR.evaluate(C.xi)),v.addEvaluation("qm",y.QM.evaluate(C.xi)),v.addEvaluation("qo",y.QO.evaluate(C.xi)),v.addEvaluation("qc",y.QC.evaluate(C.xi)),v.addEvaluation("s1",y.Sigma1.evaluate(C.xi)),v.addEvaluation("s2",y.Sigma2.evaluate(C.xi)),v.addEvaluation("s3",y.Sigma3.evaluate(C.xi)),v.addEvaluation("a",y.A.evaluate(C.xi)),v.addEvaluation("b",y.B.evaluate(C.xi)),v.addEvaluation("c",y.C.evaluate(C.xi)),v.addEvaluation("z",y.Z.evaluate(C.xi)),C.xiw=h.mul(C.xi,h.w[f.power]),v.addEvaluation("zw",y.Z.evaluate(C.xiw)),v.addEvaluation("t1w",y.T1.evaluate(C.xiw)),v.addEvaluation("t2w",y.T2.evaluate(C.xiw))}async function P(){a&&a.info("> Computing challenge alpha");let t=new ar(g);t.addScalar(C.xiSeed),t.addScalar(v.getEvaluation("ql")),t.addScalar(v.getEvaluation("qr")),t.addScalar(v.getEvaluation("qm")),t.addScalar(v.getEvaluation("qo")),t.addScalar(v.getEvaluation("qc")),t.addScalar(v.getEvaluation("s1")),t.addScalar(v.getEvaluation("s2")),t.addScalar(v.getEvaluation("s3")),t.addScalar(v.getEvaluation("a")),t.addScalar(v.getEvaluation("b")),t.addScalar(v.getEvaluation("c")),t.addScalar(v.getEvaluation("z")),t.addScalar(v.getEvaluation("zw")),t.addScalar(v.getEvaluation("t1w")),t.addScalar(v.getEvaluation("t2w")),C.alpha=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.alpha: "+h.toString(C.alpha)),a&&a.info("> Reading C0 polynomial"),y.C0=new al(new l.qc(8*d),g,a),await s.readToBuffer(y.C0.coef,0,8*d,u[17][0].p),a&&a.info("> Computing R0 polynomial"),function(){if(y.R0=al.lagrangePolynomialInterpolation([E.S0.h0w8[0],E.S0.h0w8[1],E.S0.h0w8[2],E.S0.h0w8[3],E.S0.h0w8[4],E.S0.h0w8[5],E.S0.h0w8[6],E.S0.h0w8[7]],[y.C0.evaluate(E.S0.h0w8[0]),y.C0.evaluate(E.S0.h0w8[1]),y.C0.evaluate(E.S0.h0w8[2]),y.C0.evaluate(E.S0.h0w8[3]),y.C0.evaluate(E.S0.h0w8[4]),y.C0.evaluate(E.S0.h0w8[5]),y.C0.evaluate(E.S0.h0w8[6]),y.C0.evaluate(E.S0.h0w8[7])],g),y.R0.degree()>7)throw Error("R0 Polynomial is not well calculated")}(),a&&a.info("> Computing R1 polynomial"),function(){if(y.R1=al.lagrangePolynomialInterpolation([E.S1.h1w4[0],E.S1.h1w4[1],E.S1.h1w4[2],E.S1.h1w4[3]],[y.C1.evaluate(E.S1.h1w4[0]),y.C1.evaluate(E.S1.h1w4[1]),y.C1.evaluate(E.S1.h1w4[2]),y.C1.evaluate(E.S1.h1w4[3])],g),y.R1.degree()>3)throw Error("R1 Polynomial is not well calculated")}(),a&&a.info("> Computing R2 polynomial"),function(){if(y.R2=al.lagrangePolynomialInterpolation([E.S2.h2w3[0],E.S2.h2w3[1],E.S2.h2w3[2],E.S2.h3w3[0],E.S2.h3w3[1],E.S2.h3w3[2]],[y.C2.evaluate(E.S2.h2w3[0]),y.C2.evaluate(E.S2.h2w3[1]),y.C2.evaluate(E.S2.h2w3[2]),y.C2.evaluate(E.S2.h3w3[0]),y.C2.evaluate(E.S2.h3w3[1]),y.C2.evaluate(E.S2.h3w3[2])],g),y.R2.degree()>5)throw Error("R2 Polynomial is not well calculated")}(),a&&a.info("> Computing F polynomial"),await i(),a&&a.info("> Computing W1 multi exponentiation");let e=await y.F.multiExponentiation(F,"W1");return v.addPolynomial("W1",e),0;async function i(){a&&a.info("\xb7\xb7\xb7 Computing F polynomial"),y.F=al.fromPolynomial(y.C0,g,a),y.F.sub(y.R0),y.F.divByZerofier(8,C.xi);let t=al.fromPolynomial(y.C1,g,a);t.sub(y.R1),t.mulScalar(C.alpha),t.divByZerofier(4,C.xi);let e=al.fromPolynomial(y.C2,g,a);if(e.sub(y.R2),e.mulScalar(h.square(C.alpha)),e.divByZerofier(3,C.xi),e.divByZerofier(3,C.xiw),y.F.add(t),y.F.add(e),y.F.degree()>=9*f.domainSize-6)throw Error("F Polynomial is not well calculated")}}async function D(){a&&a.info("> Computing challenge y");let t=new ar(g);t.addScalar(C.alpha),t.addPolCommitment(v.getPolynomial("W1")),C.y=t.getChallenge(),a&&a.info("\xb7\xb7\xb7 challenges.y: "+h.toString(C.y)),a&&a.info("> Computing L polynomial"),await o(),a&&a.info("> Computing ZTS2 polynomial"),await s();let e=y.ZTS2.evaluate(C.y);e=h.inv(e),y.L.mulScalar(e);let i=al.fromCoefficientsArray([h.neg(C.y),h.one],g);a&&a.info("> Computing W' = L / ZTS2 polynomial");let n=y.L.divBy(i);if(n.degree()>0)throw Error(`Degree of L(X)/(ZTS2(y)(X-y)) remainder is ${n.degree()} and should be 0`);if(y.L.degree()>=9*f.domainSize-1)throw Error("Degree of L(X)/(ZTS2(y)(X-y)) is not correct");a&&a.info("> Computing W' multi exponentiation");let r=await y.L.multiExponentiation(F,"W2");return v.addPolynomial("W2",r),0;async function o(){a&&a.info("\xb7\xb7\xb7 Computing L polynomial");let t=y.R0.evaluate(C.y),e=y.R1.evaluate(C.y),i=y.R2.evaluate(C.y),n=h.sub(C.y,E.S0.h0w8[0]);for(let t=1;t<8;t++)n=h.mul(n,h.sub(C.y,E.S0.h0w8[t]));let r=h.sub(C.y,E.S1.h1w4[0]);for(let t=1;t<4;t++)r=h.mul(r,h.sub(C.y,E.S1.h1w4[t]));let o=h.sub(C.y,E.S2.h2w3[0]);for(let t=1;t<3;t++)o=h.mul(o,h.sub(C.y,E.S2.h2w3[t]));for(let t=0;t<3;t++)o=h.mul(o,h.sub(C.y,E.S2.h3w3[t]));let s=h.mul(r,o),u=h.mul(C.alpha,h.mul(n,o)),w=h.mul(h.square(C.alpha),h.mul(n,r));b.denH1=r,b.denH2=o,y.L=al.fromPolynomial(y.C0,g,a),y.L.subScalar(t),y.L.mulScalar(s);let c=al.fromPolynomial(y.C1,g,a);c.subScalar(e),c.mulScalar(u);let d=al.fromPolynomial(y.C2,g,a);d.subScalar(i),d.mulScalar(w),y.L.add(c),y.L.add(d),a&&a.info("> Computing ZT polynomial"),await l();let m=y.ZT.evaluate(C.y);if(y.F.mulScalar(m),y.L.sub(y.F),y.L.degree()>=9*f.domainSize)throw Error("L Polynomial is not well calculated");delete p.L}async function l(){y.ZT=al.zerofierPolynomial([E.S0.h0w8[0],E.S0.h0w8[1],E.S0.h0w8[2],E.S0.h0w8[3],E.S0.h0w8[4],E.S0.h0w8[5],E.S0.h0w8[6],E.S0.h0w8[7],E.S1.h1w4[0],E.S1.h1w4[1],E.S1.h1w4[2],E.S1.h1w4[3],E.S2.h2w3[0],E.S2.h2w3[1],E.S2.h2w3[2],E.S2.h3w3[0],E.S2.h3w3[1],E.S2.h3w3[2]],g)}async function s(){y.ZTS2=al.zerofierPolynomial([E.S1.h1w4[0],E.S1.h1w4[1],E.S1.h1w4[2],E.S1.h1w4[3],E.S2.h2w3[0],E.S2.h2w3[1],E.S2.h2w3[2],E.S2.h3w3[0],E.S2.h3w3[1],E.S2.h3w3[2]],g)}}}let{unstringifyBigInts:aB}=l.utils;async function aG(t,e,a,i,n,r){let o=aB(t),l={type:"mem"};return await t7(o,e,l,n),await aF(a,l,i,r)}let{unstringifyBigInts:aQ}=l.utils;async function ax(t,e,a,i){var n;i&&i.info("FFLONK VERIFIER STARTED"),t=aQ(t),a=aQ(a);let r=await M(t.curve),o=((n=t).k1=r.Fr.fromObject(n.k1),n.k2=r.Fr.fromObject(n.k2),n.w=r.Fr.fromObject(n.w),n.w3=r.Fr.fromObject(n.w3),n.w4=r.Fr.fromObject(n.w4),n.w8=r.Fr.fromObject(n.w8),n.wr=r.Fr.fromObject(n.wr),n.X_2=r.G2.fromObject(n.X_2),n.C0=r.G1.fromObject(n.C0),n),l=new aa(r,i);l.fromObjectProof(a);let s=aQ(e);if(s.length!==o.nPublic)return i.error("Number of public signals does not match with vk"),!1;let u=r.Fr;if(i&&(i.info("----------------------------"),i.info("  FFLONK VERIFY SETTINGS"),i.info(`  Curve:         ${r.name}`),i.info(`  Circuit power: ${o.power}`),i.info(`  Domain size:   ${2**o.power}`),i.info(`  Public vars:   ${o.nPublic}`),i.info("----------------------------")),i&&i.info("> Checking commitments belong to G1"),!function(t,e,a){let i=t.G1;return i.isValid(e.polynomials.C1)&&i.isValid(e.polynomials.C2)&&i.isValid(e.polynomials.W1)&&i.isValid(e.polynomials.W2)&&i.isValid(a.C0)}(r,l,o))return i&&i.error("Proof commitments are not valid"),!1;if(i&&i.info("> Checking evaluations belong to F"),!(aU(r,l.evaluations.ql)&&aU(r,l.evaluations.qr)&&aU(r,l.evaluations.qm)&&aU(r,l.evaluations.qo)&&aU(r,l.evaluations.qc)&&aU(r,l.evaluations.s1)&&aU(r,l.evaluations.s2)&&aU(r,l.evaluations.s3)&&aU(r,l.evaluations.a)&&aU(r,l.evaluations.b)&&aU(r,l.evaluations.c)&&aU(r,l.evaluations.z)&&aU(r,l.evaluations.zw)&&aU(r,l.evaluations.t1w)&&aU(r,l.evaluations.t2w)))return i&&i.error("Proof evaluations are not valid."),!1;if(i&&i.info("> Checking public inputs belong to F"),!function(t,e){for(let a=0;a<e.length;a++)if(!aL(t,e[a]))return!1;return!0}(r,s))return i&&i.error("Public inputs are not valid."),!1;i&&i.info("> Computing challenges");let{challenges:f,roots:g}=function(t,e,a,i,n){let r=t.Fr,o={},l={},s=new ar(t);s.addPolCommitment(a.C0);for(let t=0;t<i.length;t++)s.addScalar(r.e(i[t]));s.addPolCommitment(e.polynomials.C1),o.beta=s.getChallenge(),s.reset(),s.addScalar(o.beta),o.gamma=s.getChallenge(),s.reset(),s.addScalar(o.gamma),s.addPolCommitment(e.polynomials.C2);let u=s.getChallenge(),f=r.square(u),g=[];g[1]=a.w8,g[2]=r.square(a.w8),g[3]=r.mul(g[2],a.w8),g[4]=r.mul(g[3],a.w8),g[5]=r.mul(g[4],a.w8),g[6]=r.mul(g[5],a.w8),g[7]=r.mul(g[6],a.w8);let h=[];h[1]=a.w4,h[2]=r.square(a.w4),h[3]=r.mul(h[2],a.w4);let w=[];w[1]=a.w3,w[2]=r.square(a.w3),l.S0={},l.S0.h0w8=[],l.S0.h0w8[0]=r.mul(f,u);for(let t=1;t<8;t++)l.S0.h0w8[t]=r.mul(l.S0.h0w8[0],g[t]);l.S1={},l.S1.h1w4=[],l.S1.h1w4[0]=r.square(l.S0.h0w8[0]);for(let t=1;t<4;t++)l.S1.h1w4[t]=r.mul(l.S1.h1w4[0],h[t]);l.S2={},l.S2.h2w3=[],l.S2.h2w3[0]=r.mul(l.S1.h1w4[0],f),l.S2.h2w3[1]=r.mul(l.S2.h2w3[0],w[1]),l.S2.h2w3[2]=r.mul(l.S2.h2w3[0],w[2]),l.S2.h3w3=[],l.S2.h3w3[0]=r.mul(l.S2.h2w3[0],a.wr),l.S2.h3w3[1]=r.mul(l.S2.h3w3[0],w[1]),l.S2.h3w3[2]=r.mul(l.S2.h3w3[0],w[2]),o.xi=r.mul(r.square(l.S2.h2w3[0]),l.S2.h2w3[0]),o.xiw=r.mul(o.xi,r.w[a.power]),o.xiN=o.xi,a.domainSize=1;for(let t=0;t<a.power;t++)o.xiN=r.square(o.xiN),a.domainSize*=2;return s.reset(),s.addScalar(u),s.addScalar(e.evaluations.ql),s.addScalar(e.evaluations.qr),s.addScalar(e.evaluations.qm),s.addScalar(e.evaluations.qo),s.addScalar(e.evaluations.qc),s.addScalar(e.evaluations.s1),s.addScalar(e.evaluations.s2),s.addScalar(e.evaluations.s3),s.addScalar(e.evaluations.a),s.addScalar(e.evaluations.b),s.addScalar(e.evaluations.c),s.addScalar(e.evaluations.z),s.addScalar(e.evaluations.zw),s.addScalar(e.evaluations.t1w),s.addScalar(e.evaluations.t2w),o.alpha=s.getChallenge(),s.reset(),s.addScalar(o.alpha),s.addPolCommitment(e.polynomials.W1),o.y=s.getChallenge(),n&&(n.info("\xb7\xb7\xb7 challenges.beta:  "+r.toString(o.beta)),n.info("\xb7\xb7\xb7 challenges.gamma: "+r.toString(o.gamma)),n.info("\xb7\xb7\xb7 challenges.xi:    "+r.toString(o.xi)),n.info("\xb7\xb7\xb7 challenges.alpha: "+r.toString(o.alpha)),n.info("\xb7\xb7\xb7 challenges.y:     "+r.toString(o.y))),{challenges:o,roots:l}}(r,l,o,s,i);i&&i.info("> Computing Zero polynomial evaluation Z_H(xi)"),f.zh=u.sub(f.xiN,u.one),f.invzh=u.inv(f.zh),i&&i.info("> Computing Lagrange evaluations");let h=await a_(r,f,o);i&&i.info("> Computing polynomial identities PI(X)");let w=function(t,e,a){let i=t.Fr,n=i.zero;for(let t=0;t<e.length;t++){let r=i.e(e[t]);n=i.sub(n,i.mul(r,a[t+1]))}return n}(r,s,h);i&&i.info("> Computing r0(y)");let c=function(t,e,a,i,n){let r=i.Fr,o=az(a.S0.h0w8,e.y,e.xi,i);n&&n.info("\xb7\xb7\xb7 Computing r0(y)");let l=r.zero;for(let e=0;e<8;e++){let i=[];i[1]=a.S0.h0w8[e];for(let t=2;t<8;t++)i[t]=r.mul(i[t-1],a.S0.h0w8[e]);let n=r.add(t.evaluations.ql,r.mul(t.evaluations.qr,i[1]));n=r.add(n,r.mul(t.evaluations.qo,i[2])),n=r.add(n,r.mul(t.evaluations.qm,i[3])),n=r.add(n,r.mul(t.evaluations.qc,i[4])),n=r.add(n,r.mul(t.evaluations.s1,i[5])),n=r.add(n,r.mul(t.evaluations.s2,i[6])),n=r.add(n,r.mul(t.evaluations.s3,i[7])),l=r.add(l,r.mul(n,o[e]))}return l}(l,f,g,r,i);i&&i.info("> Computing r1(y)");let d=function(t,e,a,i,n,r){let o=n.Fr,l=az(a.S1.h1w4,e.y,e.xi,n);r&&r.info("\xb7\xb7\xb7 Computing T0(xi)");let s=o.mul(t.evaluations.ql,t.evaluations.a);s=o.add(s,o.mul(t.evaluations.qr,t.evaluations.b)),s=o.add(s,o.mul(t.evaluations.qm,o.mul(t.evaluations.a,t.evaluations.b))),s=o.add(s,o.mul(t.evaluations.qo,t.evaluations.c)),s=o.add(s,t.evaluations.qc),s=o.add(s,i),s=o.mul(s,e.invzh),r&&r.info("\xb7\xb7\xb7 Computing C1(h_1_4^i) values");let u=o.zero;for(let e=0;e<4;e++){let i=t.evaluations.a;i=o.add(i,o.mul(a.S1.h1w4[e],t.evaluations.b));let n=o.square(a.S1.h1w4[e]);i=o.add(i,o.mul(n,t.evaluations.c)),i=o.add(i,o.mul(o.mul(n,a.S1.h1w4[e]),s)),u=o.add(u,o.mul(i,l[e]))}return u}(l,f,g,w,r,i);i&&i.info("> Computing r2(y)");let m=function(t,e,a,i,n,r,o){let l=r.Fr,s=function(t,e,a,i,n){let r=n.Fr,o=[],l=t[0].length,s=l*t.length,u=r.exp(e,s),f=r.mul(r.add(a,i),r.exp(e,l)),g=r.mul(a,i),h=r.add(r.sub(u,f),g),w=r.mul(r.mul(r.e(l),t[0][0]),r.sub(a,i));for(let a=0;a<l;a++){let i=t[0][(l-1)*a%l],n=r.sub(e,t[0][a]),s=r.mul(w,r.mul(i,n));o[a]=r.div(h,s)}w=r.mul(r.mul(r.e(l),t[1][0]),r.sub(i,a));for(let a=0;a<l;a++){let i=t[1][(l-1)*a%l],n=r.sub(e,t[1][a]),s=r.mul(w,r.mul(i,n));o[a+l]=r.div(h,s)}return o}([a.S2.h2w3,a.S2.h3w3],e.y,e.xi,e.xiw,r);o&&o.info("\xb7\xb7\xb7 Computing T1(xi)");let u=l.sub(t.evaluations.z,l.one);u=l.mul(u,i),u=l.mul(u,e.invzh),o&&o.info("\xb7\xb7\xb7 Computing T2(xi)");let f=l.mul(e.beta,e.xi),g=l.add(t.evaluations.a,l.add(f,e.gamma)),h=l.add(t.evaluations.b,l.add(l.mul(f,n.k1),e.gamma)),w=l.add(t.evaluations.c,l.add(l.mul(f,n.k2),e.gamma)),c=l.mul(g,l.mul(h,l.mul(w,t.evaluations.z))),d=l.add(t.evaluations.a,l.add(l.mul(e.beta,t.evaluations.s1),e.gamma)),m=l.add(t.evaluations.b,l.add(l.mul(e.beta,t.evaluations.s2),e.gamma)),A=l.add(t.evaluations.c,l.add(l.mul(e.beta,t.evaluations.s3),e.gamma)),p=l.mul(d,l.mul(m,l.mul(A,t.evaluations.zw))),y=l.sub(c,p);y=l.mul(y,e.invzh),o&&o.info("\xb7\xb7\xb7 Computing C2(h_2_3^i) values");let I=l.zero;for(let e=0;e<3;e++){let i=l.add(t.evaluations.z,l.mul(a.S2.h2w3[e],u));i=l.add(i,l.mul(l.square(a.S2.h2w3[e]),y)),I=l.add(I,l.mul(i,s[e]))}o&&o.info("\xb7\xb7\xb7 Computing C2(h_3_3^i) values");for(let e=0;e<3;e++){let i=l.add(t.evaluations.zw,l.mul(a.S2.h3w3[e],t.evaluations.t1w));i=l.add(i,l.mul(l.square(a.S2.h3w3[e]),t.evaluations.t2w)),I=l.add(I,l.mul(i,s[e+3]))}return I}(l,f,g,h[1],o,r,i);i&&i.info("> Computing F");let A=function(t,e,a,i,n){let r=t.G1,o=t.Fr,l=o.sub(i.y,n.S0.h0w8[0]);for(let t=1;t<8;t++)l=o.mul(l,o.sub(i.y,n.S0.h0w8[t]));i.temp=l;let s=o.sub(i.y,n.S1.h1w4[0]);for(let t=1;t<4;t++)s=o.mul(s,o.sub(i.y,n.S1.h1w4[t]));let u=o.sub(i.y,n.S2.h2w3[0]);for(let t=1;t<3;t++)u=o.mul(u,o.sub(i.y,n.S2.h2w3[t]));for(let t=0;t<3;t++)u=o.mul(u,o.sub(i.y,n.S2.h3w3[t]));i.quotient1=o.mul(i.alpha,o.div(l,s)),i.quotient2=o.mul(o.square(i.alpha),o.div(l,u));let f=r.timesFr(e.polynomials.C1,i.quotient1),g=r.timesFr(e.polynomials.C2,i.quotient2);return r.add(a.C0,r.add(f,g))}(r,l,o,f,g);i&&i.info("> Computing E");let p=function(t,e,a,i,n,r,o){let l=t.G1,s=t.Fr,u=s.mul(r,a.quotient1),f=s.mul(o,a.quotient2);return l.timesFr(l.one,s.add(n,s.add(u,f)))}(r,0,f,0,c,d,m);i&&i.info("> Computing J");let y=r.G1.timesFr(l.polynomials.W1,f.temp);i&&i.info("> Validate all evaluations with a pairing");let I=await aT(r,l,f,o,A,p,y);return i&&(I?i.info("PROOF VERIFIED SUCCESSFULLY"):i.warn("Invalid Proof")),i&&i.info("FFLONK VERIFIER FINISHED"),I}function aL(t,e){return l.Ru.lt(e,t.r)}function aU(t,e){return aL(t,l.Ru.fromRprLE(e))}async function a_(t,e,a){let i=t.Fr,n=Math.max(1,a.nPublic),r=new l.qc(n*i.n8),o=new l.qc(n*i.n8),s=i.one;for(let t=0;t<n;t++){let n=t*i.n8;r.set(i.mul(s,e.zh),n),o.set(i.mul(i.e(a.domainSize),i.sub(e.xi,s)),n),s=i.mul(s,a.w)}o=await i.batchInverse(o);let u=[];for(let t=0;t<n;t++){let e=t*i.n8;u[t+1]=i.mul(r.slice(e,e+i.n8),o.slice(e,e+i.n8))}return u}async function aT(t,e,a,i,n,r,o){let l=t.G1,s=l.timesFr(e.polynomials.W2,a.y);s=l.add(l.sub(l.sub(n,r),o),s);let u=t.G2.one,f=e.polynomials.W2,g=i.X_2;return await t.pairingEq(l.neg(s),u,f,g)}function az(t,e,a,i){let n=i.Fr,r=t.length,o=n.sub(n.exp(e,r),a),l=n.mul(n.e(r),n.exp(t[0],r-2)),s=[];for(let a=0;a<r;a++){let i=t[(r-1)*a%r],u=n.sub(e,t[a]);s[a]=n.div(o,n.mul(n.mul(l,i),u))}return s}let{unstringifyBigInts:aP}=l.utils;function aD(t){let e=t.toString(16);for(;e.length<64;)e="0"+e;return`0x${e}`}var aR=Object.freeze({__proto__:null,setup:aS,prove:aF,fullProve:aG,verify:ax,exportSolidityVerifier:e7,exportSolidityCallData:async function(t,e){let a=aP(e),i=aP(t);await M(a.curve);let n="";for(let t=0;t<i.length;t++)""!==n&&(n+=","),n+=aD(i[t]);return`[${aD(a.polynomials.C1[0])}, ${aD(a.polynomials.C1[1])},${aD(a.polynomials.C2[0])},${aD(a.polynomials.C2[1])},${aD(a.polynomials.W1[0])},${aD(a.polynomials.W1[1])},${aD(a.polynomials.W2[0])},${aD(a.polynomials.W2[1])},${aD(a.evaluations.ql)},${aD(a.evaluations.qr)},${aD(a.evaluations.qm)},${aD(a.evaluations.qo)},${aD(a.evaluations.qc)},${aD(a.evaluations.s1)},${aD(a.evaluations.s2)},${aD(a.evaluations.s3)},${aD(a.evaluations.a)},${aD(a.evaluations.b)},${aD(a.evaluations.c)},${aD(a.evaluations.z)},${aD(a.evaluations.zw)},${aD(a.evaluations.t1w)},${aD(a.evaluations.t2w)},${aD(a.evaluations.inv)}],[${n}]`}})}}]);